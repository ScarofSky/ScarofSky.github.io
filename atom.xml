<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天の痕的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-06-02T13:33:35.727Z</updated>
  <id>/</id>
  
  <author>
    <name>天の痕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图论算法</title>
    <link href="/2020/06/01/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    <id>/2020/06/01/图论算法/</id>
    <published>2020-06-01T14:16:01.000Z</published>
    <updated>2020-06-02T13:33:35.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h1><h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>使用邻接矩阵存储图更为合理，因为floyd算法要求每两个点之间的最短路径。循环顺序是kij其中k是阶段，从ik到kj点的最短路径由松弛操作<br>$$<br>g[i][j] = min(g[i][j], g[i][k] + g[k][j])<br>$$<br>给出。当有重边和自环时，每两个点之间存储的<code>g[i][j]</code>只存储最短的一条即可。</p><p>总结：图论算法主要包括几部分，有最短路径、最小生成树。下图可以比较清楚地将最短路径算法分类。</p><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>使用dist数组来维护所有点到源点的最短距离，用st数组维护已经确定最短距离的点。st数组一定要从空集开始，这样才能更新1号点。从所有点中选择距离源点最近的点来更新，将其所有临接点到源点的最短距离更新。最终更新了n个点后，所有点到达最短距离。时间复杂度为O(n^2)。</p><h3 id="堆优化的Dijkstra"><a href="#堆优化的Dijkstra" class="headerlink" title="堆优化的Dijkstra"></a>堆优化的Dijkstra</h3><p>维护一个堆，堆中储存一对信息（距离源点距离，当前点序号），从而每次得到距离源点最近的点的编号，扩展所有邻接点。这里不能保证每个点只入堆一次，因此当第一次从堆出来以后，再出来的就是错误的更新点，因此continue。时间复杂度因为有堆进行优化，所以是O(nlogn)。</p><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman Ford"></a>Bellman Ford</h3><p>可以求解不超过k条边的最短路径，通过k次循环，每次备份dist数组，每次遍历所有的边，通过上次dist数组更新本次dist数组，可以求取负边权的情况。时间复杂度是O(km)，因为每次经过k次迭代，每次迭代m条边。</p><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>SPFA算法是队列优化的Bellman Ford算法，由于Bellman Ford算法需要k次更新所有的边，但是其中某些边在没有最短路径涉及时不需要更新。SPFA算法通过维护队列，将每次被更新的点加入队列，每次只更新队列内部的点，这样就减少了很多不必要点的更新操作。队列里是所有被更新过的点，因此可以维护st数组，当某个点被多个点更新时，就不用重复进入队列作为一下步扩展更新了。时间复杂度是O(nm)，但是实际上会比这个复杂度快很多。</p><h3 id="SPFA判断负环"><a href="#SPFA判断负环" class="headerlink" title="SPFA判断负环"></a>SPFA判断负环</h3><p>SPFA算法当队列不空的时候就会不断的更新图中路径的最短值，每次更新相当于多走一条边，当有负环的时候，某些节点一定会被无限次更新到负无穷，因此用cnt数组来记录每一个点的被更新次数，当某个点更新次数大于n – 1时，说明存在一条路径当我更新n – 1次之后，还可以更小，这样就是存在负环了。开始时一定要把所有点都加入到队列中，否则只更新某一个点，也许去其他点的路径可以不经过负环，也就不会无限更新，就找不到负环来判断。</p><h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>用st数组维护一个集合，最开始为空，每次扩充一个距离当前集合最近的点进入集合，并且更新其他点到集合的最近距离。所有点到集合的初始最近距离为INF，将所有点均加入到集合时算法结束。如果某一次扩充的点到集合的最近距离为正无穷，则说明不存在最小生成树。</p><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>通过排序得到所有边的序列，从最小的边开始扩展，贪心的思路。维护一个并查集来确定两个点是否属于同一个集合，如果属于同一个集合的两个点还需要增加一条边，则该条边增加后则成环。因此维护一个计数器cnt，当算法结束之后，cnt如果小于n – 1则说明不存在有效的生成树，否则并查集维护的点就是当前生成树。</p>]]></content>
    
    <summary type="html">
    
      图论算法总结
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>读书笔记</title>
    <link href="/2020/06/01/%E8%AF%BB%E4%B9%A6/"/>
    <id>/2020/06/01/读书/</id>
    <published>2020-06-01T14:16:01.000Z</published>
    <updated>2020-06-02T14:17:22.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><p>近期更新，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      读书笔记
    
    </summary>
    
      <category term="读书" scheme="/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="/2020/06/01/%E9%9A%8F%E7%AC%94/"/>
    <id>/2020/06/01/随笔/</id>
    <published>2020-06-01T14:16:01.000Z</published>
    <updated>2020-06-03T16:11:01.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><p>近期更新，敬请期待~</p><p><img src="https://i.loli.net/2020/06/04/EYoizIZMWBd1uUT.jpg" alt="71446588_p0.jpg"></p><p><img src="https://i.loli.net/2020/06/04/kKDe6bBL9pF7dTH.jpg" alt="66189513_p0.jpg"></p><p><img src="https://i.loli.net/2020/06/04/nci6rqb2mXsYWJa.jpg" alt="79998863_p0.jpg"></p><p><img src="https://i.loli.net/2020/06/04/2Mv8V3kpd4rsCfW.png" alt="68751597_p0.png"></p>]]></content>
    
    <summary type="html">
    
      随笔
    
    </summary>
    
      <category term="随笔" scheme="/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>生活</title>
    <link href="/2020/06/01/%E7%94%9F%E6%B4%BB/"/>
    <id>/2020/06/01/生活/</id>
    <published>2020-06-01T14:16:01.000Z</published>
    <updated>2020-06-02T14:14:47.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>近期更新，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      生活
    
    </summary>
    
      <category term="生活" scheme="/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
</feed>
