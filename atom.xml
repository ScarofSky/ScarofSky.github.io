<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天の痕的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-06-12T13:34:40.409Z</updated>
  <id>/</id>
  
  <author>
    <name>天の痕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划（一）背包专题</title>
    <link href="/2020/06/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E8%83%8C%E5%8C%85%E4%B8%93%E9%A2%98/"/>
    <id>/2020/06/12/动态规划（一）背包专题/</id>
    <published>2020-06-12T08:06:40.000Z</published>
    <updated>2020-06-12T13:34:40.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背包专题"><a href="#背包专题" class="headerlink" title="背包专题"></a>背包专题</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>dp[i][j]</code>表示考虑到第i个元素时，背包容量为j的情况下的最大价值。初始条件为<code>dp[0][i]</code> = 0，表示当考虑前0个物品时，无论背包容量为多少，最大价值都是0。状态转移方程可以通过定义得到，当前状态由前一个状态拿当前物品i或者不拿当前物品i转移过来。一维空间形式循环顺序要从m到v[i]，原因是省略了i - 1维度。</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])</script><script type="math/tex; mode=display">dp[j] = max(dp[j], dp[j - v[i] + w[i]]), j ∈(m,v[i])</script><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">for (int i = 1; i &lt;= n; i ++ )    for (int j = m; j &gt;= v[i];j -- )        f[j] = max(f[j], f[j - v[i]] + w[i]);</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">AW.2 01背包问题（简单）</a></p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>如果按照01背包的状态定义和状态转移方程思维方式，我们不难得出如下的状态转移方程。</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i], ... , dp[i - 1][j - s * v[i]] + s * w[i]);</script><p>如果直接循环则需要3重循环来实现，但是我们发现上述部分项已经计算过了。</p><script type="math/tex; mode=display">dp[i][j - v[i]] + w[i] = max(dp[i - 1][j - v[i]] + w[i], dp[i - 1][j - 2 * v[i]] + 2 * w[i] , ... , dp[i - 1][j - s * v[i]] + s * w[i]);</script><p>所以<code>dp[i][j]</code>可以进行简化为：</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]), j∈(v[i], m)</script><p>如果化简为一维形式，由于需要简化的是<code>dp[i][j - v[i]]</code>，应该体积从小到大循环。这里可以优化的原因是，体积一定的情况下，如果可以随意拿取，那么拿取的s件一定是固定值，注意和下边的多重背包区分。</p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">for (int i = 1; i &lt;= n; i ++ )    for (int j = v[i]; j &lt;= m; j ++ )        f[j] = max(f[j], f[j - v[i]] + w[i]);</code></pre><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">AW. 完全背包问题（简单）</a></p><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">LC.322 零钱兑换（中等）</a></p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><ul><li>多重背包问题可以使用三重循环直接暴力求解，也可以使用二进制优化。暴力求解和上述完全背包问题相似，在于每次要确定s个物品，这里无法进行完全背包的优化，因为每次求解的s并不是固定值。</li><li>二进制优化的原理是将多个物品打包成一个物品来看，将最多选s个物品的问题转化成log(s)个物品的 01背包问题，从而降低复杂度。可以证明每次选取1,2,4,8,16…(s- 2^k - 1)个物品打包之后，每个物品选与不选的组合（看做01背包）可以得到s种结果。这里二进制优化的思想很有意思，可以类比快速幂和龟速乘。</li></ul><h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//暴力求解多重背包问题for (int i = 1; i &lt;= n; i ++ )    for (int j = 0; j &lt;= m; j ++ )        for (int t = 0; t &lt;= s[i]; t ++ )            if (j - s * v[i] &gt;= 0)                f[i][j] = max(f[i][j], f[i - 1][j - s * v[i]] + s * w[i]);//二进制优化#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 12010, M = 2010;int V[N], W[N];int idx;int n, m;int f[M];int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    //对于每一个物品将s件拆解成log(s)件打包的物品    for (int i = 0; i &lt; n; i ++ )    {        int v, w, s;        scanf(&quot;%d%d%d&quot;, &amp;v, &amp;w, &amp;s);        int k = 1;        while (k &lt;= s)        {            ++ idx;            V[idx] = k * v;            W[idx] = k * w;            s -= k;            k *= 2;        }        //如果还有剩余不满足2的幂次也要打包        if (s)        {            ++ idx;            V[idx] = s * v;            W[idx] = s * w;        }    }    //用01背包求解    for (int i = 1; i &lt;= idx; i ++ )        for (int j = m; j &gt;= V[i]; j -- )            f[j] = max(f[j], f[j - V[i]] + W[i]);    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><p><a href="https://www.acwing.com/problem/content/4/" target="_blank" rel="noopener">AW.4 多重背包问题I（简单）</a></p><p><a href="https://www.acwing.com/problem/content/5/" target="_blank" rel="noopener">AW.5 多重背包问题II（中等）</a></p><p>第二题主要考察二进制优化</p><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>分组背包问题指有很多物品组，从每组中只能挑选一个物品，求最大价值。分组背包是有依赖的背包问题的前序问题。</p><h3 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h3>]]></content>
    
    <summary type="html">
    
      动态规划背包专题
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>未分类题目</title>
    <link href="/2020/06/12/%E9%A2%98%E5%BA%93%E9%A2%98%E8%A7%A3/"/>
    <id>/2020/06/12/题库题解/</id>
    <published>2020-06-12T06:50:30.000Z</published>
    <updated>2020-06-12T06:57:07.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题库"><a href="#题库" class="headerlink" title="题库"></a>题库</h1><h2 id="题库-题解"><a href="#题库-题解" class="headerlink" title="题库+题解"></a>题库+题解</h2><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LC.15 三数之和（中等）</a></p><p>排序+双指针，排序加上双指针可以简化定和搜索。排序可以将相同元素邻接。时间复杂度O(n^2)。</p><pre><code class="lang-c++">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {        vector&lt;vector&lt;int&gt;&gt; ans;        sort(nums.begin(), nums.end());        for (int i = 0; i &lt; nums.size(); i ++ )        {            //因为要不重复，所以当前如果在之前出现过就跳过，排序的好处体现在这里            if (i - 1 &gt;=0 &amp;&amp; nums[i - 1] == nums[i]) continue;            int target = -nums[i];            //第i个左边的都遍历过了，只考虑右边即可。            int l = i + 1, r = nums.size() - 1;            //双指针过程            while (l &lt; r)            {                if (nums[l] + nums[r] &lt; target) l ++ ;                else if (nums[l] + nums[r] &gt; target) r -- ;                else                 {                    vector&lt;int&gt; cur;                    cur.push_back(nums[i]);                    cur.push_back(nums[l]);                    cur.push_back(nums[r]);                    ans.push_back(cur);                    //重复的直接跳过                    while (l + 1 &lt;= nums.size() - 1 &amp;&amp; nums[l + 1] == nums[l]) l ++ ;                    while (r - 1 &gt;= 0 &amp;&amp; nums[r - 1] == nums[r]) r -- ;                    l ++ , r -- ;                }            }        }        return ans;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      题库
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>离散化</title>
    <link href="/2020/06/11/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <id>/2020/06/11/离散化/</id>
    <published>2020-06-11T11:28:11.000Z</published>
    <updated>2020-06-11T11:28:14.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="通过哈希表进行离散化"><a href="#通过哈希表进行离散化" class="headerlink" title="通过哈希表进行离散化"></a>通过哈希表进行离散化</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;建立一个哈希表，通过每次将新的值映射为一个递增的n来达到离散化的目的。这种离散化不要求顺序，只需要值的对应即可。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">int find(int x){    if (S.count(x) == 0) S[x] = ++ n;    return S[x];}</code></pre><p><img src="https://i.loli.net/2020/06/11/Ghvsez17FXYmINB.jpg" alt></p><h2 id="排序-去重-二分查找进行离散化"><a href="#排序-去重-二分查找进行离散化" class="headerlink" title="排序+去重+二分查找进行离散化"></a>排序+去重+二分查找进行离散化</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;当要求有序的离散化时，需要将需要离散化的坐标排序，之后去重，最后使用二分查找获得映射后的坐标。这里其实相当于将排序后的数组下标作为离散化后的值。这种离散化的好处就是保序，当计算原下标3-7之间的结果时，直接计算离散化之后find(3)-find(7) = 3 - 5之间的结果即可。</p><p><img src="https://i.loli.net/2020/06/11/vIzDqYwVsuAeUaN.jpg" alt></p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">int find(int x){    int l = 0, r = n - 1;    while (l &lt; r)    {        int mid = l + r &gt;&gt; 1;        if (a[mid] &gt;= x) r = mid;        else l = mid + 1;    }    return r;}//排序+去重sort(pts.begin(), pts.end());pts.erase(unique(pts.begin(), pts.end()), pts.end());</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/804/" target="_blank" rel="noopener">AW.802 区间和（简单）</a></p>]]></content>
    
    <summary type="html">
    
      离散化模板和常见套路
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="/2020/06/11/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>/2020/06/11/快速幂/</id>
    <published>2020-06-11T06:12:16.000Z</published>
    <updated>2020-06-11T06:50:00.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;可以在log(k)的时间复杂度下计算a^k (mod p)的值。将k以2进制展开，其中的每一个1相当于乘以a^(2^m)。</p><p>假设 k的二进制表示为10010101:</p><script type="math/tex; mode=display">a^k = a^{2^0} * a^{2^2} * a^{2^4} * a^{2^7}</script><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">LL qmi(LL a, LL k, LL p){    LL res = 1;    while (k)    {        if (k &amp; 1)        {            res = res * a % p;            a = a * a % p;        }        k &gt;&gt;= 1;    }    return res;}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/877/" target="_blank" rel="noopener">AW.875 快速幂（简单）</a></p><p><a href="https://www.acwing.com/problem/content/878/" target="_blank" rel="noopener">AW.876 快速幂求逆元（简单）</a></p><p>快速幂求逆元用到了费马小定理，是扩展欧几里得定理的一个特例</p>]]></content>
    
    <summary type="html">
    
      快速幂模板
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>单调栈与单调队列</title>
    <link href="/2020/06/10/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <id>/2020/06/10/单调栈与单调队列/</id>
    <published>2020-06-10T14:58:03.000Z</published>
    <updated>2020-06-11T03:19:04.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调栈与单调队列"><a href="#单调栈与单调队列" class="headerlink" title="单调栈与单调队列"></a>单调栈与单调队列</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;单调栈使用范围比较小，已知有两种用法，其中第一种用法比较经典，用的较多，第二种用法出现较少。</p><ol><li><p><strong>寻找数组中某一个数左边、右边第一个比它大或小的数</strong>。首先要找到最近的一个数，并且满足这个数和当前数的单调关系（比它大或者小）。栈的特点是后进先出，在这里其实利用了栈“<strong>最近</strong>”的思想，而单调性能够确保与栈顶比较时，相当于比较了所有之前的数据，降低了时间复杂度。</p><p>&emsp;&emsp;Condition 1 ：以寻找数列中每一个数左边第一个比它小的数为例，如果使用单调递增栈，<strong>当前元素大于栈顶元素</strong>，则相当于大于栈中所有元素，当前元素左侧第一个比它小的数就是栈顶元素；</p><p>&emsp;&emsp;Condition 2 ：如果<strong>当前元素小于栈顶元素</strong>，那么当前元素<strong>左侧比当前元素还大的</strong>那些元素（即已经在栈中）就永远不需要考虑了（我要找的是更小的！），并且可以在这个过程中直接出栈。原因是，这些出栈的元素在更靠后的元素考虑时，肯定不会是答案，因为使得这个元素出栈的元素，会距离更近且更小，具体看下图会更加清晰。可以看到，4号元素在找左侧更小的元素时，一定不会找到2号元素，因为3号元素一定更早被选择。</p><p><img src="https://i.loli.net/2020/06/10/nPoi2mMvOVHt1uy.jpg" alt></p></li><li><p><strong>寻找数组中两个数之间满足i &lt; j 且 A[i] &lt;= A[j]的情况下，下标之间的最大距离</strong>。这种可以看做<strong>全局的单调性和“最近”性质</strong>的应用，并且还有<strong>双指针</strong>的思想。这里有个重点是，当从右向左考虑元素时，只需要考虑当前元素左侧是否会产生最大值，不用考虑右侧的情况，因为右侧已经考虑过了。首先从左向右初始化单调递减栈，之后从右向左每次元素和栈顶元素比较，通过出栈每次确认当前最小的元素是否更新了答案，直到栈顶元素大于当前遍历元素：</p><p>&emsp;&emsp;Condition 1 ：如果当前元素小于栈顶（当前最小值），则栈内其他元素均不满足A[i] &lt;= A[j]的要求，更进一步说明栈顶元素左侧所有元素均无法产生答案；栈顶右侧元素一定已经和当前元素右侧的元素更新过答案（因此才被弹出栈），所以再和当前元素产生的答案，肯定无法更新答案（从右向左，每次都在递减）。</p><p>&emsp;&emsp;Condition 2 ：如果当前元素大于栈顶，由于栈顶元素右边的元素更靠近序列右侧，所以最大距离一定更小，即便和当前元素能产生正确大小关系，也不会更新答案。之后我们无法确定左侧元素是否还能继续产生更大答案，所以栈顶元素出栈，继续比较。能够安全出栈的原因是，右侧当前元素每次都在减少，因此贪心的认为，之后即便有满足要求的元素，也不会更新最大距离（与第一种情况的栈顶右侧元素一致）。</p></li></ol><p>&emsp;&emsp;假设序列是 <strong><u>A</u> <u>B</u> C <u>D</u> E F G H</strong>，从左到右入递减栈的是A B D，那么假设当前元素为G：</p><ol><li>如果G &gt;= D，D出栈，考虑B，如果G &gt;= B, 即使G &gt;= C没有产生更大答案，如果G &lt; B，因为从左到右是单调栈，因此C &gt; B, 若G &gt; C，可以推导出C &lt; G &lt; B, B &gt; C，冲突，所以不用考虑G &gt; C的情况。</li><li>如果G &lt; D,  比最小值还小，那么栈顶元素左侧没有可以满足条件的情况；而右侧E F即便有更小，也无法更新答案。</li></ol><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//寻找数组中某一个数左边第一个比他大的数for (int i = 0; i &lt; n; i ++ ){    while (!st.size() &amp;&amp; s[i] &gt;= st.top()) st.pop();    if (st.size()) cout &lt;&lt; st.top() &lt;&lt; &quot; &quot;;    else cout &lt;&lt; &quot;-1 &quot;;    st.push(s[i]);}//寻找i &lt; j 且 A[i] &lt; A[j]条件的最大j - istack&lt;int&gt; st;int n = A.size();for (int i = 0; i &lt; n; i ++ )    if (st.empty() || A[i] &lt; A[st.top()])        st.push(i);int ans = 0;for (int i = n - 1; i &gt;= 0; i -- ){    while (st.size() &amp;&amp; A[i] &gt;= A[st.top()])    {        ans = max(ans, i - st.top());        st.pop();    }    if (!st.size()) break;}return ans;</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/832/" target="_blank" rel="noopener">AW.830 单调栈（简单）</a></p><p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">LC.739 每日问题（中等）</a></p><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">LC.42 接雨水（困难）</a></p><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">LC.84 柱状图中最大的矩形（困难）</a></p><p><a href="https://leetcode-cn.com/problems/maximum-width-ramp/" target="_blank" rel="noopener">LC.962 最大宽度坡（中等）</a></p><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;单调队列是队头维护的是整个队列中最大或者最小的元素，每次有新元素入队时，如果不满足当前队列维护的单调性，则将所有不满足的元素全部出队。单调队列本质是一个双端队列，每次出队时是从队尾出队，而不是从队头出队。<strong>单调队列可以解决滑动窗口的最值问题</strong>，以及与之相关的优化。</p><p>&emsp;&emsp;单调队列操作顺序也比较重要，在不同需要的时候有不同的操作顺序。</p><ol><li>计算是否当前元素和队头元素距离之差大于规定值，如果大于则队头出队。</li><li>计算答案，此时是计算的[0, r - 1]范围内的最值，因此放在第二步。</li><li>保持队列单调性，while循环从队尾出队。</li><li>将当前元素入队。</li><li>*若计算答案在这里，则是求的[0, r]范围内的最值。</li></ol><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//k是窗口大小, 计算最大值, 手动模拟队列int q[N];int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ ){    if (hh &lt;= tt &amp;&amp; i - q[hh] + 1 &gt; k) hh ++ ;    while (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) tt -- ;    q[++ tt ] = i;    if (i &gt;= k - 1) cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;;}</code></pre><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/156/" target="_blank" rel="noopener">AW.154 滑动窗口（简单）</a></p>]]></content>
    
    <summary type="html">
    
      单调栈和单调队列总结
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="/2020/06/08/KMP%E7%AE%97%E6%B3%95/"/>
    <id>/2020/06/08/KMP算法/</id>
    <published>2020-06-08T14:02:01.000Z</published>
    <updated>2020-06-08T14:02:23.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;KMP算法核心是ne数组，其定义是：<strong>从0（空串）到第i个模板串字符的子串为止，子串中前缀和后缀相等的最大长度，其中前缀和后缀不包括子串本身。</strong></p><p>&emsp;&emsp;举例来说，对于字符串ababab（按照下标从1开始存储，更为方便）：</p><ul><li>ne[0]总是0的原因是空串最长前缀也是0。</li><li>ne[1] = 0的原因是长度为1的子串前缀如果<strong>不包括子串本身</strong>，也只有长度为0的空串，因此也是0。</li><li>ne[2] = 0，(ab)abab此时子串ab的前缀没有和后缀相等的匹配。</li><li>ne[3] = 1，(aba)bab的前缀可以看到下s[1] = a和s[3] = a相等。</li><li>ne[4] = 2，(abab)ab的前缀可以看到{s[1], s[2]} = ab和{s[3], s[4]} = ab相等，这里由于只增加了一个字母，且当前最长前缀用到了长度为3子串时的最长前缀，所以最长前缀长度<strong>最多增加1</strong>，这一点很重要，是<strong>动态规划的思想</strong>。</li><li>ne[5] = 3，(ababa)b，可以看到{s[1], s[2], s[3]} = aba和{s[3], s[4], s[5]} = aba相等。</li><li>ne[6] = 4，（ababab), abab = abab。</li></ul><p>&emsp;&emsp;通过ne数组的定义，我们可以知道，当模板串和匹配串两个字符不匹配的时候，此时模板串的匹配位置就不必向后错一个位置继续从头匹配，而是从下一个前缀已经匹配完全的位置开始。</p><p>&emsp;&emsp;这里通过将开始下标设置为1，之前定义的ne数组是前后缀的最大长度，正好也是当不匹配时，模板串应该移动到的下标位置。</p><p>&emsp;&emsp;KMP算法求模板串ne数组的方法实际上是一种动态规划。每次使用了之前模板串中相同的长度，并且每次最长前缀最多+1，来计算下一次的最长前缀。当无法匹配的时候，正好通过定义j = ne[j]来跳到最大匹配位置继续。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//n是模板串长度，m是匹配串长度//p存储模板串，s存储匹配串//产生ne数组的过程，模板串自己和自己匹配for (int i = 2, j = 0; i &lt;= n; i ++ ){    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];    if (p[i] == p[j + 1]) j ++ ;    ne[i] = j;}//在匹配串中匹配的过程for (int i = 1, j = 0; i &lt;= m; i ++ ){    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];    if (s[i] == p[j + 1]) j ++ ;    if (j == n)    {        //输出位置etc.        j = ne[j];    }}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/833/" target="_blank" rel="noopener">AW.831 KMP字符串（简单）</a></p>]]></content>
    
    <summary type="html">
    
      KMP算法
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="/2020/06/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>/2020/06/08/二分查找/</id>
    <published>2020-06-08T13:40:00.000Z</published>
    <updated>2020-06-08T13:44:05.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="二分查找元素"><a href="#二分查找元素" class="headerlink" title="二分查找元素"></a>二分查找元素</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;二分使用的条件是有<strong>单调性</strong>，比如有序的序列，事实上二分是<strong>分治算法</strong>思想。本质是将问题抽象化为<strong>找一个分界面</strong>，分界面左边不满足某一性质，而右边满足某一个性质。这时候左边边界缩减时需要多缩减一个，因为左边不满足性质；右边边界缩减到当前mid，不用多缩减。下边代码的check函数即是满足某种性质的判断函数，当满足性质时返回 true, 不满足时返回false。</p><p>&emsp;&emsp;当搜素结束时，左右边界重合，即<code>l == r</code>。如果有<code>l = mid</code>的情况，需要<code>l + r + 1 &gt;&gt; 1</code>才能够避免最后两个数相邻时，mid永远更新为左边界的死循环。</p><p>&emsp;&emsp;二分查找分为整数二分和浮点数二分，浮点数查找时原理相同，但是要求精度小于一定数时停止。浮点数二分比整数二分容易很多，不需要考虑很多边界条件的情况。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//每次右边界缩减为mid的情况while (l &lt; r){    int mid = l + r &gt;&gt; 1;    if (check(mid)) r = mid;    else l = mid + 1;}//每次左边界缩减为mid的情况while (l &lt; r){    int mid = l + r + 1 &gt;&gt; 1;    if (check(mid)) l = mid;    else r = mid + 1;}//浮点数二分const double eps = 1e-8;while (r - l &gt; eps){    int mid = l + r / 2.0;    if (check(mid)) l = mid;    else r = mid;}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">LC.704 二分查找（简单）</a></p><p><a href="https://www.acwing.com/problem/content/792/" target="_blank" rel="noopener">AW.790 数的三次方根（简单）</a></p><p><a href="https://www.acwing.com/problem/content/791/" target="_blank" rel="noopener">AW.789 数的范围（简单）</a></p><h2 id="二分搜索答案"><a href="#二分搜索答案" class="headerlink" title="二分搜索答案"></a>二分搜索答案</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;答案很多时候是<strong>有范围的</strong>，当某一个问题<strong>验证某一个答案</strong>的时间复杂度乘以二分区间范围的log时，可以考虑搜索答案。通过不断的尝试排除错误答案，且是以指数速度排除，最终得到正确答案。这里一般在验证答案的时候，可以采用某种程度的贪心策略，并且将原问题中单调性质进行转化，能够通过一次的验证缩小答案范围。</p><p>&emsp;&emsp;这类题往往不是简单的搜索答案，而是将问题某种程度的转化之后，再搜索答案。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/104/" target="_blank" rel="noopener">AW.102 最佳牛围栏（简单）</a></p><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LC.287 寻找重复数（中等）</a></p>]]></content>
    
    <summary type="html">
    
      二分查找模板和常见套路
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>BFS</title>
    <link href="/2020/06/04/BFS/"/>
    <id>/2020/06/04/BFS/</id>
    <published>2020-06-04T06:26:01.000Z</published>
    <updated>2020-06-08T05:34:21.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><h2 id="采坑"><a href="#采坑" class="headerlink" title="采坑"></a>采坑</h2><pre><code class="lang-c++">while (q.size()){    int len = q.size();    for (int i = 0; i &lt; len; i ++ )    {        auto t = q.front();        int x = t.first, y = t.second;        q.pop();        //如果是这里标记，队列里面有大量相同元素，虽然不影响最终得到正确结果，但是效率很低        //A[x][y] = -1;        for (int i = 0; i &lt; 4; i ++ )        {            int a = x + dx[i], b = y + dy[i];            if (a &lt; 0 || a &gt;= A.size() || b &lt; 0 || b &gt;= A[0].size()) continue;            if (A[a][b] == -1) continue;            if (A[a][b] == 1) return dis;            //就是这里要在入队之前将当前入队元素标记为已经遍历            A[a][b] = -1;            q.push({a, b});        }    }    dis ++ ;}</code></pre>]]></content>
    
    <summary type="html">
    
      BFS
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="/2020/06/04/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>/2020/06/04/位运算/</id>
    <published>2020-06-04T06:26:01.000Z</published>
    <updated>2020-06-08T05:30:25.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h3 id="亦或运算"><a href="#亦或运算" class="headerlink" title="亦或运算"></a>亦或运算</h3><p>&emsp;&emsp;亦或运算本质是定义了一组操作，0^0 = 0, 1^1 = 0, 1^0 = 1, 0^1 = 1，描述为相同为0，不同为1。从定义来看，可以判断两个数是否相同，如果为0则相同，为1则不同。进一步，由于有结合律，可以消除一个序列中所有相同的数组，即a^b^c = (a^b)^c = a^(b^c)。在进一步思考，其实所有能够满足上述运算规律的情况都可以用亦或运算来实现，简单有效。比如无进位二进制加法，实际上与0+0 = 0, 1+1 = 0, 1+0 = 1, 0+1 = 1相同。奇偶性检验，如果我们把奇数看做1，偶数看做0，则有0+0 = 0, 1+1 = 0, 1 + 0 = 1, 0 + 1 = 1，和亦或操作一样。凡是有两个相反、相对的状态，都可以抽象为 0 和 1。另外对于奇偶性一般都会有简单的考察：奇数+奇数 = 偶数，以及奇数 - 1 = 偶数这两条基本性质。</p><p>​     状态压缩题目中一般应用按位与、或和亦或运算会将状态之间的转换变得容易很多。包括如果想取得某一位的状态，可以用 i &gt;&gt; j &amp; 1来计算。</p>]]></content>
    
    <summary type="html">
    
      位运算
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划（二）其他DP</title>
    <link href="/2020/06/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E5%85%B6%E4%BB%96DP/"/>
    <id>/2020/06/04/动态规划（二）其他DP/</id>
    <published>2020-06-04T06:26:01.000Z</published>
    <updated>2020-06-08T05:29:22.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="其他DP"><a href="#其他DP" class="headerlink" title="其他DP"></a>其他DP</h1><h3 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h3><p>区间DP是在区间上进行动态规划，本质是用更小区间的最优解来求更大区间的最优解。一般的模板都是这样的：</p><pre><code class="lang-c++">for (int len = 2; len &lt;= n; len ++ )    for (int i = 1; i + len - 1 &lt;= n; i ++ )    {        int j = i + len - 1;        for (int k = i; k &lt; j; k ++ )            f[i][j] = mamx(f[i][j], f[i][k] + f[k][j] + ****);    }</code></pre><h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><p>状压DP分为两类，一类是棋盘式（基于连通性）的模型，另一类是基于集合。</p><p>  棋盘式：蒙德里安的梦想这道题，是求把N<em>M的棋盘分割成若干个1</em>2的的长方形，有多少种方案。通过将每一列看成一个状态，其中放了小块的格子为1，没放的为0，这样可以通过枚举所有的状态到状态的转移来进行计数。</p><p>  基于集合：最短哈密尔顿路径，给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。对所有点构成的集合考虑，已经走过的点为1，还没有到达过的点为0，可以确定一个n位状态state，但如果需要从一个点转移到下一个点，则还需要记录当前停在了哪一个点上。因此用f[state][j]表示到达j号点时，已经走过的状态为state的路径集合中的最小值。</p><p>  因此可以得到状态转移方程：</p><script type="math/tex; mode=display">f[state][j] = min(f[state][j], f[state - (1 << k)][k] + w[k][j]);</script>]]></content>
    
    <summary type="html">
    
      动态规划其他DP
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>欧几里得算法</title>
    <link href="/2020/06/04/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <id>/2020/06/04/欧几里得算法/</id>
    <published>2020-06-04T06:26:01.000Z</published>
    <updated>2020-06-11T07:06:36.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;gcd可以计算两个数的最大公约数。欧几里得算法通过递归来计算最大公约数。基本情况是当b为0时，a和b的最大公约数就是a。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">int gcd(int a, int b){    return b ? gcd(b, a % b) : a;}</code></pre><h1 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h1>]]></content>
    
    <summary type="html">
    
      欧几里得算法
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>高精度</title>
    <link href="/2020/06/04/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <id>/2020/06/04/高精度/</id>
    <published>2020-06-04T06:26:01.000Z</published>
    <updated>2020-06-08T05:16:58.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h3 id="高精度加法和乘法"><a href="#高精度加法和乘法" class="headerlink" title="高精度加法和乘法"></a>高精度加法和乘法</h3><p>高精度加法和高精度乘法用在某些题目中成为一个模块，不会单独出现，基本是用一个数组或者vector来模拟竖式加法和乘法。除法和减法好像还没有见到过在什么题目中应用。</p><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><p>高精度加法和乘法方法如同竖式一样，高精度除法是余数每次乘10之后加上当前位除以被除数。没有涉及到两个大数相乘和相除的问题，具体方法要更加复杂。</p>]]></content>
    
    <summary type="html">
    
      高精度总结
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="/2020/06/04/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>/2020/06/04/高级数据结构/</id>
    <published>2020-06-04T06:26:01.000Z</published>
    <updated>2020-06-04T06:27:18.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>&emsp;&emsp;并查集重点在于通过集合维护什么额外信息来解决问题。额外信息可以是集合内元素数量、当前元素和根节点的距离。当前元素和根节点的距离可以用来维护多个相互关系。</p><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>&emsp;&emsp;树状数组能够以logn的时间复杂度计算前缀和并且单点修改某一位置的值。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>&emsp;&emsp;在动态的求中位数时，可以用对顶堆，上边是一个小根堆，下边是一个大根堆，用来维护中位数在中间。</p><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>&emsp;&emsp;Trie树又叫字典树，可以快速插入和查询某一字符串是否在当前集合之中。限制条件是当前字符集合所有字符总数不能太大，否则效率低下且耗费空间。</p><p>&emsp;&emsp;这里存储树是通过<code>son[N][26]</code>类型的二维数组来存储，本质是一个单向查询函数，其中son的第一个维度为当前指针地址，用idx从0开始分配。树根被分配为0，之后依次分配地址递增。第二个维度26是当前确定的字符，当确定了当前节点和当前字符之后，就确定了son中存储值，即下一个节点的地址。通过这种逻辑来用数组存储树和图是一种较为方便和快捷的方法。</p><p>&emsp;&emsp;AC自动机是Trie树和KMP算法的结合，通过KMP算法的ne数组在Trie树上进行匹配，完成多个模板串在某一原串中出现次数的统计。</p>]]></content>
    
    <summary type="html">
    
      高级数据结构
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>图论算法</title>
    <link href="/2020/06/04/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    <id>/2020/06/04/图论算法/</id>
    <published>2020-06-04T06:26:01.000Z</published>
    <updated>2020-06-04T06:27:02.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h1><h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>&emsp;&emsp;使用邻接矩阵存储图更为合理，因为floyd算法要求每两个点之间的最短路径。循环顺序是kij其中k是阶段，从ik到kj点的最短路径由松弛操作</p><script type="math/tex; mode=display">g[i][j] = min(g[i][j], g[i][k] + g[k][j])</script><p>给出。当有重边和自环时，每两个点之间存储的<code>g[i][j]</code>只存储最短的一条即可。</p><p>总结：图论算法主要包括几部分，有最短路径、最小生成树。下图可以比较清楚地将最短路径算法分类。</p><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>&emsp;&emsp;使用dist数组来维护所有点到源点的最短距离，用st数组维护已经确定最短距离的点。st数组一定要从空集开始，这样才能更新1号点。从所有点中选择距离源点最近的点来更新，将其所有临接点到源点的最短距离更新。最终更新了n个点后，所有点到达最短距离。时间复杂度为O(n^2)。</p><h3 id="堆优化的Dijkstra"><a href="#堆优化的Dijkstra" class="headerlink" title="堆优化的Dijkstra"></a>堆优化的Dijkstra</h3><p>&emsp;&emsp;维护一个堆，堆中储存一对信息（距离源点距离，当前点序号），从而每次得到距离源点最近的点的编号，扩展所有邻接点。这里不能保证每个点只入堆一次，因此当第一次从堆出来以后，再出来的就是错误的更新点，因此continue。时间复杂度因为有堆进行优化，所以是O(nlogn)。</p><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman Ford"></a>Bellman Ford</h3><p>&emsp;&emsp;可以求解不超过k条边的最短路径，通过k次循环，每次备份dist数组，每次遍历所有的边，通过上次dist数组更新本次dist数组，可以求取负边权的情况。时间复杂度是O(km)，因为每次经过k次迭代，每次迭代m条边。</p><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>&emsp;&emsp;SPFA算法是队列优化的Bellman Ford算法，由于Bellman Ford算法需要k次更新所有的边，但是其中某些边在没有最短路径涉及时不需要更新。SPFA算法通过维护队列，将每次被更新的点加入队列，每次只更新队列内部的点，这样就减少了很多不必要点的更新操作。队列里是所有被更新过的点，因此可以维护st数组，当某个点被多个点更新时，就不用重复进入队列作为一下步扩展更新了。时间复杂度是O(nm)，但是实际上会比这个复杂度快很多。</p><h3 id="SPFA判断负环"><a href="#SPFA判断负环" class="headerlink" title="SPFA判断负环"></a>SPFA判断负环</h3><p>&emsp;&emsp;SPFA算法当队列不空的时候就会不断的更新图中路径的最短值，每次更新相当于多走一条边，当有负环的时候，某些节点一定会被无限次更新到负无穷，因此用cnt数组来记录每一个点的被更新次数，当某个点更新次数大于n – 1时，说明存在一条路径当我更新n – 1次之后，还可以更小，这样就是存在负环了。开始时一定要把所有点都加入到队列中，否则只更新某一个点，也许去其他点的路径可以不经过负环，也就不会无限更新，就找不到负环来判断。</p><h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>&emsp;&emsp;用st数组维护一个集合，最开始为空，每次扩充一个距离当前集合最近的点进入集合，并且更新其他点到集合的最近距离。所有点到集合的初始最近距离为INF，将所有点均加入到集合时算法结束。如果某一次扩充的点到集合的最近距离为正无穷，则说明不存在最小生成树。</p><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>&emsp;&emsp;通过排序得到所有边的序列，从最小的边开始扩展，贪心的思路。维护一个并查集来确定两个点是否属于同一个集合，如果属于同一个集合的两个点还需要增加一条边，则该条边增加后则成环。因此维护一个计数器cnt，当算法结束之后，cnt如果小于n – 1则说明不存在有效的生成树，否则并查集维护的点就是当前生成树。</p>]]></content>
    
    <summary type="html">
    
      图论算法总结
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>生活</title>
    <link href="/2020/06/01/%E7%94%9F%E6%B4%BB/"/>
    <id>/2020/06/01/生活/</id>
    <published>2020-06-01T14:16:01.000Z</published>
    <updated>2020-06-04T06:30:41.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>近期更新，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      生活
    
    </summary>
    
      <category term="生活" scheme="/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>读书笔记</title>
    <link href="/2020/06/01/%E8%AF%BB%E4%B9%A6/"/>
    <id>/2020/06/01/读书/</id>
    <published>2020-06-01T14:16:01.000Z</published>
    <updated>2020-06-04T06:30:48.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><p>近期更新，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      读书笔记
    
    </summary>
    
      <category term="读书" scheme="/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="/2020/06/01/%E9%9A%8F%E7%AC%94/"/>
    <id>/2020/06/01/随笔/</id>
    <published>2020-06-01T14:16:01.000Z</published>
    <updated>2020-06-04T06:30:32.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><p>近期更新，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      随笔
    
    </summary>
    
      <category term="随笔" scheme="/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
