<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天の痕的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-06-30T07:56:41.761Z</updated>
  <id>/</id>
  
  <author>
    <name>天の痕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统</title>
    <link href="/2020/06/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>/2020/06/30/操作系统/</id>
    <published>2020-06-30T07:56:08.000Z</published>
    <updated>2020-06-30T07:56:41.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ol><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（<strong>资源分配给进程，同一进程的所有线程共享该进程的所有资源</strong>。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</li><li>进程是CPU<strong>资源分配</strong>的最小单位，线程是CPU<strong>调度</strong>的最小单位；</li><li>系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、IO设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，<strong>进程切换的开销也远大于线程切换的开销</strong>。</li><li><strong>线程间比进程间通信更容易</strong>。由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预。</li><li>进程编程<strong>调试简单可靠性高</strong>，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程<strong>调试相对复杂</strong>。</li><li>进程间不会相互影响 ；一个线程挂掉将导致整个进程挂掉。</li></ol><h2 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h2><p>进程间通信主要包括<strong>管道</strong>、<strong>系统IPC</strong>（包括消息队列、信号量、信号、共享内存等）、以及<strong>套接字socket</strong>。</p><h3 id="1-管道："><a href="#1-管道：" class="headerlink" title="1.管道："></a><strong>1.管道：</strong></h3><p>管道主要包括<strong>无名管道</strong>和<strong>命名管道</strong>。管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p><p><strong>1.1 普通管道PIPE（无名管道）：</strong></p><p>1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端，fd[0] 和fd[1]，0是读端，1是写端。</p><p>2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</p><p>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并<strong>不属于其他任何文件系统</strong>，并且<strong>只存在于内存</strong>中。</p><p><strong>Linux下实现代码</strong>：</p><pre><code class="lang-c++">int main(){    char buf[1024]=&quot;change world!\n&quot;;    int fds[2];    if(pipe(fds) == -1)        perror(&quot;pipe&quot;),exit(1);    pid_t pid = fork(); //创建匿名管道    if(pid == 0)    {        close(fds[0]); //关闭管道读描述符        if(write(fds[1],buf,1024)==-1) //写进管道            perror(&quot;write&quot;),exit(1);        close(fds[1]);         exit(1);    }    else    {        memset(buf,0x00,1024);        close(fds[1]); //关闭管道写描述符        if(read(fds[0],buf,1024)==-1) //从管道读内容            perror(&quot;read&quot;),exit(1);        if(write(1,buf,1024)==-1)            perror(&quot;write&quot;),exit(1);        close(fds[0]);        exit(1);    }    return 0;}</code></pre><p><strong>1.2 命名管道FIFO：</strong></p><p>1)FIFO可以在<strong>无关的进程</strong>之间交换数据</p><p>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式<strong>存在于文件系统</strong>中。</p><p><strong>Linux下实现代码</strong>：</p><p>在Linux系统中，使用下边命令创建命名管道</p><pre><code class="lang-shell">mkfifo filename</code></pre><pre><code class="lang-shell">[centos@localhost fifo]$ mkfifo myfifo[centos@localhost fifo]$ lsmyfifo[centos@localhost fifo]$ file myfifomyfifo: fifo (named pipe)</code></pre><p>也可以在程序内部创建</p><pre><code class="lang-c++">int mkfifo(const char *pathname, mode_t mode);int main(){    mkfifo(&quot;my.p&quot;, 0644);    return 0;}</code></pre><p>从命名管道中读入读出</p><pre><code class="lang-c++">#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;//读入示例int main(){    mkfifo(&quot;my.p&quot;,0664);//八进制0664 = 110 110 100    int outfd = open(&quot;my.p&quot;,O_WRONLY);    if(outfd == -1)        perror(&quot;open my.txt&quot;),exit(1);    char buf[1024]={};    int n = 0;    while(fgets(buf,1024,stdin))    {           write(outfd,buf,1024);        memset(buf,0x00,1024);    }      close(outfd);}//读出示例int main(){    int infd = open(&quot;my.p&quot;,O_RDONLY);    if(infd==-1)        perror(&quot;open my.p&quot;),exit(1);    char buf[1024]={};    int n = 0;    while((n = read(infd,buf,1024))&gt;0)    {        write(1,buf,n);        memset(buf,0x00,1024);    }    close(infd);                                                                                                             unlink(&quot;my.p&quot;); //删除管道    return 0;}</code></pre><p><strong>总结：</strong></p><p>匿名管道由pipe函数创建并打开。命名管道由mkfifo函数创建，打开⽤用open。FIFO（命名管道）与pipe（匿名管道）之间唯一的区别在它们创建与打开的⽅方式不同，一但这些工作完成之后，它们具有相同的语义。</p><p><a href="https://www.cnblogs.com/zhonglongbo/p/8976730.html" target="_blank" rel="noopener">参考资料.Blog龙跃十二.利用管道实现进程间通信</a></p><h3 id="2-系统IPC（Inter-Process-Communication"><a href="#2-系统IPC（Inter-Process-Communication" class="headerlink" title="2.系统IPC（Inter-Process Communication)"></a><strong>2.系统IPC（Inter-Process Communication)</strong></h3><p><strong>2.1 消息队列</strong></p><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道<strong>只能承载无格式字节流</strong>以及缓冲区大小受限等特点)具有写权限的进程可以按照一定的规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p><p>特点：</p><p>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p><p>2)消息队列<strong>独立于发送与接收进程</strong>。进程终止时，消息队列及其内容并不会被删除。</p><p>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,<strong>也可以按消息的类型读取</strong>。</p><p>Linux下消息队列实现主要通过四个函数，msgget(),msgsnd(),msgrcv(),msgctl()。</p><pre><code class="lang-c++">#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;//调用成功返回一个keykey_t ftok(const char *pathname, int proj_id);//创建和获取消息队列int msgget(key_t key, int msgflg);//key : 消息队列关联的键，即id, 使用ftok()产生,不同进程通过相同key可以得到相同消息队列//msgflg ：消息队列的建立标志和存取权限//IPC_CREAT 单独使用是如果没有就创建 //IPC_EXCL + IPC_CREAT 是已经存在则执行失败//返回创建的消息队列的标识符msqid，msqid是IPC对象内部名，失败返回-1//使用的例子int open_queue(int keyval){    int qid;    qid = msgget(keyval, IPC_CREAT | 0666);    if (qid == -1)    {        perror(&quot;Failed in calling msgget&quot;);        return -1;    }    return qid;}//发送一条消息到指定的消息队列int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflag);//msqid为消息队列标识符//msgp指向准备发送消息的指针//msgsz上述指针指向消息的长度//msgflag默认为0（IPC_NOWAIT)，表示阻塞，1表示非阻塞。阻塞表示如果队列满了就一直等到有地方，如果非阻塞满了，就直接返回-1。//消息结构一方面必须小于系统规定的上限，另一方面必须以一个long int长整型开始，接受者以此来确定消息的类型（协议必须的部分）//实际例子struct msgbuf{    long mtype;    char mtext[1024];}int sendMsgQueue(int msg_id, int who, char* msg){    struct msgbuf buf;    buf.mtype = who;    strcpy(buf.mtext, msg);//前目的，后源    if (msgsnd(msg_id, (void*) &amp;buf, sizeof(buf.mtext), 0) &lt; 0)    {        perror(&quot;Fail to send message to MsgQueue!&quot;);        return -1;    }    return 0;}//从指定消息队列接收一条消息ssize_t msgrcv(int msqid, const void* msgp, size_t msgsz, long msgtype, int msgflg);//参数和msgsnd相同//例子int recvMsgQueue(int msg_id, int recvType, char out[]){    struct msgbuf buf;    int size = sizeof(buf.mtext);    if (msgrcv(msg_id, (void*)&amp;buf, size, recvType, 0) &lt; 0)    {        perror(&quot;Fail to receive message from MsgQueue!&quot;);        return -1;    }    strncpy(out, buf.mtext, size);//将特定大小的字符串复制    out[size] = 0;//字符串设置为&#39;\0&#39;    return 0;}//消息控制int msgctl(int msqid, int cmd, struct msgid_ds *buf);//msqid是由msgget返回的消息队列id//cmd有三种值 //IPC_RMID 删除消息队列//PIC_STAT 把msgid_ds结构中的数据设置为消息队列的当前关联值//IPC_SET 在进程有足够权限的前提下，把消息队列的当前关联值设置为msgid_ds数据结构中给出的值int destoryMsgQueue(int msg_id){    if (msgctl(msg_id, IPC_RMID, NULL) &lt; 0)    {        perror(&quot;Remove MsgQueue Fail!&quot;);        return -1;    }    return 0;}</code></pre><pre><code class="lang-shell">#ipcs 显示IPC资源 -q是消息队列， -m是共享内存#ipcrm 手动删除IPC资源[root@localhost code]# ipcs -q------ Message Queues --------                                                 key        msqid      owner      perms      used-bytes   messages0x66020001 524288     root       666        0            0[root@localhost code]# ipcrm -q 524288[root@localhost code]# ipcs -q------ Message Queues --------                                                 key        msqid      owner      perms      used-bytes   messages[root@localhost code]#</code></pre><p><a href="https://blog.csdn.net/wei_cheng18/article/details/79661495" target="_blank" rel="noopener">CSDN. Linux进程间通信之消息队列</a></p><p><a href="https://blog.csdn.net/xiaohuangcat/article/details/8203734?locationNum=6" target="_blank" rel="noopener">CSDN. Linux进程通信之消息队列-项目实践</a></p><p><strong>2.2 共享内存（Shared Memory）</strong></p><p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</p><p>特点：</p><p>1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p><p>2)因为多个进程可以同时操作，所以需要进行同步</p><p>3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p><p><strong>2.3 信号量semaphore</strong></p><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><p>特点：</p><p>1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p><p>2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p><p>3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p><p>4)支持信号量组。</p><p><strong>2.4 信号signal</strong></p><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p><strong>3.套接字SOCKET：</strong></p><p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p><h2 id="线程间通信的方式"><a href="#线程间通信的方式" class="headerlink" title="线程间通信的方式"></a><strong>线程间通信的方式</strong></h2><p>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p><p>互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p><p>信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p><p>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><h2 id="死锁的必要条件和解决方法"><a href="#死锁的必要条件和解决方法" class="headerlink" title="死锁的必要条件和解决方法"></a>死锁的必要条件和解决方法</h2><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：</p><ol><li>互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</li><li>请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</li><li>不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</li><li>环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链</li></ol><p>解决死锁的方法即破坏上述四个条件之一，主要方法如下：</p><ol><li>资源一次性分配，从而剥夺请求和保持条件</li><li>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件</li><li>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</li></ol>]]></content>
    
    <summary type="html">
    
      操作系统知识 面试
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划（二）其他DP</title>
    <link href="/2020/06/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E5%85%B6%E4%BB%96DP/"/>
    <id>/2020/06/30/动态规划（二）其他DP/</id>
    <published>2020-06-30T07:30:01.000Z</published>
    <updated>2020-06-30T07:54:03.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="其他DP"><a href="#其他DP" class="headerlink" title="其他DP"></a>其他DP</h1><h3 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h3><p>区间DP是在区间上进行动态规划，本质是用更小区间的最优解来求更大区间的最优解。一般的模板都是这样的：</p><pre><code class="lang-c++">for (int len = 2; len &lt;= n; len ++ )    for (int i = 1; i + len - 1 &lt;= n; i ++ )    {        int j = i + len - 1;        for (int k = i; k &lt; j; k ++ )            f[i][j] = max(f[i][j], f[i][k] + f[k][j] + ****);    }</code></pre><h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><p>状压DP分为两类，一类是棋盘式（基于连通性）的模型，另一类是基于集合。</p><p>  棋盘式：蒙德里安的梦想这道题，是求把N<em>M的棋盘分割成若干个1</em>2的的长方形，有多少种方案。通过将每一列看成一个状态，其中放了小块的格子为1，没放的为0，这样可以通过枚举所有的状态到状态的转移来进行计数。</p><p>  基于集合：最短哈密尔顿路径，给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。对所有点构成的集合考虑，已经走过的点为1，还没有到达过的点为0，可以确定一个n位状态state，但如果需要从一个点转移到下一个点，则还需要记录当前停在了哪一个点上。因此用f[state][j]表示到达j号点时，已经走过的状态为state的路径集合中的最小值。</p><p>  因此可以得到状态转移方程：</p><script type="math/tex; mode=display">f[state][j] = min(f[state][j], f[state - (1 << k)][k] + w[k][j]);</script><h2 id="LIS问题"><a href="#LIS问题" class="headerlink" title="LIS问题"></a>LIS问题</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>LIS问题有两种解法，基于动态规划定义f[i]为以i结尾的最长上升子序列的最大长度。如果基于贪心，将i之前所有上升子序列长度存储下来，则可以发现其必然是单调上升的，因此可以通过二分来优化时间复杂度为O(nlogn）。</p><p>关于贪心解法的证明：</p><ol><li>首先我们发现，在求解LIS问题时，如果a b c序列，c可以接到a后边即c &gt; a，那么如果b &lt; a则c一定也可以接到b后边。因此在这种思想的指导下，我们可以存储i位置之前所有长度的上升子序列的最后一位的<strong>最小值</strong>。</li><li>其次，对于上述存储方式，我们发现应该是单调递增的。因为如果长度为x的末尾的值，大于长度x + 1末尾的值，则在长度x + 1的情况下，一定存在一个长度为x的序列，其末尾值又严格小于现在x的末尾的值，由此发现不是最小值，矛盾，因此一定是严格上升的。</li></ol><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//基于DP的O(n^2)解法for (int i = 1; i &lt;= n; i ++ ){    f[i] = 1;    for (int j = 1; j &lt; i; j ++ )        if (a[i] &gt; a[j])            f[i] = max(f[i], f[j] + 1);}//基于贪心的O(nlogn)的解法int q[N];int a[N];int len = 0;q[0] = -2e9; //哨兵，表示长度为0的最长上升子序列的末尾值for (int i = 0; i &lt; n; i ++ ){    int l = 0, r = len;    while (l &lt; r)    {        int mid = l + r + 1 &gt;&gt; 1;        if (q[mid] &lt; a[i]) l = mid; //如果q[mid] &lt; a[i]表示当前的mid的值比a[i]要小，因此mid可以再大点        else r = mid - 1;    }    len = max(len, r + 1);    q[r + 1] = a[i];}cout &lt;&lt; len &lt;&lt; endl;</code></pre>]]></content>
    
    <summary type="html">
    
      动态规划其他DP
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="/2020/06/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>/2020/06/28/二分查找/</id>
    <published>2020-06-28T13:41:30.000Z</published>
    <updated>2020-06-28T13:41:34.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="二分查找元素"><a href="#二分查找元素" class="headerlink" title="二分查找元素"></a>二分查找元素</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;二分使用的条件是有<strong>单调性</strong>，比如有序的序列，事实上二分是<strong>分治算法</strong>思想。本质是将问题抽象化为<strong>找一个分界面</strong>，分界面左边不满足某一性质，而右边满足某一个性质。这时候左边边界缩减时需要多缩减一个，因为左边不满足性质；右边边界缩减到当前mid，不用多缩减。下边代码的check函数即是满足某种性质的判断函数，当满足性质时返回 true, 不满足时返回false。</p><p>&emsp;&emsp;当搜素结束时，左右边界重合，即<code>l == r</code>。如果有<code>l = mid</code>的情况，需要<code>l + r + 1 &gt;&gt; 1</code>才能够避免最后两个数相邻时，mid永远更新为左边界的死循环。</p><p>&emsp;&emsp;二分查找分为整数二分和浮点数二分，浮点数查找时原理相同，但是要求精度小于一定数时停止。浮点数二分比整数二分容易很多，不需要考虑很多边界条件的情况。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//每次右边界缩减为mid的情况while (l &lt; r){    int mid = l + r &gt;&gt; 1;    if (check(mid)) r = mid;    else l = mid + 1;}//每次左边界缩减为mid的情况while (l &lt; r){    int mid = l + r + 1 &gt;&gt; 1;    if (check(mid)) l = mid;    else r = mid + 1;}//浮点数二分const double eps = 1e-8;while (r - l &gt; eps){    int mid = l + r / 2.0;    if (check(mid)) l = mid;    else r = mid;}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">LC.704 二分查找（简单）</a></p><p><a href="https://www.acwing.com/problem/content/792/" target="_blank" rel="noopener">AW.790 数的三次方根（简单）</a></p><p><a href="https://www.acwing.com/problem/content/791/" target="_blank" rel="noopener">AW.789 数的范围（简单）</a></p><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">LC.209 长度最小的子数组（中等）</a></p><p>构造单调性+二分查找，重点在于单调性的构造</p><h2 id="二分搜索答案"><a href="#二分搜索答案" class="headerlink" title="二分搜索答案"></a>二分搜索答案</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;答案很多时候是<strong>有范围的</strong>，当某一个问题<strong>验证某一个答案</strong>的时间复杂度乘以二分区间范围的log时，可以考虑搜索答案。通过不断的尝试排除错误答案，且是以指数速度排除，最终得到正确答案。这里一般在验证答案的时候，可以采用某种程度的贪心策略，并且将原问题中单调性质进行转化，能够通过一次的验证缩小答案范围。</p><p>&emsp;&emsp;这类题往往不是简单的搜索答案，而是将问题某种程度的转化之后，再搜索答案。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/104/" target="_blank" rel="noopener">AW.102 最佳牛围栏（简单）</a></p><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LC.287 寻找重复数（中等）</a></p><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank" rel="noopener">LC.5438 制作m束花所需最少天数（中等）(193周赛第三题）</a></p><p><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">LC.1300 转变数组后最接近目标值的数组和（中等）</a></p>]]></content>
    
    <summary type="html">
    
      二分查找模板和常见套路
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>最小生成树算法</title>
    <link href="/2020/06/28/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    <id>/2020/06/28/最小生成树算法/</id>
    <published>2020-06-28T10:34:07.000Z</published>
    <updated>2020-06-28T10:36:33.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;用st数组维护一个集合，最开始为空，每次扩充一个距离当前集合最近的点进入集合，并且更新其他点到集合的最近距离。所有点到集合的初始最近距离为INF，将所有点均加入到集合时算法结束。如果某一次扩充的点到集合的最近距离为正无穷，则说明不存在最小生成树。时间复杂度为O(n^2)。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int w[N][N];int dist[N];bool st[N];int n, m;int prim(){    int res = 0;    memset(dist, 0x3f, sizeof dist);    for (int i = 0; i &lt; n; i ++ )    {        int t = -1;        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        if (i) res += dist[t];        if (i &amp;&amp; dist[t] == INF) return INF;        st[t] = true;        for (int j = 1; j &lt;= n; j ++ )            dist[j] = min(dist[j], w[t][j]);    }    return res;}int main(){    cin &gt;&gt; n &gt;&gt; m;    memset(w, 0x3f, sizeof w);    for (int i = 1; i &lt;= n; i ++ ) w[i][i] = 0;    for (int i = 0; i &lt; m; i ++ )    {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        w[a][b] = w[b][a] = min(w[a][b], c);    }    int t = prim();    if (t == INF) puts(&quot;impossible&quot;);    else cout &lt;&lt; t &lt;&lt; endl;}</code></pre><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;通过排序得到所有边的序列，从最小的边开始扩展，<strong>贪心</strong>的思路。维护一个<strong>并查集</strong>来确定两个点是否属于同一个集合，如果属于同一个集合的两个点还需要增加一条边，则该条边增加后则成环。因此维护一个计数器cnt，当算法结束之后，cnt如果小于n – 1则说明不存在有效的生成树，否则并查集维护的点就是当前生成树。时间复杂度因为用到了排序，因此是<strong>mlog(m)</strong>。</p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010, M = 200010;struct Edge{    int a, b, w;    bool operator &lt; (const Edge&amp; a) const    {        return w &lt; a.w;    }}edges[M];int n, m;int p[N];int find(int x){    if (p[x] != x) p[x] = find(p[x]);    return p[x];}void kruskal(){    int res = 0, cnt = 0;    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    for (int i = 0; i &lt; m; i ++ )    {        auto e = edges[i];        int a = e.a, b = e.b, w = e.w;        int pa = find(a), pb = find(b);        if (pa != pb)        {            res += w;            cnt ++ ;            p[pa] = pb;        }    }    if (cnt &lt; n - 1) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;    else cout &lt;&lt; res &lt;&lt; endl;}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; m; i ++ )    {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        edges[i].a = a, edges[i].b = b, edges[i].w = c;    }    sort(edges, edges + m);    kruskal();    return 0;}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/861/" target="_blank" rel="noopener">AW.859 Kruskal算法求最小生成树（简单）</a></p><p><a href="https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/" target="_blank" rel="noopener">LC.1489 找到最小生成树中的关键边和伪关键边（困难）</a></p>]]></content>
    
    <summary type="html">
    
      最小生成树算法
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="/2020/06/28/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>/2020/06/28/双指针/</id>
    <published>2020-06-28T06:09:29.000Z</published>
    <updated>2020-06-28T06:12:22.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>双指针算法一般都可以暴力求解，但是暴力求解的时间复杂度一般为O(n^2)，通过优化使用双指针可以将其时间复杂度降低为O(n)。优化的本质是寻找i和j变化的<strong>单调性</strong>，如果某个指针在单调条件之下不可能再继续遍历，就可以省略那些遍历。</p><p>有些情况下，需要先构造性质比较好的数列，之后才能应用双指针算法。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">for (int i = 0, j = 0; i &lt; n; i ++ ){    //如果要维护集合，在这里维护即可    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;    //具体逻辑}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/description/801/" target="_blank" rel="noopener">AW.799 最长连续不重复子序列（简单）</a></p><p><a href="https://www.acwing.com/problem/content/802/" target="_blank" rel="noopener">AW.800 数组元素的目标和（简单）</a></p><p>两个序列上的双指针，需要考虑如何构造单调性</p><p><a href="https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/" target="_blank" rel="noopener">LC.5450 满足条件的子序列数目（中等）</a></p><p>周赛第三题，需要先进行排序，再考虑双指针算法</p><p><a href="https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/" target="_blank" rel="noopener">LC.5434 删掉一个元素以后全为1的最长子数组（中等）</a></p><p>简单双指针或者说滑动窗口应用</p>]]></content>
    
    <summary type="html">
    
      双指针算法
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>题库题解</title>
    <link href="/2020/06/27/%E9%A2%98%E5%BA%93%E9%A2%98%E8%A7%A3/"/>
    <id>/2020/06/27/题库题解/</id>
    <published>2020-06-27T06:56:30.000Z</published>
    <updated>2020-06-28T06:16:11.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题库"><a href="#题库" class="headerlink" title="题库"></a>题库</h1><h2 id="题库-题解"><a href="#题库-题解" class="headerlink" title="题库+题解"></a>题库+题解</h2><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LC.15 三数之和（中等）</a></p><p>排序+双指针，排序加上双指针可以简化定和搜索。排序可以将相同元素邻接。时间复杂度O(n^2)。</p><pre><code class="lang-c++">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {        vector&lt;vector&lt;int&gt;&gt; ans;        sort(nums.begin(), nums.end());        for (int i = 0; i &lt; nums.size(); i ++ )        {            //因为要不重复，所以当前如果在之前出现过就跳过，排序的好处体现在这里            if (i - 1 &gt;=0 &amp;&amp; nums[i - 1] == nums[i]) continue;            int target = -nums[i];            //第i个左边的都遍历过了，只考虑右边即可。            int l = i + 1, r = nums.size() - 1;            //双指针过程            while (l &lt; r)            {                if (nums[l] + nums[r] &lt; target) l ++ ;                else if (nums[l] + nums[r] &gt; target) r -- ;                else                 {                    vector&lt;int&gt; cur;                    cur.push_back(nums[i]);                    cur.push_back(nums[l]);                    cur.push_back(nums[r]);                    ans.push_back(cur);                    //重复的直接跳过                    while (l + 1 &lt;= nums.size() - 1 &amp;&amp; nums[l + 1] == nums[l]) l ++ ;                    while (r - 1 &gt;= 0 &amp;&amp; nums[r - 1] == nums[r]) r -- ;                    l ++ , r -- ;                }            }        }        return ans;    }};</code></pre><p><a href="https://leetcode-cn.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/" target="_blank" rel="noopener">LC.1467 两个盒子中球的颜色数相同的概率（困难）</a></p><p>首先要知道<strong>可重复排列数</strong>计算原理和公式，假设有1122333这样的数，要求不重复的排列数，就要用到可重复排列数计算公式。思想是首先将所有的相同的数看做不同，求总共的排列数，假设一共有sum个数，有sum!种排列方式。再对于每一种数，除以重复的种数的全排列，用公式表达如下：</p><script type="math/tex; mode=display">res = \frac{(S_1 + S_2 + ... + S_n)!}{S_1!*S_2!*...*S_n!}</script><p>其中Si表示第i个数出现的次数。这样可以计算出概率的分母，对于分子，首先其必须满足分成两部分之后，左边和右边的种类数相同，然后对于左边和右边分别计算可重复排列数，并且利用乘法原理，得到最终合并之后的排列数。另外dfs过程中需要剪枝，当左边总和个数的两倍大于整体总和的时候不要继续计算了。</p><p>这道题是典型的概率类题目，之前没遇到过，记录一下。</p><pre><code class="lang-c++">double fact[50];class Solution {public:    //计算阶乘    void factorial()    {        fact[0] = 1;        for (int i = 1; i &lt;= 48; i ++ )            fact[i] = fact[i - 1] * i;    }    //计算可重复排列数    double get(vector&lt;int&gt;&amp; balls)    {        int sum = 0;        for (int i = 0; i &lt; balls.size(); i ++ ) sum += balls[i];        double res = fact[sum];        for (int i = 0; i &lt; balls.size(); i ++ ) res /= fact[balls[i]];        return res;    }    //通过dfs计算所有可能的情况    double dfs(int u, int ts, int ls, int rs, vector&lt;int&gt;&amp; left, vector&lt;int&gt;&amp; right, vector&lt;int&gt;&amp; balls)    {        //剪枝        if (ls * 2 &gt; ts || rs * 2 &gt; ts) return 0;        double res = 0;        if (u == balls.size())        {            int l = 0, r = 0;            for (int i = 0; i &lt; left.size(); i ++ )                if (left[i]) l += 1;            for (int i = 0; i &lt; right.size(); i ++ )                if (right[i]) r += 1;            //如果左右种类数不同，不可能产生答案，直接返回0            if (l != r) return 0;            return get(left) * get(right);        }        //对于每一种球分别枚举        for (int i = 0; i &lt;= balls[u]; i ++ )        {            left[u] = i, right[u] = balls[u] - i;            res += dfs(u + 1, ts, ls + i, rs + balls[u] - i, left, right, balls);        }        return res;    }    double getProbability(vector&lt;int&gt;&amp; balls) {        int n = balls.size();        int sum = 0;        for (int i = 0; i &lt; balls.size(); i ++ ) sum += balls[i];        factorial();        double down = get(balls);        vector&lt;int&gt; left(n, 0), right(n, 0);        double up = dfs(0, sum, 0, 0, left, right, balls);        return up / down;    }};</code></pre><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank" rel="noopener">LC.5438 制作m束花所需的最少天数（中等）</a></p><p>这是周赛的第三题，答案有一个范围，并且验证答案的时间在O(n)，且具有单调性（如果第x天无法制作那么小于x天都不行，如果x天可以制作，那么大于x天都可以制作），数据规模在10^5，因此O(nlogn)的二分算法可以完成这道题。</p><pre><code class="lang-c++">class Solution {public:    int minDays(vector&lt;int&gt;&amp; bd, int m, int k) {        int n = bd.size();        //无论如果都不能制作只有花数量不够        if (m * k &gt; n) return -1;        //答案是在最小值和最大值之间，增加效率        int l = INT_MAX, r = INT_MIN;        for (int i = 0; i &lt; n; i ++ )        {            l = min(l, bd[i]);            r = max(r, bd[i]);        }        //标准二分查找答案模板        while (l &lt; r)        {            int mid = l + r &gt;&gt; 1;            if (check(bd, mid, m, k)) r = mid;            else l = mid + 1;        }        return l;    }    //check函数用O(n)的时间判断是否当前答案可行    //这里判断是否可行有点贪心的意味    bool check(vector&lt;int&gt;&amp; bd, int mid, int m, int k)    {        int cnt = 0;        int ans = 0;        for (int i = 0; i &lt; bd.size(); i ++ )        {            //如果已经过了开花时间，则连续花数 + 1            if (bd[i] &lt;= mid)            {                cnt ++ ;                //如果有k朵花了，可以做个束                if (cnt &gt;= k)                {                    ans ++ ;                    //当前连续花数清零                    cnt = 0;                }            }            else cnt = 0;        }        if (ans &gt;= m) return true;        else return false;    }};</code></pre><p><a href="https://www.acwing.com/problem/content/344/" target="_blank" rel="noopener">AW.342 道路与航线（中等）</a></p><p>这题很有意思，是图论的题，里面使用了堆优化的dijkstra + 拓扑排序 + dfs，看起来很难写，但是事实如果理清关系，是比较好写的一道题。</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 25010, M = 150010, INF = 0x3f3f3f3f;int h[N], e[M], ne[M], w[M], idx;int dist[N];bool st[N];int id[N];int din[N];int bid;vector&lt;int&gt; block[N];queue&lt;int&gt; q;int n, mr, mp, s;void add(int a, int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;}void dfs(int u, int bid){    id[u] = bid;    block[bid].push_back(u);    for (int i = h[u]; ~i; i = ne[i])    {        int j = e[i];        if (!id[j])            dfs(j, bid);    }}void dijkstra(int bid){    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    for (int i = 0; i &lt; block[bid].size(); i ++ )    {        int j = block[bid][i];        heap.push({dist[j], j});    }    while(heap.size())    {        auto t = heap.top();        heap.pop();        int ver = t.y, distance = t.x;        if (st[ver]) continue;        st[ver] = true;        for (int i = h[ver]; ~i; i = ne[i])        {            int j = e[i];            if (id[ver] != id[j])             {                din[id[j]] -- ;                if (din[id[j]] == 0)                    q.push(id[j]);            }            if (dist[j] &gt; dist[ver] + w[i])            {                dist[j] = dist[ver] + w[i];                if (id[ver] == id[j])                    heap.push({dist[j], j});            }        }    }}void top_sort(){    memset(dist, 0x3f, sizeof dist);    dist[s] = 0;    for (int i = 1; i &lt;= bid; i ++ )        if (!din[i])            q.push(i);    while (q.size())    {        int t = q.front();        q.pop();        dijkstra(t);    }}int main(){    cin &gt;&gt; n &gt;&gt; mr &gt;&gt; mp &gt;&gt; s;    memset(h, -1, sizeof h);    for (int i = 0; i &lt; mr; i ++ )    {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c), add(b, a, c);    }    for (int i = 1; i &lt;= n; i ++ )        if (!id[i])            dfs(i, ++ bid);    for (int i = 0; i &lt; mp; i ++ )    {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);        din[id[b]] ++ ;    }    top_sort();    for (int i = 1; i &lt;= n; i ++ )        if (dist[i] &gt; INF / 2) cout &lt;&lt; &quot;NO PATH&quot; &lt;&lt; endl;        else cout &lt;&lt; dist[i] &lt;&lt; endl;    return 0;}</code></pre><p><a href="https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/" target="_blank" rel="noopener">LC.1477 找两个和为目标值且不重叠的子数组</a></p><p>这题的数据保证了每一个数都是正数，因此双指针算法很容易每次<strong>寻找一个区间</strong>，使得当前区间的和为target。如果要找<strong>两个</strong>和为目标值<strong>且不重叠</strong>的子数组，只需要记忆化之前所有的答案，f[i] 定义为从0到i的子数组满足和为target的最短长度，以动态规划的思想，可以每次得到f[i] = min(i - j + 1, f[i - 1])用O(1)的时间复杂度更新。很容易想到双指针算法去寻找一个区间，但是对于两个区间，没有及时想到记忆化的方法。</p><p>这里双指针应该用i做循环，这样每次计算f[i]比较容易。</p><p>这题融合了双指针算法和动态规划的思想，是好题。</p><pre><code class="lang-c++">class Solution {public:    int minSumOfLengths(vector&lt;int&gt;&amp; arr, int target) {        int n = arr.size();        vector&lt;int&gt; f(n, 1e8);        int res = 1e8;        for (int i = 0, j = 0, sum = 0; i &lt; n; i ++ )        {            sum += arr[i];            while (sum &gt; target) sum -= arr[j ++ ];            if (sum == target)            {                if (j) res = min(res, i - j + 1 + f[j - 1]);                f[i] = i - j + 1;            }            if (i) f[i] = min(f[i], f[i - 1]);        }        if (res &gt; arr.size()) res = -1;        return res;    }};</code></pre><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">LC.10 正则表达式匹配（困难）</a></p><p>动态规划，<code>dp[i][j]</code>表示<strong>s串前i个字符和p串前j个字符是否匹配</strong>。初始条件是空串一定匹配，且s的空串可以匹配任意个以.*开头的p串位置。之后对于最后一个p串位置的字符分类讨论：</p><ol><li>p[j] != ‘*’ :  此时p[j]有两种可能，’.’或者字符，这样就是普通的匹配，如果s[i] == p[j]那么就依赖于<code>dp[i - 1][j - 1]</code>，否则就不可能匹配，为false。</li><li>p[j] == ‘<em>‘ :  </em>的意思是<strong>匹配0个或多个前边一个字符</strong>。如果匹配0个，那么当前结果依赖<code>dp[i][j - 2]</code>，如果匹配多个之前的字符，是依赖<code>dp[i - 1][j - 3]、dp[i - 2][j - 4]...</code>如此代码会比较难写，且增加时间复杂度。从i角度来看，其实是看<code>dp[i - 1][j]</code>，表示当前s串的第i个字符能否被j这个*所取代。</li></ol><p>整体的转移方程如下：</p><script type="math/tex; mode=display">f[i][j] = \left\{\begin{array}if (p[j]\ ≠\ '*') = \left\{\begin{array}f[i - 1][j - 1], & matches(s[i], p[j])\\false, & otherwise\\\end{array}\right. \\otherwise = \left\{\begin{array}f[i - 1][j]\ or\ f[i][j - 2],& matches(s[i], p[j - 1)\\f[i][j - 2], & otherwise\\\end{array}\right.\\\end{array}\right.</script><pre><code class="lang-c++">class Solution {public:    bool isMatch(string s, string p) {        int n = s.size(), m = p.size();        vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1, false));        dp[0][0] = true;        for (int j = 1; j &lt;= m; j ++ )        {            if (p[j - 1] == &#39;*&#39;) dp[0][j] = dp[0][j - 2];            else dp[0][j] = false;        }        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= m; j ++ )            {                if (p[j - 1] != &#39;*&#39;)                {                    if (equal(s[i - 1], p[j - 1])) dp[i][j] = dp[i - 1][j - 1];                    else dp[i][j] = false;                }                else                {                    if (j &gt;= 2) dp[i][j] = dp[i][j - 2];                    if (j &gt;= 2 &amp;&amp; equal(s[i - 1], p[j - 2])) dp[i][j] = (dp[i][j] || dp[i - 1][j]);                }            }        return dp[n][m];    }    bool equal(char a, char b)    {        if (b == &#39;.&#39;) return true;        else return a == b;    }};</code></pre><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">LC.124 二叉树中的最大路径和（困难）</a></p><p>这题主要是想总结一下树的题目主要考点。对于二叉树来说，90%都需要使用递归的方式来解决，一般是先递归解决左子树，再递归解决右子树。思考方式主要从以下几个方面：</p><ol><li>想清楚当前层该问题是如何解决的，如何利用左子树和右子树已知的答案得到当前根节点的答案，有些树状dp的意思。</li><li>想清楚叶子节点的子节点，为nullptr的节点应该如何给上一层提供信息，也就是边界问题，或者是递归出口。</li><li>对于树中每一个节点，先考虑递归解决左子树相同的问题，再递归解决右子树相同的问题，之后返回当前节点的问题答案。</li></ol><pre><code class="lang-c++">class Solution {public:    const int INF = 0x3f3f3f3f;    int ans = -INF;    int maxPathSum(TreeNode* root) {        dfs(root);        return ans;    }    int dfs(TreeNode* root)    {        if (root == nullptr) return -INF;        int val = root -&gt; val;        int left = dfs(root -&gt;left);        int right = dfs(root -&gt;right);        ans = max(ans, max({left, right, 0}) + val);        ans = max(ans, left + right + val);        return max({left, right, 0}) + val;    }};</code></pre><p><a href="https://leetcode-cn.com/problems/avoid-flood-in-the-city/" target="_blank" rel="noopener">LC.1488 避免洪水泛滥（中等）</a></p><p>194周赛第三题，思路是贪心。这里可以通过预处理得到当前天下一次下雨的时间点，因此可以通过贪心，每一次不下雨抽水时，优先抽走马上下次要下雨的的坑。找到马上要下雨的坑，可以通过堆来实现（寻找一个集合中的最小值）。</p><p>贪心证明首先考虑，<strong>任意一种抽水方法，如果能完成最终任务，都可以通过排序转换为当前贪心的方法</strong>。再思考，如果这样抽水最终还是无法完成防洪的任务，那么调换顺序之后，一定会更早的洪水泛滥。因此从正反两方面可以证明当前贪心是正确的。</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; avoidFlood(vector&lt;int&gt;&amp; rains) {        unordered_map&lt;int, int&gt; hash;        int n = rains.size();        vector&lt;int&gt; next(n, n + 1);        for (int i = n - 1; i &gt;= 0; i -- )        {            int r = rains[i];            if (hash.count(r) == 0) hash[r] = i;            else             {                next[i] = hash[r];                hash[r] = i;            }        }        typedef pair&lt;int, int&gt; PII;        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;        unordered_set&lt;int&gt; S;        vector&lt;int&gt; ans;        for (int i = 0; i &lt; n; i ++ )        {            int r = rains[i];            if (r &gt; 0)            {                ans.push_back(-1);                if (S.count(r)) return {};                else                {                    S.insert(r);                    heap.push({next[i], r});                }            }            else            {                if (heap.empty()) ans.push_back(1);                else{                    auto t = heap.top();                    heap.pop();                    int r = t.second;                    S.erase(r);                    ans.push_back(r);                }            }        }        return ans;    }};</code></pre><p><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">LC.41 缺失的第一个正数（困难）</a></p><p>这道题一个隐藏的思路是，<strong>下标都是从0到n - 1递增的</strong>，如果我们能将所有不超过n的数值都按规律填好，那么就可以很轻松的找到对应第一个未出现的正整数。这里如果发现已经填好的数，则跳过，如果发现置换之后死循环，也要处理。</p><pre><code class="lang-c++">class Solution {public:    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        for (int i = 0; i &lt; n; i ++ )        {            //如果已经填好的数，则可以跳过            if (nums[i] == i + 1) continue;            while (nums[i] &gt;= 1 &amp;&amp; nums[i] &lt;= n)            {                int t = nums[nums[i] - 1];                //如果换了的数和现在的数一样，那其实换下去没有意义，会死循环                if (t == nums[i]) break;                nums[nums[i] - 1] = nums[i];                nums[i] = t;            }        }        //找到第一个没有出现过的数        for (int i = 0; i &lt; n; i ++ )            if (nums[i] != i + 1)                return i + 1;        return n + 1;    }};</code></pre><p><a href="https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/" target="_blank" rel="noopener">LC.满足条件的子序列数目（中等）</a></p><p>周赛第三题，首先读题之后，判断题目最终所求信息和数组内元素顺序无关，这样可以考虑先排序试试。如果排序，可以得到有序序列，有序序列的特点是第一个元素最小，最后一个元素最大，且单调递增。因此可以考虑使用双指针算法来求解两数相加对于某个target和的问题。</p><pre><code class="lang-c++">class Solution {public:    const int mod = 1e9 + 7;    int numSubseq(vector&lt;int&gt;&amp; nums, int target) {        int n = nums.size();        vector&lt;int&gt; pow2(n + 1);        pow2[0] = 1;        //这里可以先预处理出2的n次幂，之后每次要增加2的n次幂种情况，就直接调用了。        for (int i = 1; i &lt;= n; i ++ )            pow2[i] = (pow2[i - 1] * 2) % mod;        //排序，想到这里很重要        sort(nums.begin(), nums.end());        //标准的双指针算法        int ans = 0;        for (int i = 0, j = n - 1; i &lt; n; i ++ )        {            while (i &lt;= j &amp;&amp; nums[i] + nums[j] &gt; target) j -- ;            if (i &gt; j) break;            ans = (ans + pow2[j - i]) % mod;        }        return ans;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      题库
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>C++原理与使用技巧</title>
    <link href="/2020/06/25/C++%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>/2020/06/25/C++原理与使用技巧/</id>
    <published>2020-06-25T09:44:08.000Z</published>
    <updated>2020-06-30T07:54:44.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-原理与使用技巧"><a href="#C-原理与使用技巧" class="headerlink" title="C++原理与使用技巧"></a>C++原理与使用技巧</h1><h2 id="C-语法相关"><a href="#C-语法相关" class="headerlink" title="C++语法相关"></a>C++语法相关</h2><h3 id="static关键字的使用"><a href="#static关键字的使用" class="headerlink" title="static关键字的使用"></a>static关键字的使用</h3><ol><li>函数体内的static作用域是当前函数，表示该变量在下次这个函数调用时，不重新分配，还是上次执行之后的值。</li><li>在模块内（一个cpp文件之内）的static全局变量，可以被模块内的所有函数访问，但是模块外的其他函数无法访问。（<strong>全局静态变量</strong>）。全局和静态不同，全局变量在另一个cpp里可以使用extern来引入，而静态变量不允许被其他cpp引入。</li><li>在模块内的static函数只能被当前模块的其他函数调用，外部无法调用。函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。</li><li>类中的static成员变量属于整个类所有，对类的所有对象，调用都是同一个。</li><li>类中的static成员函数属于整个类所有，函数不接受this指针，因此只能访问static成员变量。</li></ol><p>总结：静态的变量和函数都是将变量或者函数限定在了当前cpp文件之中，局部则是多次调用复用。类的静态表示全类共有的东西。</p><h3 id="C-C-中指针和引用的区别"><a href="#C-C-中指针和引用的区别" class="headerlink" title="C/C++ 中指针和引用的区别"></a>C/C++ 中指针和引用的区别</h3><ol><li>指针有自己的一块空间，而引用只是一个别名；</li><li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li><li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；</li><li>作为参数传递时，指针需要被解引用(*操作)才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li><li>可以有const指针，但是没有const引用；</li><li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，<strong>不能被改变</strong>；</li><li>指针可以有多级指针（**p），而引用只有一级；</li><li>指针和引用使用++运算符的意义不一样，指针是指向下一个地址，引用代表所引用对象值+1；</li><li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li></ol><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。unique_ptr是多个指针不能同时指向一个对象，shared_ptr可以指向同一个。weak_ptr不会改变shared_ptr的引用计数。</p><p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而<strong>防止内存泄漏</strong>。C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。</p><p>当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。（因为引用计数不会为0）为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p><p><a href="https://blog.csdn.net/c_base_jin/article/details/79440999" target="_blank" rel="noopener">c++11 weak_ptr使用</a></p><h2 id="C-STL相关"><a href="#C-STL相关" class="headerlink" title="C++STL相关"></a>C++STL相关</h2><h3 id="map和set的区别以及底层实现"><a href="#map和set的区别以及底层实现" class="headerlink" title="map和set的区别以及底层实现"></a>map和set的区别以及底层实现</h3><p>map和set都是C++的关联容器，其底层实现都是<strong>红黑树</strong>（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。</p><p>map和set区别在于：</p><ol><li>map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。</li><li>set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</li><li>map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-原理与使用技巧&quot;&gt;&lt;a href=&quot;#C-原理与使用技巧&quot; class=&quot;headerlink&quot; title=&quot;C++原理与使用技巧&quot;&gt;&lt;/a&gt;C++原理与使用技巧&lt;/h1&gt;&lt;h2 id=&quot;C-语法相关&quot;&gt;&lt;a href=&quot;#C-语法相关&quot; class=&quot;he
      
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>/2020/06/25/数据库/</id>
    <published>2020-06-25T09:44:08.000Z</published>
    <updated>2020-06-25T13:06:45.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库知识"><a href="#数据库知识" class="headerlink" title="数据库知识"></a>数据库知识</h1><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    <summary type="html">
    
      数据库知识
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="/2020/06/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>/2020/06/25/计算机网络/</id>
    <published>2020-06-25T09:44:08.000Z</published>
    <updated>2020-06-25T13:06:47.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    <summary type="html">
    
      计算机网络知识
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>从《广场协议》看近代日本经济</title>
    <link href="/2020/06/18/%E4%BB%8E%E3%80%8A%E5%B9%BF%E5%9C%BA%E5%8D%8F%E8%AE%AE%E3%80%8B%E7%9C%8B%E8%BF%91%E4%BB%A3%E6%97%A5%E6%9C%AC%E7%BB%8F%E6%B5%8E/"/>
    <id>/2020/06/18/从《广场协议》看近代日本经济/</id>
    <published>2020-06-18T05:24:25.000Z</published>
    <updated>2020-06-26T09:45:59.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从《广场协议》看近代日本经济"><a href="#从《广场协议》看近代日本经济" class="headerlink" title="从《广场协议》看近代日本经济"></a>从《广场协议》看近代日本经济</h1><p>日本经过二战之后几十年的经济发展，很快的从战败的萧条中走了出来，曾经成为仅次于美国的全球第二大经济体，然而又在极短的时间内经济全面崩盘，成为“失去的十年”，直到今天也没有完全恢复往日的荣光。对如此戏剧性的快速发展和衰败，到底是什么原因导致了近代日本的经济过山车式的发展？</p><p>首先我们从时间顺序上，以历史的角度看一看日本从二战到现在的经济是如何繁荣的。</p><p>首先在政治上，二战结束之后，日本作为战败国成为了美国的占领区。事实上日本应该是被当时苏联、美国、中国和英国四个战胜国分区占领，但除了美国之外其他国家并没有真正履行约定，最后实际由美国占领并且管控。因此从政治上讲，二战之后，日本部分的失去了自己的主权，比如从军队来看，日本无法拥有真正的海陆军，只能最多拥有自卫队。</p><p>战后的日本经济的腾飞，是通过朝鲜战争、越南战争和1964年的东京奥运会实现的。朝鲜战争和越南战争期间，日本作为美国军火和物资最大生产地，每年从美国有几十亿美元的收入。日本曾经多次申请举办奥运会，最早的一次在1940年，但是由于日本在当时进行了全面侵华战争，所以奥运会因为战争搁浅。1952年，日本终于成功申请到了1964年东京奥运会的举办资格。日本国民都将此次奥运会作为一次增强国民信心，对外展示日本战后发展的机会。在奥运会之后，日本吸引了全世界的投资，经济进一步发展。</p><p>《广场协议》是1985年美国和日本、西德、英国、法国签署的协议，内容是联合干预外汇市场，使美元对日元及德国马克等主要货币贬值，解决美国贸易赤字的问题。由于日本经济的发展和工业化的逐步成型，生产的产品质量好且比美国本土廉价。美国本土的生产企业认为由于美元对日本汇率高，因此卖不出去东西的原因是美元太贵了，不利于出口，因此向政府施压要求签署协议使得日元升值，美元贬值，得以增加出口。</p><p>《广场协议》本质是几个国家通过抛售美元，操纵汇率的协议。本来美国和日本双方都有所诉求，心怀鬼胎，但事实上最终对于美国和日本两方都没有达到自己的目的：</p><ul><li>美国想通过美元贬值刺激出口，增加国内企业在世界领域产品的竞争力。</li><li>日本如果同意日元升值，本质上是牺牲了国内出口企业的利益。但是日元升值有几个好处：第一，石油价格暴涨，石油是由美元结算，因此日元升值有利于日本进口石油。第二，日元升值对于日本人民来说是好事，购买力上升，可以在国外进口更多的商品。第三，日本由于在政治、军事上依靠美国，且最近贸易逆差的确很大，因此日本需要帮助美国解决这个问题。而事实上，经过日本政府测算，日元升值区间在10%至20%之间时，日本企业是可以承受的。</li></ul><p>但是由于日本企业在日元升值之后更进一步控制成本，导致即便日元升值也可以通过压缩成本进一步降低价格。这样一来导致美国的商品仍旧在世界范围内不会比日本有更好的竞争力。对于日本，如果日元持续升值，能降低成本的手段都用完了，日本企业只能把自己的生产线转移到人力物力更便宜的地方，比如东南亚、中国。把工厂开到外国，而日本的工人只能失业了。</p><p>日本人低估了金融市场的变化，金融市场向来是非理性化的。在1986年1月22日电视屏幕下方路透社新闻栏滑过了一行字：“竹下藏相言明可以接受190左右的日元汇率”。由此日本市场开始了日元升值的疯狂循环。日元最终由于日本政府对于升值的放任态度，导致市场恶性循环失控了。</p><p>由于日元的疯狂升值，日本很多小企业最终扛不住了。日本政府这时候进行了错误的决策，认为只要降低银行贷款利息，企业贷款更加方便，有了钱，升值带来的压力就会减小。但是拿了钱的投资人不会去投资给利润低的制造业，而是直接进入了股市和房地产。这样就进一步加大了泡沫经济，使得本就虚浮的实体经济更加无人问津。</p><p>但是实体经济才是一个国家的命脉，炒起来的股市和房市泡沫很大，一旦泡沫破了，没有制造业兜底，整个国家的经济就会崩盘。日本政府似乎也意识到了这个问题，因此再次出手，想让过热的股市和楼价降温。日本政府又祭出了5年前使用过的那招——调利率，只不过这次是往高调，而且调整的幅度太大了，1989年5月至1990年8月，日本银行五次上调中央银行的利率，从2.5％升到了6％。这是日本政府的第二次决策失误，导致了过热的经济直接硬着陆。最终导致日本的股市连带房市暴跌，银行大量坏账。</p><p>说到这里，真正的问题不在于《广场协议》，而在于日本自己的脱实向虚。金融业吸引资金的能力天生就很强，很容易就吸走实体经济的血液。日本的教训已经说明了，金融业固然不可或缺，但绝不能缺乏政府的管束，任凭其疯狂扩张。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/68807774" target="_blank" rel="noopener">知乎.被误读的“广场协议”：日本是如何把自己玩死的？</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%9C%BA%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">维基百科.广场协议</a></p><p><a href="https://www.bilibili.com/video/BV1vE411J75C" target="_blank" rel="noopener">B站.骁话一下：面对疫情日本为什么不取消奥运？带你算算政治经济社会三本账</a></p><p><a href="https://www.bilibili.com/video/BV1Y5411t73s" target="_blank" rel="noopener">B站.巫师财经：日本经济崩盘始末</a></p>]]></content>
    
    <summary type="html">
    
      为何日本会陷入“失去的三十年”？
    
    </summary>
    
      <category term="随笔" scheme="/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>高精度</title>
    <link href="/2020/06/15/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <id>/2020/06/15/高精度/</id>
    <published>2020-06-15T08:20:48.000Z</published>
    <updated>2020-06-15T09:14:39.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="高精度加法和乘法"><a href="#高精度加法和乘法" class="headerlink" title="高精度加法和乘法"></a>高精度加法和乘法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>高精度加法和高精度乘法用在某些题目中成为一个模块，不会单独出现，基本方法是用一个数组或者vector来模拟竖式加法和乘法。有些题目分析之后可能可以用double来代替高精度。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;//高精度加法vector&lt;int&gt; add(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B){    vector&lt;int&gt; C;    int t = 0;    for (int i = 0; i &lt; A.size() || i &lt; B.size() || t; i ++ )    {        if (i &lt; A.size()) t += A[i];        if (i &lt; B.size()) t += B[i];        C.push_back(t % 10);        t /= 10;    }    return C;}//高精度乘法vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b){    vector&lt;int&gt; C;    int t = 0;    for (int i = 0; i &lt; A.size() || t; i ++ )    {        if (i &lt; A.size()) t += A[i] * b;        C.push_back(t % 10);        t /= 10;    }    //12345 * 0;    while (!C.back() &amp;&amp; C.size() &gt; 1) C.pop_back();    return C;}int main(){    string a, b;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt; A, B;    for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#39;0&#39;);    for (int i = b.size() - 1; i &gt;= 0; i -- ) B.push_back(b[i] - &#39;0&#39;);    auto C = add(A, B);    for (int i = C.size() - 1; i &gt;= 0; i -- )         cout &lt;&lt; C[i];       cout &lt;&lt; endl;    return 0;}</code></pre><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>高精度加法和乘法方法如同竖式一样，高精度除法是余数每次乘10之后加上当前位除以被除数。没有涉及到两个大数相乘和相除的问题，具体方法要更加复杂。</p>]]></content>
    
    <summary type="html">
    
      高精度总结
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>DFS</title>
    <link href="/2020/06/15/DFS/"/>
    <id>/2020/06/15/DFS/</id>
    <published>2020-06-15T08:05:03.000Z</published>
    <updated>2020-06-17T15:35:23.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="DFS的多种实现方法"><a href="#DFS的多种实现方法" class="headerlink" title="DFS的多种实现方法"></a>DFS的多种实现方法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过程序调用栈自动实现DFS过程。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">int dx[] = {0, -1, 0, 1}, dy[] = {1, 0, -1, 0};int dis = 0;while (q.size()){    int len = q.size();    for (int i = 0; i &lt; len; i ++ )    {        auto t = q.front();        int x = t.first, y = t.second;        q.pop();        //如果是这里标记，队列里面有大量相同元素，虽然不影响最终得到正确结果，但是效率很低        //A[x][y] = -1;        for (int i = 0; i &lt; 4; i ++ )        {            int a = x + dx[i], b = y + dy[i];            if (a &lt; 0 || a &gt;= A.size() || b &lt; 0 || b &gt;= A[0].size()) continue;            if (A[a][b] == -1) continue;            if (A[a][b] == 1) return dis;            //就是这里要在入队之前将当前入队元素标记为已经遍历            A[a][b] = -1;            q.push({a, b});        }    }    dis ++ ;}</code></pre>]]></content>
    
    <summary type="html">
    
      DFS
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>BFS</title>
    <link href="/2020/06/15/BFS/"/>
    <id>/2020/06/15/BFS/</id>
    <published>2020-06-15T08:05:03.000Z</published>
    <updated>2020-06-28T06:20:16.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><h2 id="标准BFS"><a href="#标准BFS" class="headerlink" title="标准BFS"></a>标准BFS</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过队列每次将邻接点加入，多层扩展，BFS可以求得边权为1的情况下的最短路径，因为当第一次搜索到的都是，就是最短路径。BFS要注意元素不要在出队的时候判重，要在入队之前设置为已经遍历。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">int dx[] = {0, -1, 0, 1}, dy[] = {1, 0, -1, 0};int dis = 0;while (q.size()){    int len = q.size();    for (int i = 0; i &lt; len; i ++ )    {        auto t = q.front();        int x = t.first, y = t.second;        q.pop();        //如果是这里标记，队列里面有大量相同元素，虽然不影响最终得到正确结果，但是效率很低        //A[x][y] = -1;        for (int i = 0; i &lt; 4; i ++ )        {            int a = x + dx[i], b = y + dy[i];            if (a &lt; 0 || a &gt;= A.size() || b &lt; 0 || b &gt;= A[0].size()) continue;            if (A[a][b] == -1) continue;            if (A[a][b] == 1) return dis;            //就是这里要在入队之前将当前入队元素标记为已经遍历            A[a][b] = -1;            q.push({a, b});        }    }    dis ++ ;}</code></pre><h2 id="多源BFS"><a href="#多源BFS" class="headerlink" title="多源BFS"></a>多源BFS</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>通过设置超级源点，可以将多个分散的源点合并为一个，可以解决一个点到另外多个点的最短距离问题。我们从超级源点开始做单源BFS，发现原先的多个源点只不过是BFS的<strong>第二层</strong>而已，所以多源BFS没有改变BFS的本质，不会影响结果的正确性。</p><p><img src="https://pic.leetcode-cn.com/be6bdff2b8d983d2135e5d2675b4dae750fef16104c904e462d9b1d64ef6d8ed-%E5%A4%9A%E6%BA%90BFS.gif" alt></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">LC.1162 地图分析（中等）</a></p><h2 id="双端队列BFS"><a href="#双端队列BFS" class="headerlink" title="双端队列BFS"></a>双端队列BFS</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>双端队列BFS可以解决图中<strong>权重仅为0和1时的情况</strong>，相当于简化的dijkstra算法，可以更快的（<strong>时间复杂度为O(m)</strong>)搜到想要的答案。使用一个双端队列，队列头插入搜索权重为0的节点，队列尾插入权重为1的节点，每次从队头扩展，可以尽早的扩展那些权重为0的边，相比于BFS更快的搜索到答案。</p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;deque&gt;void bfs(){    memset(dist, 0x3f, sizeof dist);    memset(st, 0, sizeof st);    deque&lt;int&gt; q;    q.push_back(1);    while(q.size())    {        int t = q.front();        q.pop_front();        if (st[t]) continue;        st[t] = true;        for (int i = h[t]; ~i; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            {                dist[j] = dist[t] + w[i];                if (!w[i]) q.push_front(j);                else q.push_back(j);            }        }    }}</code></pre><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/177/" target="_blank" rel="noopener">AW.175 电路维修（简单）</a></p><p><a href="https://www.acwing.com/problem/content/342/" target="_blank" rel="noopener">AW.340 通信线路（中等）</a></p><p>这题是二分+双端广搜</p>]]></content>
    
    <summary type="html">
    
      BFS
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划（一）背包专题</title>
    <link href="/2020/06/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E8%83%8C%E5%8C%85%E4%B8%93%E9%A2%98/"/>
    <id>/2020/06/12/动态规划（一）背包专题/</id>
    <published>2020-06-12T08:06:40.000Z</published>
    <updated>2020-06-12T13:34:40.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背包专题"><a href="#背包专题" class="headerlink" title="背包专题"></a>背包专题</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>dp[i][j]</code>表示考虑到第i个元素时，背包容量为j的情况下的最大价值。初始条件为<code>dp[0][i]</code> = 0，表示当考虑前0个物品时，无论背包容量为多少，最大价值都是0。状态转移方程可以通过定义得到，当前状态由前一个状态拿当前物品i或者不拿当前物品i转移过来。一维空间形式循环顺序要从m到v[i]，原因是省略了i - 1维度。</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])</script><script type="math/tex; mode=display">dp[j] = max(dp[j], dp[j - v[i] + w[i]]), j ∈(m,v[i])</script><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">for (int i = 1; i &lt;= n; i ++ )    for (int j = m; j &gt;= v[i];j -- )        f[j] = max(f[j], f[j - v[i]] + w[i]);</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">AW.2 01背包问题（简单）</a></p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>如果按照01背包的状态定义和状态转移方程思维方式，我们不难得出如下的状态转移方程。</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i], ... , dp[i - 1][j - s * v[i]] + s * w[i]);</script><p>如果直接循环则需要3重循环来实现，但是我们发现上述部分项已经计算过了。</p><script type="math/tex; mode=display">dp[i][j - v[i]] + w[i] = max(dp[i - 1][j - v[i]] + w[i], dp[i - 1][j - 2 * v[i]] + 2 * w[i] , ... , dp[i - 1][j - s * v[i]] + s * w[i]);</script><p>所以<code>dp[i][j]</code>可以进行简化为：</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]), j∈(v[i], m)</script><p>如果化简为一维形式，由于需要简化的是<code>dp[i][j - v[i]]</code>，应该体积从小到大循环。这里可以优化的原因是，体积一定的情况下，如果可以随意拿取，那么拿取的s件一定是固定值，注意和下边的多重背包区分。</p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">for (int i = 1; i &lt;= n; i ++ )    for (int j = v[i]; j &lt;= m; j ++ )        f[j] = max(f[j], f[j - v[i]] + w[i]);</code></pre><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">AW. 完全背包问题（简单）</a></p><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">LC.322 零钱兑换（中等）</a></p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><ul><li>多重背包问题可以使用三重循环直接暴力求解，也可以使用二进制优化。暴力求解和上述完全背包问题相似，在于每次要确定s个物品，这里无法进行完全背包的优化，因为每次求解的s并不是固定值。</li><li>二进制优化的原理是将多个物品打包成一个物品来看，将最多选s个物品的问题转化成log(s)个物品的 01背包问题，从而降低复杂度。可以证明每次选取1,2,4,8,16…(s- 2^k - 1)个物品打包之后，每个物品选与不选的组合（看做01背包）可以得到s种结果。这里二进制优化的思想很有意思，可以类比快速幂和龟速乘。</li></ul><h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//暴力求解多重背包问题for (int i = 1; i &lt;= n; i ++ )    for (int j = 0; j &lt;= m; j ++ )        for (int t = 0; t &lt;= s[i]; t ++ )            if (j - s * v[i] &gt;= 0)                f[i][j] = max(f[i][j], f[i - 1][j - s * v[i]] + s * w[i]);//二进制优化#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 12010, M = 2010;int V[N], W[N];int idx;int n, m;int f[M];int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    //对于每一个物品将s件拆解成log(s)件打包的物品    for (int i = 0; i &lt; n; i ++ )    {        int v, w, s;        scanf(&quot;%d%d%d&quot;, &amp;v, &amp;w, &amp;s);        int k = 1;        while (k &lt;= s)        {            ++ idx;            V[idx] = k * v;            W[idx] = k * w;            s -= k;            k *= 2;        }        //如果还有剩余不满足2的幂次也要打包        if (s)        {            ++ idx;            V[idx] = s * v;            W[idx] = s * w;        }    }    //用01背包求解    for (int i = 1; i &lt;= idx; i ++ )        for (int j = m; j &gt;= V[i]; j -- )            f[j] = max(f[j], f[j - V[i]] + W[i]);    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><p><a href="https://www.acwing.com/problem/content/4/" target="_blank" rel="noopener">AW.4 多重背包问题I（简单）</a></p><p><a href="https://www.acwing.com/problem/content/5/" target="_blank" rel="noopener">AW.5 多重背包问题II（中等）</a></p><p>第二题主要考察二进制优化</p><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>分组背包问题指有很多物品组，从每组中只能挑选一个物品，求最大价值。分组背包是有依赖的背包问题的前序问题。</p><h3 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h3>]]></content>
    
    <summary type="html">
    
      动态规划背包专题
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>离散化</title>
    <link href="/2020/06/11/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <id>/2020/06/11/离散化/</id>
    <published>2020-06-11T11:28:11.000Z</published>
    <updated>2020-06-11T11:28:14.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="通过哈希表进行离散化"><a href="#通过哈希表进行离散化" class="headerlink" title="通过哈希表进行离散化"></a>通过哈希表进行离散化</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;建立一个哈希表，通过每次将新的值映射为一个递增的n来达到离散化的目的。这种离散化不要求顺序，只需要值的对应即可。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">int find(int x){    if (S.count(x) == 0) S[x] = ++ n;    return S[x];}</code></pre><p><img src="https://i.loli.net/2020/06/11/Ghvsez17FXYmINB.jpg" alt></p><h2 id="排序-去重-二分查找进行离散化"><a href="#排序-去重-二分查找进行离散化" class="headerlink" title="排序+去重+二分查找进行离散化"></a>排序+去重+二分查找进行离散化</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;当要求有序的离散化时，需要将需要离散化的坐标排序，之后去重，最后使用二分查找获得映射后的坐标。这里其实相当于将排序后的数组下标作为离散化后的值。这种离散化的好处就是保序，当计算原下标3-7之间的结果时，直接计算离散化之后find(3)-find(7) = 3 - 5之间的结果即可。</p><p><img src="https://i.loli.net/2020/06/11/vIzDqYwVsuAeUaN.jpg" alt></p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">int find(int x){    int l = 0, r = n - 1;    while (l &lt; r)    {        int mid = l + r &gt;&gt; 1;        if (a[mid] &gt;= x) r = mid;        else l = mid + 1;    }    return r;}//排序+去重sort(pts.begin(), pts.end());pts.erase(unique(pts.begin(), pts.end()), pts.end());</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/804/" target="_blank" rel="noopener">AW.802 区间和（简单）</a></p>]]></content>
    
    <summary type="html">
    
      离散化模板和常见套路
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="/2020/06/11/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>/2020/06/11/快速幂/</id>
    <published>2020-06-11T06:12:16.000Z</published>
    <updated>2020-06-11T06:50:00.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;可以在log(k)的时间复杂度下计算a^k (mod p)的值。将k以2进制展开，其中的每一个1相当于乘以a^(2^m)。</p><p>假设 k的二进制表示为10010101:</p><script type="math/tex; mode=display">a^k = a^{2^0} * a^{2^2} * a^{2^4} * a^{2^7}</script><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">LL qmi(LL a, LL k, LL p){    LL res = 1;    while (k)    {        if (k &amp; 1)        {            res = res * a % p;            a = a * a % p;        }        k &gt;&gt;= 1;    }    return res;}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/877/" target="_blank" rel="noopener">AW.875 快速幂（简单）</a></p><p><a href="https://www.acwing.com/problem/content/878/" target="_blank" rel="noopener">AW.876 快速幂求逆元（简单）</a></p><p>快速幂求逆元用到了费马小定理，是扩展欧几里得定理的一个特例</p>]]></content>
    
    <summary type="html">
    
      快速幂模板
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>单调栈与单调队列</title>
    <link href="/2020/06/10/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <id>/2020/06/10/单调栈与单调队列/</id>
    <published>2020-06-10T14:58:03.000Z</published>
    <updated>2020-06-11T03:19:04.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调栈与单调队列"><a href="#单调栈与单调队列" class="headerlink" title="单调栈与单调队列"></a>单调栈与单调队列</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;单调栈使用范围比较小，已知有两种用法，其中第一种用法比较经典，用的较多，第二种用法出现较少。</p><ol><li><p><strong>寻找数组中某一个数左边、右边第一个比它大或小的数</strong>。首先要找到最近的一个数，并且满足这个数和当前数的单调关系（比它大或者小）。栈的特点是后进先出，在这里其实利用了栈“<strong>最近</strong>”的思想，而单调性能够确保与栈顶比较时，相当于比较了所有之前的数据，降低了时间复杂度。</p><p>&emsp;&emsp;Condition 1 ：以寻找数列中每一个数左边第一个比它小的数为例，如果使用单调递增栈，<strong>当前元素大于栈顶元素</strong>，则相当于大于栈中所有元素，当前元素左侧第一个比它小的数就是栈顶元素；</p><p>&emsp;&emsp;Condition 2 ：如果<strong>当前元素小于栈顶元素</strong>，那么当前元素<strong>左侧比当前元素还大的</strong>那些元素（即已经在栈中）就永远不需要考虑了（我要找的是更小的！），并且可以在这个过程中直接出栈。原因是，这些出栈的元素在更靠后的元素考虑时，肯定不会是答案，因为使得这个元素出栈的元素，会距离更近且更小，具体看下图会更加清晰。可以看到，4号元素在找左侧更小的元素时，一定不会找到2号元素，因为3号元素一定更早被选择。</p><p><img src="https://i.loli.net/2020/06/10/nPoi2mMvOVHt1uy.jpg" alt></p></li><li><p><strong>寻找数组中两个数之间满足i &lt; j 且 A[i] &lt;= A[j]的情况下，下标之间的最大距离</strong>。这种可以看做<strong>全局的单调性和“最近”性质</strong>的应用，并且还有<strong>双指针</strong>的思想。这里有个重点是，当从右向左考虑元素时，只需要考虑当前元素左侧是否会产生最大值，不用考虑右侧的情况，因为右侧已经考虑过了。首先从左向右初始化单调递减栈，之后从右向左每次元素和栈顶元素比较，通过出栈每次确认当前最小的元素是否更新了答案，直到栈顶元素大于当前遍历元素：</p><p>&emsp;&emsp;Condition 1 ：如果当前元素小于栈顶（当前最小值），则栈内其他元素均不满足A[i] &lt;= A[j]的要求，更进一步说明栈顶元素左侧所有元素均无法产生答案；栈顶右侧元素一定已经和当前元素右侧的元素更新过答案（因此才被弹出栈），所以再和当前元素产生的答案，肯定无法更新答案（从右向左，每次都在递减）。</p><p>&emsp;&emsp;Condition 2 ：如果当前元素大于栈顶，由于栈顶元素右边的元素更靠近序列右侧，所以最大距离一定更小，即便和当前元素能产生正确大小关系，也不会更新答案。之后我们无法确定左侧元素是否还能继续产生更大答案，所以栈顶元素出栈，继续比较。能够安全出栈的原因是，右侧当前元素每次都在减少，因此贪心的认为，之后即便有满足要求的元素，也不会更新最大距离（与第一种情况的栈顶右侧元素一致）。</p></li></ol><p>&emsp;&emsp;假设序列是 <strong><u>A</u> <u>B</u> C <u>D</u> E F G H</strong>，从左到右入递减栈的是A B D，那么假设当前元素为G：</p><ol><li>如果G &gt;= D，D出栈，考虑B，如果G &gt;= B, 即使G &gt;= C没有产生更大答案，如果G &lt; B，因为从左到右是单调栈，因此C &gt; B, 若G &gt; C，可以推导出C &lt; G &lt; B, B &gt; C，冲突，所以不用考虑G &gt; C的情况。</li><li>如果G &lt; D,  比最小值还小，那么栈顶元素左侧没有可以满足条件的情况；而右侧E F即便有更小，也无法更新答案。</li></ol><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//寻找数组中某一个数左边第一个比他大的数for (int i = 0; i &lt; n; i ++ ){    while (!st.size() &amp;&amp; s[i] &gt;= st.top()) st.pop();    if (st.size()) cout &lt;&lt; st.top() &lt;&lt; &quot; &quot;;    else cout &lt;&lt; &quot;-1 &quot;;    st.push(s[i]);}//寻找i &lt; j 且 A[i] &lt; A[j]条件的最大j - istack&lt;int&gt; st;int n = A.size();for (int i = 0; i &lt; n; i ++ )    if (st.empty() || A[i] &lt; A[st.top()])        st.push(i);int ans = 0;for (int i = n - 1; i &gt;= 0; i -- ){    while (st.size() &amp;&amp; A[i] &gt;= A[st.top()])    {        ans = max(ans, i - st.top());        st.pop();    }    if (!st.size()) break;}return ans;</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/832/" target="_blank" rel="noopener">AW.830 单调栈（简单）</a></p><p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">LC.739 每日问题（中等）</a></p><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">LC.42 接雨水（困难）</a></p><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">LC.84 柱状图中最大的矩形（困难）</a></p><p><a href="https://leetcode-cn.com/problems/maximum-width-ramp/" target="_blank" rel="noopener">LC.962 最大宽度坡（中等）</a></p><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;单调队列是队头维护的是整个队列中最大或者最小的元素，每次有新元素入队时，如果不满足当前队列维护的单调性，则将所有不满足的元素全部出队。单调队列本质是一个双端队列，每次出队时是从队尾出队，而不是从队头出队。<strong>单调队列可以解决滑动窗口的最值问题</strong>，以及与之相关的优化。</p><p>&emsp;&emsp;单调队列操作顺序也比较重要，在不同需要的时候有不同的操作顺序。</p><ol><li>计算是否当前元素和队头元素距离之差大于规定值，如果大于则队头出队。</li><li>计算答案，此时是计算的[0, r - 1]范围内的最值，因此放在第二步。</li><li>保持队列单调性，while循环从队尾出队。</li><li>将当前元素入队。</li><li>*若计算答案在这里，则是求的[0, r]范围内的最值。</li></ol><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//k是窗口大小, 计算最大值, 手动模拟队列int q[N];int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ ){    if (hh &lt;= tt &amp;&amp; i - q[hh] + 1 &gt; k) hh ++ ;    while (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) tt -- ;    q[++ tt ] = i;    if (i &gt;= k - 1) cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;;}</code></pre><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/156/" target="_blank" rel="noopener">AW.154 滑动窗口（简单）</a></p>]]></content>
    
    <summary type="html">
    
      单调栈和单调队列总结
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="/2020/06/08/KMP%E7%AE%97%E6%B3%95/"/>
    <id>/2020/06/08/KMP算法/</id>
    <published>2020-06-08T14:02:01.000Z</published>
    <updated>2020-06-08T14:02:23.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;KMP算法核心是ne数组，其定义是：<strong>从0（空串）到第i个模板串字符的子串为止，子串中前缀和后缀相等的最大长度，其中前缀和后缀不包括子串本身。</strong></p><p>&emsp;&emsp;举例来说，对于字符串ababab（按照下标从1开始存储，更为方便）：</p><ul><li>ne[0]总是0的原因是空串最长前缀也是0。</li><li>ne[1] = 0的原因是长度为1的子串前缀如果<strong>不包括子串本身</strong>，也只有长度为0的空串，因此也是0。</li><li>ne[2] = 0，(ab)abab此时子串ab的前缀没有和后缀相等的匹配。</li><li>ne[3] = 1，(aba)bab的前缀可以看到下s[1] = a和s[3] = a相等。</li><li>ne[4] = 2，(abab)ab的前缀可以看到{s[1], s[2]} = ab和{s[3], s[4]} = ab相等，这里由于只增加了一个字母，且当前最长前缀用到了长度为3子串时的最长前缀，所以最长前缀长度<strong>最多增加1</strong>，这一点很重要，是<strong>动态规划的思想</strong>。</li><li>ne[5] = 3，(ababa)b，可以看到{s[1], s[2], s[3]} = aba和{s[3], s[4], s[5]} = aba相等。</li><li>ne[6] = 4，（ababab), abab = abab。</li></ul><p>&emsp;&emsp;通过ne数组的定义，我们可以知道，当模板串和匹配串两个字符不匹配的时候，此时模板串的匹配位置就不必向后错一个位置继续从头匹配，而是从下一个前缀已经匹配完全的位置开始。</p><p>&emsp;&emsp;这里通过将开始下标设置为1，之前定义的ne数组是前后缀的最大长度，正好也是当不匹配时，模板串应该移动到的下标位置。</p><p>&emsp;&emsp;KMP算法求模板串ne数组的方法实际上是一种动态规划。每次使用了之前模板串中相同的长度，并且每次最长前缀最多+1，来计算下一次的最长前缀。当无法匹配的时候，正好通过定义j = ne[j]来跳到最大匹配位置继续。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//n是模板串长度，m是匹配串长度//p存储模板串，s存储匹配串//产生ne数组的过程，模板串自己和自己匹配for (int i = 2, j = 0; i &lt;= n; i ++ ){    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];    if (p[i] == p[j + 1]) j ++ ;    ne[i] = j;}//在匹配串中匹配的过程for (int i = 1, j = 0; i &lt;= m; i ++ ){    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];    if (s[i] == p[j + 1]) j ++ ;    if (j == n)    {        //输出位置etc.        j = ne[j];    }}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/833/" target="_blank" rel="noopener">AW.831 KMP字符串（简单）</a></p>]]></content>
    
    <summary type="html">
    
      KMP算法
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="/2020/06/04/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>/2020/06/04/位运算/</id>
    <published>2020-06-04T06:26:01.000Z</published>
    <updated>2020-06-08T05:30:25.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h3 id="亦或运算"><a href="#亦或运算" class="headerlink" title="亦或运算"></a>亦或运算</h3><p>&emsp;&emsp;亦或运算本质是定义了一组操作，0^0 = 0, 1^1 = 0, 1^0 = 1, 0^1 = 1，描述为相同为0，不同为1。从定义来看，可以判断两个数是否相同，如果为0则相同，为1则不同。进一步，由于有结合律，可以消除一个序列中所有相同的数组，即a^b^c = (a^b)^c = a^(b^c)。在进一步思考，其实所有能够满足上述运算规律的情况都可以用亦或运算来实现，简单有效。比如无进位二进制加法，实际上与0+0 = 0, 1+1 = 0, 1+0 = 1, 0+1 = 1相同。奇偶性检验，如果我们把奇数看做1，偶数看做0，则有0+0 = 0, 1+1 = 0, 1 + 0 = 1, 0 + 1 = 1，和亦或操作一样。凡是有两个相反、相对的状态，都可以抽象为 0 和 1。另外对于奇偶性一般都会有简单的考察：奇数+奇数 = 偶数，以及奇数 - 1 = 偶数这两条基本性质。</p><p>​     状态压缩题目中一般应用按位与、或和亦或运算会将状态之间的转换变得容易很多。包括如果想取得某一位的状态，可以用 i &gt;&gt; j &amp; 1来计算。</p>]]></content>
    
    <summary type="html">
    
      位运算
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>最短路径算法</title>
    <link href="/2020/06/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    <id>/2020/06/04/最短路径算法/</id>
    <published>2020-06-04T06:26:01.000Z</published>
    <updated>2020-06-20T06:27:47.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h1><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;使用邻接矩阵存储图更为合理，因为floyd算法要求每两个点之间的最短路径。循环顺序是kij其中k是阶段，从ik到kj点的最短路径由松弛操作</p><script type="math/tex; mode=display">g[i][j] = min(g[i][j], g[i][k] + g[k][j])</script><p>给出。当有重边和自环时，每两个点之间存储的<code>g[i][j]</code>只存储最短的一条即可。时间复杂度为<strong>O(n^3)</strong>。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/856/" target="_blank" rel="noopener">AW.854 Floyd求最短路（简单）</a></p><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;使用dist数组来维护所有点到源点的最短距离，用st数组维护已经确定最短距离的点。<strong>st数组一定要从空集开始</strong>，这样才能更新1号点。从所有点中选择<strong>距离源点最近的点</strong>来更新，将其所有临接点到源点的最短距离更新。最终更新了n个点后，所有点到达最短距离。时间复杂度为<strong>O(n^2)</strong>。</p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int d[N][N];int n, m;int dist[N];bool st[N];void dijkstra(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for (int i = 1; i &lt;= n; i ++ )    {        int t = -1;        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        st[t] = true;        for (int j = 1; j &lt;= n; j ++ )            if (dist[j] &gt; dist[t] + d[t][j])                dist[j] = dist[t] + d[t][j];    }    if (dist[n] == INF) cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;}int main(){    cin &gt;&gt; n &gt;&gt; m;    memset(d, 0x3f, sizeof d);    for (int i = 1; i &lt;= m; i ++ )    {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        d[a][b] = min(d[a][b], c);    }    dijkstra();    return 0;}</code></pre><h2 id="堆优化的Dijkstra"><a href="#堆优化的Dijkstra" class="headerlink" title="堆优化的Dijkstra"></a>堆优化的Dijkstra</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;维护一个堆，堆中储存一对信息（<strong>距离源点距离</strong>，<strong>当前点序号</strong>），从而每次得到距离源点最近的点的编号，扩展所有邻接点。这里不能保证每个点只入堆一次，因此当第一次从堆出来以后，再出来的就是错误的更新点，因此使用判重布尔数组st来continue。时间复杂度因为有堆进行优化，所以是<strong>O(mlogn)</strong>。</p><h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 150010, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], w[N], idx;int n, m;int dist[N];bool st[N];void dijkstra(){    memset(dist, 0x3f, sizeof dist);    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    dist[1] = 0;    heap.push({0, 1});    while (heap.size())    {        auto t = heap.top();        heap.pop();        int ver = t.y, distance = t.x;        if (st[ver]) continue;        st[ver] = true;        for (int i = h[ver]; ~i; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[ver] + w[i])            {                dist[j] = dist[ver] + w[i];                heap.push({dist[j], j});            }        }    }    if (dist[n] == INF) cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;}void add(int a, int b, int c){    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;}int main(){    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);    while (m -- )    {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);    }    dijkstra();    return 0;}</code></pre><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman Ford"></a>Bellman Ford</h2><p>&emsp;&emsp;可以求解不超过k条边的最短路径，通过k次循环，每次备份dist数组，每次遍历所有的边，通过上次dist数组更新本次dist数组，可以求取负边权的情况。时间复杂度是<strong>O(km)</strong>，因为每次经过k次迭代，每次迭代m条边。</p><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;SPFA算法是<strong>队列优化</strong>的Bellman Ford算法，由于Bellman Ford算法需要k次更新所有的边，但是其中某些边在没有最短路径涉及时不需要更新。SPFA算法通过维护队列，将<strong>每次被更新的点加入队列</strong>，每次只更新队列内部的点，这样就减少了很多不必要点的更新操作。队列里是所有被更新过的点，因此可以<strong>维护st数组</strong>，当某个点被多个点更新时，就不用重复进入队列作为一下步扩展更新了。时间复杂度是<strong>O(nm)</strong>，但是实际上会比这个复杂度快很多，接近于<strong>O(m)</strong>。有可能会被特殊的图卡时间复杂度，如果没有卡，算是最短路径里面最好用的算法了。</p><p>&emsp;&emsp;实现过程中，使用<strong>循环队列</strong>，因为一共需要更新多少次不一定，如果使用n * m的队列太大了。</p><h3 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010;const int INF = 0x3f3f3f3f;int h[N], e[N], ne[N], w[N], idx;int n, m;int dist[N], q[N];bool st[N];//这里spfa使用了循环队列void spfa(){    int hh = 0, tt = 1;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    q[0] = 1;    st[1] = true;    while (hh != tt)    {        int t = q[hh ++ ];        if (hh == N) hh = 0;        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            {                dist[j] = dist[t] + w[i];                if (!st[j])                 {                    q[tt ++ ] = j;                    st[j] = true;                }                if (tt == N) tt = 0;            }        }    }    if (dist[n] &gt;= INF / 2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;}void add(int a, int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;}int main(){    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);    while (m -- )    {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);    }    spfa();    return 0;}</code></pre><h2 id="SPFA判断负环"><a href="#SPFA判断负环" class="headerlink" title="SPFA判断负环"></a>SPFA判断负环</h2><p>&emsp;&emsp;SPFA算法当队列不空的时候就会不断的更新图中路径的最短值，每次更新相当于多走一条边，当有负环的时候，某些节点一定会被无限次更新到负无穷，因此用cnt数组来记录每一个点的被更新次数，当某个点更新次数大于n – 1时，说明存在一条路径当我更新n – 1次之后，还可以更小，这样就是存在负环了。开始时一定要把所有点都加入到队列中，否则只更新某一个点，也许去其他点的路径可以不经过负环，也就不会无限更新，就找不到负环来判断。</p>]]></content>
    
    <summary type="html">
    
      最短路径算法
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
