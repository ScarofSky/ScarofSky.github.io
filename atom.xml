<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天の痕的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-08-28T15:53:38.316Z</updated>
  <id>/</id>
  
  <author>
    <name>天の痕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020年秋招攻略</title>
    <link href="/2020/08/25/%E9%9A%8F%E7%AC%94/2020%E5%B9%B4%E7%A7%8B%E6%8B%9B%E6%94%BB%E7%95%A5/"/>
    <id>/2020/08/25/随笔/2020年秋招攻略/</id>
    <published>2020-08-25T05:24:25.000Z</published>
    <updated>2020-08-28T15:53:38.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020年秋招攻略"><a href="#2020年秋招攻略" class="headerlink" title="2020年秋招攻略"></a>2020年秋招攻略</h1><p>2020年秋招在7月到9月之间已经进行到了最为白热化的阶段。我从2019年8月29日开始第一次刷Leetcode准备秋招为止，已经过了整整一年的时间。从一脸懵逼到现在的熟悉，很有感触。这里进行记录，如果能够帮助之后秋招的学弟学妹，就感到非常欣慰了。由于我的专业是计算机视觉（神经网络那一套东西），从2018年开始招聘形势逐年恶化，很多岗位饱和，因此竞争压力很大，没有CVPR等顶会论文很难找到像样的算法工程师职位，所以只好转开发。如果有很多论文的大佬，后边就不用看了，算法考察点和开发区别比较大。</p><h2 id="秋招流程"><a href="#秋招流程" class="headerlink" title="秋招流程"></a>秋招流程</h2><h3 id="暑期实习"><a href="#暑期实习" class="headerlink" title="暑期实习"></a>暑期实习</h3><p>在正式秋招开始之前，也就是2020年的3月到5月之间，一部分公司会开启暑期实习。通过去公司进行1-3个月的暑期实习，最终会有大概率（50%以上）发放offer。这个暑期实习不同于其他时间的实习，是公司专门为有意向来公司工作的同学提供的快捷通道，一般也要经过2-3次的面试才可以进入。</p><h3 id="提前批"><a href="#提前批" class="headerlink" title="提前批"></a>提前批</h3><p>所谓提前批，是秋招的一部分。提前批一般在秋招之前，从6月下旬开始公司会陆续开启提前批的投递和面试，一般7月中旬就结束了。提前批比较好的一点是绝大多数没有笔试，只有面试，可以减少复习的量。但是时间相对也更早，没有足够的复习时间。提前批的难度不统一，有的是大佬专享，招的是大佬；有的和正式批几乎一样，甚至更简单一点，因公司而异。</p><h3 id="春招与秋招"><a href="#春招与秋招" class="headerlink" title="春招与秋招"></a>春招与秋招</h3><p>假设我是2021年毕业的毕业生，总共可以参加的校园招聘一共有两场，分别是秋招和次年春招，也就是2020年7月到9月之间的招聘和2021年1月到3月的招聘。其中HC(head count，就是招聘名额)最多的，是2020年秋招，基本上绝大多数的人毕业之后都在这个时间段期间找到了工作，次年就可以去上班当社畜了。所谓春招，更像是秋招的补录，因此如果能在秋招找到工作，无疑是更加主动和稳妥的。但是即便没有找到，也不要慌，春招还有一些 机会，一定要把握住。</p><h2 id="秋招准备"><a href="#秋招准备" class="headerlink" title="秋招准备"></a>秋招准备</h2><h3 id="简历准备"><a href="#简历准备" class="headerlink" title="简历准备"></a>简历准备</h3><p>首先，如果没有实习经历的同学非常推荐去参加暑期实习，如果实习最终拿到了offer，那么血赚；如果没有拿到offer，也有一段大厂的实习经历，这非常重要。</p><p>这里就要说到简历的准备，一般来说简历要干净整洁，并且必要的信息一定要全面，包括自己的联系方式，邮箱（北航的同学不建议留学校邮箱，因为安全问题可能offer邮件会被屏蔽），还有获得过的学校内的奖项。因为校招很多时候看重的不是你项目经历，学校的那些项目，大家也心知肚明是什么情况，如果能够入企业法眼，那真的是万里挑一的好项目了。校招更看重的是你的基础是否牢靠，能力是否足够、值得继续进一步的培养。因此，不用担心自己简历上项目不够优秀，只要在学校中有所建树，学习足够扎实，是没有太大问题的，包括面试过程中，也不会一直问项目相关的问题，往往项目只是一个提问的出发点。当然，如果有实习经历的同学，一定要写上去，而且对于做过的事情要写的详细一点，并且烂熟于心，当面试官无论从哪个方向提问，都要能回答上才行。</p><h3 id="笔试准备"><a href="#笔试准备" class="headerlink" title="笔试准备"></a>笔试准备</h3><p>此部分ACMer可以略过，不需要看。</p><p>秋招在你投递简历之后，分为笔试和面试两部分。一般来说如果学校水平不是很差，都会给你笔试的机会，简历是可以通过的。相比于面试，笔试一般是1-2小时的编程题，2-3道。有些公司会加上单向选择题，主要考察基础知识。其中笔试主要有区分度的部分是编程，这里编程的难度高于面试中的难度，甚至有一部分会达到竞赛难度。但是不用怕，因为打过竞赛的毕竟是少数，所以只要3题中能AC一道题，就可以稳稳的拿到面试通知。亲测有效。</p><p>如果想进行学习和练习，推荐Acwing的算法提高课，以及各大OJ，一般笔试的难度是其中简单和中等的难度。</p><h3 id="面试算法题准备"><a href="#面试算法题准备" class="headerlink" title="面试算法题准备"></a>面试算法题准备</h3><p>此部分ACMer依然可以跳过，你已经是大佬了，受我一拜。</p><p>众所周知，国内互联网企业招聘喜欢在面试过程中让应聘者做一些算法题，来考察其思维能力与习惯，以及写代码的能力。从最开始只要求应聘者写简单的快速排序与二分，到现在面试中也可能出动态规划的问题，面试的难度在客观上是增加了的。因此我们也需要应对的学习并且准备一下面试时常考的算法题。我大学时数据结构与算法学的并不是非常牢固（和打比赛的ACMer相比更是差远了），因此我认为最重要的任务就是这一部分。经过一段时间的刷题，我总结出当前比较好的刷题方式和顺序：</p><ol><li>Leetcode刷200道easy和medium难度的算法题，不要碰hard难度的题，打击信心且无意义，主要是找手感，并且熟悉一些所用语言的语法，我主要是用C++，因此之后也用C++举例。如果基础较好，可以跳过此部分。</li><li>推荐去www.acwing.com报名学习算法基础课（价格200块，有时候会有优惠），将双指针、二分、快排、前缀和等较为简单的部分进行系统的学习，对动态规划和贪心问题有初步的理解，熟练编写DFS和BFS。一般来说每道题刷2遍+总结可以达到这种状态。如果不想花太多钱，也可以买《算法竞赛入门经典》来看，作者刘汝佳。</li><li>继续刷Leetcode，主要关注medium以及以上的题目，可以尝试挑战hard题目来锻炼自己思维的简洁性。对于已经做过一遍的题目，这时要仔细思考，精简代码，并且进一步理解其含义，不仅仅是AC，要尝试用多种方法求解。</li><li>面试开始前两周左右可以开始刷《剑指offer》，其实之前也可以在Leetcode上刷，但因为面试中很大概率（60%以上）会出剑指offer上的原题，因此可以在面试之前刷，突击效果会好一些。</li></ol><p>另外很推荐Acwing全家桶系列，从语法基础课、算法基础课、算法提高课到算法进阶课，如果能将这些耐心学完，基本上可以和ACMer做朋友了。我本人是学了算法基础课和算法提高课，感觉受益良多。</p><h3 id="计算机通识知识准备"><a href="#计算机通识知识准备" class="headerlink" title="计算机通识知识准备"></a>计算机通识知识准备</h3><p>除了算法题之外，我们还需要准备计算机通识知识。所谓计算机通识知识，可以认为是大学中的基础课。一般来说，大学中的《计算机网络》、《数据库》、《操作系统》这几门课中的知识，都会在面试中出现。因为我面试的岗位有C++开发工程师，所以也会出现一些关于C++语言相关的问题，当然如果是Java开发等，都会有响应的问题。</p><p>如果大学时期这些基础课你都认认真真的学习了，那么现在复习起来，更加轻松。如果没有学习，需要多预留出一部分时间，这样才更为妥当。复习的方式因人而异，但是我并不推荐拿起课本一页一页的看，一个是时间来不及，另外很少有人能够坚持下来。我推荐的学习顺序如下：</p><ol><li>上牛客网寻找面经，针对面经中的问题，一个一个的过，如果当前问题你无法清晰简洁的回答上来，那么就将其记录下来。如果能够清晰简洁的回答，但是多次出现，也需要进行记录。</li><li>对于所有记录下来的问题，分门别类的进行复习和总结。将其相关的知识和概念，总结成知识体系。</li></ol><p>以上需要多次反复复习，并且一定要注意细节问题，有些时候面试官会在细节方面深究，多问几个为什么。</p><h2 id="时间分配"><a href="#时间分配" class="headerlink" title="时间分配"></a>时间分配</h2><p>对于准备的时间分配，我大部分放在了算法的学习上，其余的放在了通识知识的准备。这个因人而异，但是总体来说，要针对自己的短板进行准备。12个月中，除了2月份过年懒了，其余时间基本上保证每天1-2道Leetcode题目的频率，每天1h左右的计算机通识知识的学习，弄懂1-2个知识点。这样最终完成了Acwing上245道题目和Leetcode上650道题目的学习，算法已经满足面试要求。对于毕业年级的同学，也要考虑毕业设计的时间花费，毕竟毕设做不完是不能毕业的，拿到什么offer都是扯淡了。</p><h2 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h2><p>我个人体会到的面试技巧无他，唯有真诚。说白了就是，会就是会，不会就是不会，不要不懂装懂，但是在被问道能力范围之外的情况时，可以思考一下，即如果是自己的话，会如何处理当前情况。面试技巧方面，可以多看看牛客上的面经，会有很大的启发。另外，一定要保持一个乐观和自信的心态，无论你做的东西有多low，将其讲清楚也是也是一项比较重要的能力。不用紧张，事实上有些面试官不一定有你了解他问的这些问题，你只需要将你会的东西有逻辑的讲出来就很好了。</p><p>面试大多数公司会有三次技术面试，还有一部分会有HR面。技术面会首先从项目经历入手，然后开始问一些计算机通识知识，最后再做一道或者两道算法题。总共面试时间在1小时左右。面试的难度不一定一样，一般一面会简单一些，之后的二面和三面会更难一点，原因是一面都是你面试的部门的同事（有的挺水的），二面是部门leader，三面是更高一层次的工程师。但是这并不意味这算法题更难，可能只是问题更加无法准备，是比较独特的一些需要主动思考的问题。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>写了这么多，不知道是否对你有帮助？说到底我也是一个蒟蒻（我挺喜欢这个词，弱且是菜），无论在什么情况下都是一个学习的过程，当一次面试有问题没有答上来的时候，可以记住这个问题，然后多学习一下，因为这就是你现在的短板。每当你补齐一块短板的时候，你离你预想的offer就又进了一步。还有就是心态一定要好，很多时候事情不是一蹴而就的，如果一两次的挫折让你灰心丧气，我认为是不可取的。我在面试的过程中，也挂过了好几家，都是算法题也没做出来，问题也没回答上，甚至有同学在三面被人挂掉两次。但继续往前走吧，人生也是如此，坚持学习，虚心请教，努力思考，那么最终的结果就不必要问了，正是“但问耕耘，莫问收获，庄敬日强，功不唐捐”。</p><p>最后 ，希望你能在秋招中获得一个满意的offer！</p>]]></content>
    
    <summary type="html">
    
      如何在秋招时获取一个满意的Offer？
    
    </summary>
    
      <category term="随笔" scheme="/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="/2020/08/23/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>/2020/08/23/算法/位运算/</id>
    <published>2020-08-23T05:23:01.000Z</published>
    <updated>2020-08-29T12:37:04.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="亦或运算"><a href="#亦或运算" class="headerlink" title="亦或运算"></a>亦或运算</h2><p>&emsp;&emsp;亦或运算本质是定义了一组操作，0^0 = 0, 1^1 = 0, 1^0 = 1, 0^1 = 1，描述为相同为0，不同为1。从定义来看，可以判断两个数是否相同，如果为0则相同，为1则不同。进一步，由于有结合律，可以消除一个序列中所有相同的数组，即a^b^c = (a^b)^c = a^(b^c)。在进一步思考，其实所有能够满足上述运算规律的情况都可以用亦或运算来实现，简单有效。比如无进位二进制加法，实际上与0+0 = 0, 1+1 = 0, 1+0 = 1, 0+1 = 1相同。奇偶性检验，如果我们把奇数看做1，偶数看做0，则有0+0 = 0, 1+1 = 0, 1 + 0 = 1, 0 + 1 = 1，和亦或操作一样。凡是有两个相反、相对的状态，都可以抽象为 0 和 1。另外对于奇偶性一般都会有简单的考察：奇数+奇数 = 偶数，以及奇数 - 1 = 偶数这两条基本性质。</p><p>​     状态压缩题目中一般应用按位与、或和亦或运算会将状态之间的转换变得容易很多。包括如果想取得某一位的状态，可以用 i &gt;&gt; j &amp; 1来计算。</p><h2 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h2><p>与运算的简单性质：</p><ol><li>按位与之后，当前位有一个0则以后一直是0。</li><li>基于上述运算，可以得知与运算有连续运算单调性质，每次与运算的结果不大于原先两个数。</li></ol><p>与运算的应用：</p><p><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">LC.201 数字范围按位与（中等）</a></p><pre><code class="lang-c++">//找到前缀，因为连续，所以后边一定都是0class Solution {public:    int rangeBitwiseAnd(int m, int n) {        int shift = 0;        while (m &lt; n)        {            m &gt;&gt;= 1;            n &gt;&gt;= 1;            ++ shift;        }        return m &lt;&lt; shift;    }};//Brian Kernighan 算法，就是除去最后一位1的算法，n &amp; (n - 1);//和lowbit操作可以对比来看class Solution {public:    int rangeBitwiseAnd(int m, int n) {        while (m &lt; n) n = n &amp; (n - 1);        return n;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      位运算
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>C++原理</title>
    <link href="/2020/08/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%8E%9F%E7%90%86/"/>
    <id>/2020/08/03/计算机基础知识/C++原理/</id>
    <published>2020-08-03T14:19:08.000Z</published>
    <updated>2020-08-14T05:42:58.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-原理"><a href="#C-原理" class="headerlink" title="C++原理"></a>C++原理</h1><h2 id="C-运算符的优先级和结合性"><a href="#C-运算符的优先级和结合性" class="headerlink" title="C++运算符的优先级和结合性"></a>C++运算符的优先级和结合性</h2><p><a href="https://www.cnblogs.com/shangdawei/p/3883702.html" target="_blank" rel="noopener">Blog. ImProgrammer</a></p><pre><code class="lang-c++">//一些典型应用场景，可以省去写括号if (i &gt;&gt; k &amp; 1);cnt = cnt * 2 % mod;cnt = (cnt + 2) % mod;int mid = l + r &gt;&gt; 1;//这里要注意，&amp;的优先级是低于 ==，==是7，&amp;是8，因此需要加括号才行while (j &amp;&amp; ((nums[j] &amp; 1) == 0)) j -- ;</code></pre><h2 id="static关键字的使用"><a href="#static关键字的使用" class="headerlink" title="static关键字的使用"></a>static关键字的使用</h2><ol><li>函数体内的static作用域是当前函数，表示该变量在下次这个函数调用时，不重新分配，还是上次执行之后的值。</li><li>在模块内（一个cpp文件之内）的static全局变量，可以被模块内的所有函数访问，但是模块外的其他函数无法访问。（<strong>全局静态变量</strong>）。全局和静态不同，全局变量在另一个cpp里可以使用extern来引入，而静态变量不允许被其他cpp引入。</li><li>在模块内的static函数只能被当前模块的其他函数调用，外部无法调用。函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。</li><li>类中的static成员变量属于整个类所有，对类的所有对象，调用都是同一个。</li><li>类中的static成员函数属于整个类所有，函数不接受this指针，因此只能访问static成员变量。</li></ol><p>总结：静态的变量和函数都是将变量或者函数限定在了当前cpp文件之中，局部则是多次调用复用。类的静态表示全类共有的东西。</p><h2 id="C-C-中指针和引用的区别"><a href="#C-C-中指针和引用的区别" class="headerlink" title="C/C++ 中指针和引用的区别"></a>C/C++ 中指针和引用的区别</h2><ol><li>指针有自己的一块空间，而引用只是一个别名；</li><li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li><li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；</li><li>作为参数传递时，指针需要被解引用(*操作)才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li><li>可以有const指针，但是没有const引用；</li><li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，<strong>不能被改变</strong>；</li><li>指针可以有多级指针（**p），而引用只有一级；</li><li>指针和引用使用++运算符的意义不一样，指针是指向下一个地址，引用代表所引用对象值+1；</li><li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li></ol><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而<strong>防止内存泄漏</strong>。</p><p>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。unique_ptr是多个指针不能同时指向一个对象，shared_ptr可以指向同一个。weak_ptr不会改变shared_ptr的引用计数。</p><ol><li>auto_ptr:C98标准中，所有的智能指针都只能用auto_ptr来实现，在C++11中已经被弃用。</li><li>unique_ptr:这种指针只能指向一个对象，不能多个指针同时指向一个对象，体现在只能转移而不能简单赋值，构造函数中也不能通过值来直接构造。而shared_ptr刚好是可以进行赋值，这样可以多个指针指向同一个对象。</li><li>shared_ptr:C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。</li><li>weak_ptr:当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。（因为引用计数不会为0）为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code class="lang-c++">//unique_ptr使用#include &lt;iostream&gt;#include &lt;memory&gt;struct Task {    int mId;    Task(int id ) :mId(id) {        std::cout &lt;&lt; &quot;Task::Constructor&quot; &lt;&lt; std::endl;    }    ~Task() {        std::cout &lt;&lt; &quot;Task::Destructor&quot; &lt;&lt; std::endl;    }};int main(){    // 创建一个空指针    std::unique_ptr&lt;int&gt; ptr1;    // 通过原始指针创建 unique_ptr 实例    // 构造unique_ptr时用指针作为构造参数    std::unique_ptr&lt;Task&gt; taskPtr(new Task(23));    //通过 unique_ptr 访问其成员    int id = taskPtr-&gt;mId;    std::cout &lt;&lt; id &lt;&lt; std::endl;    return 0;}//上述代码的输出//Task::Constructor//23//Task::Destructor//shared_ptr使用#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class A{public:    int i;    A(int n):i(n) { };    ~A() { cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;destructed&quot; &lt;&lt; endl; }};int main(){    shared_ptr&lt;A&gt; sp1(new A(2)); //A(2)由sp1托管，    shared_ptr&lt;A&gt; sp2(sp1);       //A(2)同时交由sp2托管    shared_ptr&lt;A&gt; sp3;    sp3 = sp2;   //A(2)同时交由sp3托管    cout &lt;&lt; sp1-&gt;i &lt;&lt; &quot;,&quot; &lt;&lt; sp2-&gt;i &lt;&lt;&quot;,&quot; &lt;&lt; sp3-&gt;i &lt;&lt; endl;    A * p = sp3.get();      // get返回托管的指针，p 指向 A(2)    cout &lt;&lt; p-&gt;i &lt;&lt; endl;  //输出 2    sp1.reset(new A(3));    // reset导致托管新的指针, 此时sp1托管A(3)    sp2.reset(new A(4));    // sp2托管A(4)    cout &lt;&lt; sp1-&gt;i &lt;&lt; endl; //输出 3    //这里体现了引用计数为0时执行delete，从而执行析构函数    sp3.reset(new A(5));    // sp3托管A(5),A(2)无人托管，被delete    cout &lt;&lt; &quot;end&quot; &lt;&lt; endl;    return 0;}//程序输出//2,2,2//2//3//2 destructed//end//5 destructed//4 destructed//3 destructed</code></pre><p><a href="https://blog.csdn.net/c_base_jin/article/details/79440999" target="_blank" rel="noopener">c++11 weak_ptr使用</a></p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在父类派生子类的时候，如果某一个方法<strong>父类希望子类在定义的时候重新实现</strong>，应该用<strong>virtual关键字</strong>将该方法定义为虚函数。如果子类重新实现了该方法，同样需要加上virtual关键字，或者在C++11标准中不使用virtual关键字，而在函数定义后边加上override关键字。使用虚函数可以使得程序有更好的<strong>扩展性</strong>，并且虚函数是实现多态的一种方法（另外重载也是，但是是静态实现）。</p><p>虚函数实现了<strong>动态绑定</strong>，在编译阶段无法确定当前调用对象使用的是哪个版本的虚函数，只有到运行阶段才能够得知。实现方法是使用<strong>虚函数表</strong>和<strong>虚函数表指针</strong>。其中在类中声明虚函数时，类会产生一个虚函数表，将所有虚函数的地址都放入其中，当需要的时候可以查表得到当前虚函数的地址，实现调用。而虚函数指针是每一个对象会隐式保存一个，如果父类的指针指向子类的时候，在调用虚函数时会首先查找虚函数指针，找到对应类的虚函数表，再调用对应类的虚函数，这样就可以确切知道是调用哪一个版本了。另外虚函数指针是一个确实的指针，因此在sizeof的时候，对象会多4字节（存放虚函数表地址）用来存放虚函数表指针。</p><p>内联函数、构造函数和静态成员函数无法声明为虚函数，其中内联函数是在编译时确定的，和动态绑定冲突；构造函数在调用的时候，父类和子类的概念还没有出现，因此不能声明为虚函数；静态成员函数只与类有关系，和对象绑定给谁无关，因此不行。</p><p>当多次继承时，虚函数每次都会被继承，如果不想继续让其子类继续继承当前的虚函数，可以使用final声明，之后再继承的类就无法继续重新实现该函数了。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><pre><code class="lang-c++">//C++ primer中的例子class Quote {public:    Quote() = default;    Quote(const std::string &amp;book, double sales_price):bookNo(book), price(sales_price){}    std::string isbn() const { return bookNo;}    virtual double net_price(std::size_t n) const { return n * price;}    virtual ~Quote() = default; //继承关系的根节点一般会声明一个虚的析构函数private:    std::string bookNo;protected:    double price = 0.0;};class Bulk_quote : public Quote {public:    Bulk_quote() = default;    Bulk_quote(const std::string&amp;, double, std::size_t, double);    //这里是虚函数的C++11规范继承    double net_price(std::size_t) const override;    //这样写也可以    //virtual net_price(std::size_t) const;private:    std::size_t min_qty = 0;    double discount = 0.0;};</code></pre><p><a href="https://www.cnblogs.com/forcheryl/p/4705848.html" target="_blank" rel="noopener">Blog.Ryan C++虚函数原理</a></p><p><a href="https://www.cnblogs.com/zkfopen/p/11061414.html" target="_blank" rel="noopener">Blog.zkfopen C++虚函数的作用和多态</a></p><h2 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h2><ol><li>new从<strong>自由存储区</strong>上为对象动态分配内存空间，而malloc从<strong>堆</strong>上分配。自由存储区是个更高一层抽象的概念，是一块计算机中的内部存储空间，有可能是堆，也可能是静态存储区，需要具体看operator new的具体实现。new甚至可以不分配空间，比如传入指针参数的new实现。事实上，new的实现可以基于malloc。</li><li>new分配成功时，返回对象类型的指针，不用转换类型。malloc只是给了一块内存，类型是void*，大小是传入的参数，需要强制转换一下。</li><li>new分类失败时，抛出bac_alloc异常，而malloc失败时，返回NULL。</li><li>new运行时，先分配内存，之后调用构造函数，最后返回一个该对象指针。delete时先调用析构函数，之后再释放内存。而malloc更加底层，没有这样规范的全部操作。</li><li>new和delete是运算符，可以进行重载。malloc和free不允许被重载。</li><li>new支持数组类型的分配，比如如下代码段：</li></ol><pre><code class="lang-c++">//newA *ptr = new A[10]; //分配10个A对象delete [] ptr;//mallocint *ptr = (int *) malloc(sizeof(int) * 10);</code></pre><p><a href="https://www.cnblogs.com/shilinnpu/p/8945637.html" target="_blank" rel="noopener">Blog.林嵩 new与malloc有什么区别</a></p><h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><p>当使用类创建对象时，如果我们也希望可以用一个已有的类对象初始化一个新的类对象，就如同简单类型直接赋值一样，这时就会调用复制构造函数。如果没有显式定义复制构造函数，编译器会自动隐式定义一个<strong>缺省的复制构造函数</strong>，一个inline+public的成员函数，形式是类名::类名（const 类名&amp;）。</p><pre><code class="lang-c++">//基础类型的直接赋值初始化double x = 5.0;double y = x;//类对象的复制构造函数point pt1(2, 3);point pt2 = pt1;point pt2(pt1);</code></pre><p>复制构造函数的三个被使用场景：</p><ol><li>当把一个已经存在的对象赋值给另一个新的对象时；</li><li>实参和形参都是对象，进行形参和实参的结合时；</li><li>当函数返回值是对象，函数调用完成返回时；</li></ol><p>另外对于复制构造函数，要注意深拷贝和浅拷贝的关系。当一个类中有指针时，如果仅仅使用默认的复制构造函数，会导致新创建的对象中的指针也指向对应内存。这样会导致两次析构函数调用，如果有delete语句，则会delete两次，引发错误。正确做法应该显式定义复制拷贝函数，这样可以在拷贝函数内部重新分配内存，并且重新赋值指针。</p><p><a href="https://www.cnblogs.com/cthon/p/9147526.html" target="_blank" rel="noopener">Blog.C++拷贝构造 函数详解</a></p><h2 id="C-11新特性：右值引用"><a href="#C-11新特性：右值引用" class="headerlink" title="C++11新特性：右值引用"></a>C++11新特性：右值引用</h2><h3 id="什么是左值和右值？"><a href="#什么是左值和右值？" class="headerlink" title="什么是左值和右值？"></a>什么是左值和右值？</h3><p>左值和右值原本是C语言用来区别“=”左右两边操作数的一个说法，但是在C++中引入了const关键字，从而某些位于等号左侧的量也无法被赋值，因此左值和右值被重新定义，左值代表能在系统中<strong>占据某一块内存空间</strong>，<strong>有地址</strong>的变量和数值；右值代表在计算过程中的<strong>临时量</strong>，无法得到对应内存地址。其中对于持久的左值来说，C语言中就已经定义对于其的引用使用方法，相当于别名，即<strong>左值引用</strong>。但是对于右值，因为没有地址，无法持久保持当前值，所以没有右值引用的概念。</p><p><a href="https://blog.csdn.net/xuwqiang1994/article/details/79924310" target="_blank" rel="noopener">Blog.CSDN 理解C和C++中的左值和右值</a></p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>C++11的新标准中，引入了<strong>右值引用</strong>这一强大的特性，主要为了解决类对象的复制与移动的关系。C++11中使用语法&amp;&amp;来定义右值引用，可以对右值进行引用操作，具体实现不明。右值引用的其中一个意义是，可以实现“<strong>移动语义</strong>”，通过向移动赋值运算符重载的参数中直接传入右值引用，可以避免一次无意义的对象构造和析构过程。</p>]]></content>
    
    <summary type="html">
    
      C++原理
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>博弈论</title>
    <link href="/2020/07/23/%E7%AE%97%E6%B3%95/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <id>/2020/07/23/算法/博弈论/</id>
    <published>2020-07-23T12:50:01.000Z</published>
    <updated>2020-08-16T05:34:42.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="公平组合游戏"><a href="#公平组合游戏" class="headerlink" title="公平组合游戏"></a>公平组合游戏</h3><p>公平组合游戏，又称ICG，需要满足：</p><ol><li>由两名玩家交替行动；</li><li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</li><li>不能行动的玩家判负；</li></ol><p>NIM博弈属于公平组合游戏，但是城建类的棋类游戏，比如围棋，就不是ICG。</p><h3 id="NIM游戏"><a href="#NIM游戏" class="headerlink" title="NIM游戏"></a>NIM游戏</h3><p>给定N堆物品，第i堆物品有A[i]个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。<br>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。<br>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。<br>NIM博弈<strong>不存在平局</strong>，只有先手必胜和先手必败两种情况。</p><p>定理： NIM博弈先手必胜，当且仅当:</p><script type="math/tex; mode=display">A[1] \^ A[2] \^ ... \^ A[n] != 0</script><h3 id="有向图游戏"><a href="#有向图游戏" class="headerlink" title="有向图游戏"></a>有向图游戏</h3><p>给定一个<strong>有向无环图</strong>，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。<br>    任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p><h3 id="Mex运算"><a href="#Mex运算" class="headerlink" title="Mex运算"></a>Mex运算</h3><p>​    设S表示一个非负整数集合。定义mex(S)为求出<strong>不属于集合S的最小非负整数的运算</strong>，即：<br>​        mex(S) = min{x}, x属于自然数（0 ~ +∞），且x不属于S。</p><h3 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h3><p>​    在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：<br>​        </p><script type="math/tex; mode=display">SG(x) = mex({SG(y_1), SG(y_2), ..., SG(y_k)})</script><p>​    特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。</p><h3 id="有向图游戏的和"><a href="#有向图游戏的和" class="headerlink" title="有向图游戏的和"></a>有向图游戏的和</h3><p>​    设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。<br>​    有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：</p><script type="math/tex; mode=display">SG(G) = SG(G_1) \^ SG(G_2) \^ ... \^ SG(G_m)</script><p>定理<br>    有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。<br>    有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><pre><code class="lang-c++">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_set&gt;using namespace std;const int N = 110, M = 10010;int s[N], f[M];int n, m;//SG函数，一般使用记忆化搜索的方法来实现int sg(int x){    if (f[x] != -1) return f[x];    unordered_set&lt;int&gt; S;    for (int i = 0; i &lt; n; i ++ )         if (x &gt;= s[i])            S.insert(sg(x - s[i]));    for (int i = 0; ; i ++ )        if (!S.count(i))            return f[x] = i;}int main(){    memset(f, -1, sizeof f);    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; s[i];    cin &gt;&gt; m;    int res = 0;    for (int i = 0; i &lt; m; i ++ )    {        int x;        cin &gt;&gt; x;        res ^= sg(x);    }    if (res) puts(&quot;Yes&quot;);    else puts(&quot;No&quot;);    return 0;}</code></pre><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.acwing.com/problem/content/895/" target="_blank" rel="noopener">AW.893 集合-Nim游戏（简单）</a></p><p><a href="https://www.acwing.com/problem/content/896/" target="_blank" rel="noopener">AW.894 拆分-Nim游戏（简单）</a></p>]]></content>
    
    <summary type="html">
    
      博弈论
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="/2020/07/20/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    <id>/2020/07/20/算法/链表/</id>
    <published>2020-07-20T04:18:08.000Z</published>
    <updated>2020-08-16T05:34:01.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表的构建"><a href="#链表的构建" class="headerlink" title="链表的构建"></a>链表的构建</h2><p>链表主要有两种实现方式，第一种是Leetcode上的实现方式，使用new创建新节点，速度慢，使用指针操作。第二种是数组模拟链表，速度较快，但是面试中一般不会使用这种。</p><h2 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h2><p>链表的基本操作有：在头结点之前插入节点、在头结点之后的某个节点之前插入数据、删除某个节点。</p><pre><code class="lang-c++">//Leetcode的节点定义struct ListNode{    int val;    ListNode *next;    ListNode(int x) : val(x), next(NULL) {}};//删除某个节点class Solution {public:    ListNode* deleteNode(ListNode* head, int val) {        //使用有哑节点处理删除头结点的情况        ListNode *h = new ListNode(-1);        h -&gt; next = head;        ListNode *pre = h, *p = pre -&gt; next;        //使用pre节点可以减少一次遍历，直接将两个指针到应有的位置        while (p &amp;&amp; p -&gt; val != val) p = p -&gt; next, pre = pre -&gt; next;        //判断一下边界情况，如果没有要查找的值就返回        if (p == nullptr) return head;        //核心语句，将pre的下一个指向p的下一个，相当于跳过了p        pre -&gt; next = p -&gt; next;        return h -&gt; next;    }};//在链表头插入节点ListNode * add(ListNode *head, int x){    ListNode *t = new ListNode(x);    t -&gt; next = head;    return t;}//在链表中按照大小顺序插入节点ListNode * addPos(ListNode* head, int x){    //哑节点    ListNode *h = new ListNode(-1);    h -&gt; next = head;    ListNode *p = h;    //遍历到某个节点的下一个如果值还是大于当前节点，并且不为空就继续    while (p -&gt; next &amp;&amp; p -&gt; next -&gt; val &lt; x) p = p -&gt; next;    //新建一个节点，赋值    ListNode *t = new ListNode(x);    //核心语句，将p的后边插入当前新节点t，以为有哑结点，所以相当于在head之前插入也是可以的    t -&gt; next = p -&gt; next;    p -&gt; next = t;    return h -&gt; next;}//Acwing中使用数组模拟链表的模板const int N = 100010;//单链表定义，h = -1int e[N], ne[N], idx;int h = -1;//双向链表定义int e[N], r[N], l[N], idx;int head = 0, tail = 1;//单链表添加元素到链表头void add_to_head(int x){    e[idx] = x, ne[idx] = h, h = idx ++ ;}//单链表删除插入时的第k + 1个元素,需要特殊判断头节点删除的情况void remove(int k){    ne[k] = ne[ne[k]];}//双向链表初始化void init(){    r[0] = 1, l[1] = 0;    idx = 2;}//双向链表添加元素第k个元素右边void insert(int k, x){    e[idx] = x;    //将idx元素左边就是第k个，右边元素是k原来右边的元素    l[idx] = k, r[idx] = r[k];    //右边元素是r[k],其向左的指针l[r[k]]是现在的idx    //k现在右边的是idx    l[r[k]] = idx, r[k] = idx ++ ;}//删除输入的第k个数void remove(int k){    l[r[k]] = l[k];    r[l[k]] = r[k];}</code></pre><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank" rel="noopener">LC.147 对链表进行插入排序（中等）</a></p><pre><code class="lang-c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; *///不带哑结点的原地插入class Solution {public:    ListNode* insertionSortList(ListNode* head) {        if (!head || !head -&gt; next) return head;        ListNode* p = head -&gt; next;        while (p)        {            ListNode* t = p;            p = p -&gt; next;            ListNode* pre = head;            while (pre -&gt; next != t) pre = pre -&gt; next;            pre -&gt; next = t -&gt; next;            //要判断一下是否要插入到头节点之前            if (t -&gt; val &lt;= head -&gt; val)            {                t -&gt; next = head;                head = t;            }            //如果需要插入到头结点之后，判断当前节点的下一个值是否还是小于当前插入节点值，如果小于则还需要再向前走一个位置            else            {                ListNode* s = head;                while (s -&gt; next != p &amp;&amp; s -&gt; next -&gt; val &lt; t -&gt; val) s = s -&gt; next;                t -&gt; next = s -&gt; next;                s -&gt; next = t;            }        }        return head;    }};//带哑结点的插入，省去的判断是否是链表头的操作class Solution {public:    ListNode* insertionSortList(ListNode* head) {        if (!head || !head -&gt; next) return head;        ListNode *h = new ListNode(-1);        ListNode *p = head -&gt; next;        h -&gt; next = head;        head = h;        //因为有哑结点存在，所以不需要判断头结点        while (p)        {            ListNode *t = p;            p = p -&gt; next;            ListNode *pre = head;            while (pre -&gt; next != t) pre = pre -&gt; next;            pre -&gt; next = t -&gt; next;            ListNode *s = head;            while (s -&gt; next != p &amp;&amp; s -&gt; next -&gt; val &lt; t -&gt; val) s = s -&gt; next;            t -&gt; next = s -&gt; next;            s -&gt; next = t;        }        return head -&gt; next;    }};//直接新建链表，挨个插入，省去删除操作class Solution {public:    ListNode* insertionSortList(ListNode* head) {        if (!head || !head -&gt; next) return head;        ListNode *h = new ListNode(-1);        ListNode *p = head;        while (p)        {            ListNode *t = p;            p = p -&gt; next;            ListNode *s = h;            while (s -&gt; next &amp;&amp; s -&gt; next -&gt; val &lt; t -&gt; val) s = s -&gt; next;            t -&gt; next = s -&gt; next;            s -&gt; next = t;        }        return h -&gt; next;    }};</code></pre><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">LC.剑指offer24.反转链表（简单）</a></p><p>反转链表要熟悉递归和迭代两种方式，递归写起来很优美，但是有些复杂，迭代需要更多的指针。</p><pre><code class="lang-c++">//递归方式，简洁但是得稍微思考一下边界条件和每一步所做的修改顺序class Solution {public:    ListNode* reverseList(ListNode* head) {        if (!head || !head -&gt; next) return head;        ListNode *h = reverseList(head -&gt; next);        head -&gt; next -&gt; next = head;        head -&gt; next = nullptr;        return h;    }};//迭代方式（哑节点），最简单无脑的方式，新建一个链表，每次头插class Solution {public:    ListNode* reverseList(ListNode* head) {        if (!head || !head -&gt; next) return head;        ListNode *h = new ListNode(-1);        while (head)        {            ListNode *t = head;            head = head -&gt; next;            t -&gt; next = h -&gt; next;            h -&gt; next = t;        }        return h -&gt; next;    }};//迭代方式（原地修改），效率比较低，每次使用三个指针，认为第一个指针pre最开始指向nullptrclass Solution {public:    ListNode* reverseList(ListNode* head) {        if (!head || !head -&gt; next) return head;        ListNode * pre = nullptr, *cur = head;        while (cur)        {            ListNode * nxt = cur -&gt; next;            cur -&gt; next = pre;            pre = cur;            cur = nxt;        }        return pre;    }};</code></pre><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">LC.相交链表（简单）</a></p><pre><code class="lang-c++">//基础方法，将长的加到短的长度，再去判断class Solution {public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {        if (!headA || !headB) return nullptr;        int lena = 0, lenb = 0;        ListNode *p = headA, *q = headB;        while (p) p = p -&gt; next, lena ++ ;        while (q) q = q -&gt; next, lenb ++ ;        while (lena &gt; lenb) headA = headA -&gt; next, lena --;        while (lena &lt; lenb) headB = headB -&gt; next, lenb --;        while (headA &amp;&amp; headA != headB) headA = headA -&gt; next, headB = headB -&gt; next;        return headA;    }};//双指针算法，要将空指针看做两个链表一定相交的地方，并且空指针是真实能走到可停留的位置class Solution {public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {        if (!headA || !headB) return nullptr;        ListNode *a = headA, *b = headB;        while (a != b)        {            if (!a) a = headB;            else a = a -&gt; next;            if (!b) b = headA;            else b = b -&gt; next;        }        return a;    }};</code></pre><p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">LC.876 链表的中间节点（简单）</a></p><pre><code class="lang-c++">//快慢指针经典应用class Solution {public:    ListNode* middleNode(ListNode* head) {        ListNode *fast = head, *slow = head;        while (fast &amp;&amp; fast -&gt; next)        {            slow = slow -&gt; next;            fast = fast -&gt; next -&gt; next;        }        return slow;    }};</code></pre><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">LC.回文链表（简单）</a></p><pre><code class="lang-c++">class Solution {public:    bool isPalindrome(ListNode* head) {        ListNode *fast = head, *slow = head;        //快慢指针寻找链表中点        while (fast &amp;&amp; fast -&gt; next)        {            slow = slow -&gt; next;            fast = fast -&gt; next;            if (fast) fast = fast -&gt; next;        }        ListNode *r = reverse(slow);        //从两端开始依次比较，如果有一个方向的指针空了，表示两指针已经相遇        ListNode *l = head;        while (l &amp;&amp; r)        {            if (l -&gt; val != r -&gt; val) return false;            l = l -&gt; next, r = r -&gt; next;        }        return true;    }    //反转链表    ListNode *reverse(ListNode *head)    {        if (!head || !head -&gt; next) return head;        ListNode *h = reverse(head -&gt; next);        head -&gt; next -&gt; next = head;        head -&gt; next = nullptr;        return h;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      链表
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>sprintf和sscanf</title>
    <link href="/2020/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/sprintf%E5%92%8Csscanf/"/>
    <id>/2020/07/20/计算机基础知识/sprintf和sscanf/</id>
    <published>2020-07-20T04:18:08.000Z</published>
    <updated>2020-08-16T05:30:57.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sprintf和sscanf"><a href="#sprintf和sscanf" class="headerlink" title="sprintf和sscanf"></a>sprintf和sscanf</h1><h2 id="sprintf和sscanf-1"><a href="#sprintf和sscanf-1" class="headerlink" title="sprintf和sscanf"></a>sprintf和sscanf</h2><p>函数原型：</p><pre><code class="lang-c++">int sprintf(char *str, const char *format, ...);int sscanf(const char *str, const char *format, ...);//成功返回成功匹配的和赋值的个数，如果达到文件末尾或发生错误，返回EOF</code></pre><ul><li>str：指向字符数组的指针，该数组存储了C字符串</li><li>format：是一个字符串，format标签是<code>%[flags][width][.precision][length]specifier</code>形式</li></ul><h2 id="format字段"><a href="#format字段" class="headerlink" title="format字段"></a>format字段</h2><p>specifier举例子来说：</p><ul><li>%e是使用e字符的科学计数法。</li><li>%E是使用E字符的科学计数法。</li><li>%o是有符号八进制。</li><li>%u是无符号十进制。</li><li>%x是无符号十六进制。</li><li>%X是无符号十六进制大写字母。</li><li>%p是指针地址。</li><li>%n是无输出。</li><li>%%是%字符（转义）。</li></ul><p>flags举例子来说</p><ul><li>-是在给定的字段宽度内左对齐，默认是右对齐</li><li>+是强制在结果之前显示加号或减号，默认只有负数有负号</li><li>0是指定填充padding的数字左边放置0，而不是空格</li></ul><p>width举例子来说</p><ul><li>某个数：比如2，表示要输出的最小数目，如果输出更短，用空格补位，如果更长不会被截断</li><li>*：宽度未指定。</li></ul><h2 id="附加参数"><a href="#附加参数" class="headerlink" title="附加参数"></a>附加参数</h2><p><strong>附加参数</strong> 表示这个函数接受一系列的指针作为附加参数，每一个指针都指向一个对象，对象类型由 format 字符串中相应的 % 标签指定，参数与 % 标签的顺序相同。</p><p><a href="https://www.cnblogs.com/edver/p/8419807.html" target="_blank" rel="noopener">Blog.Edver.C语言中可变参数的用法</a></p><h2 id="使用中的例子"><a href="#使用中的例子" class="headerlink" title="使用中的例子"></a>使用中的例子</h2><pre><code class="lang-c++">#include &lt;stdio.h&gt;int main(){    char in[] = &quot;hello 123 -4.50 0x3f3f3f 011&quot;;    char out[50];    char arg1[6];    int arg2;    float arg3;    int arg4;    int arg5;    //%*s表示跳过了第一个参数    sscanf(in, &quot;%*s %d %f %x %o&quot;, &amp;arg2, &amp;arg3, &amp;arg4, &amp;arg5);    sscanf(in, &quot;%s %d %f %x %o&quot;, arg1, &amp;arg2, &amp;arg3, &amp;arg4, &amp;arg5);    //%05d表示不足5位补0，%+d表示正数有+号不省略    sprintf(out, &quot;%s,%05d,%+f,%+d,%o\n&quot;, arg1, arg2, arg3, arg4, arg5);    printf(&quot;%s&quot;, out);    sprintf(out, &quot;%p,%-5d,%f,%+x,%o\n&quot;, arg1, arg2, arg3, arg4, arg5);    printf(&quot;%s&quot;, out);    return 0;}//输出的结果//hello,00123,-4.500000,+4144959,11//0x7fff14a2366a,123  ,-4.500000,3f3f3f,11</code></pre>]]></content>
    
    <summary type="html">
    
      sprintf sscanf
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="/2020/07/17/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>/2020/07/17/算法/线段树/</id>
    <published>2020-07-17T07:20:12.000Z</published>
    <updated>2020-07-19T14:57:47.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="线段树-1"><a href="#线段树-1" class="headerlink" title="线段树"></a>线段树</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>将一个区间和其所有不重叠的子区间分别存储到数组中，形成一个满二叉树，并且在线段树中每一个节点维护当前区间的值。</p><p>当某一个节点进行修改之后，需要修改当前节点和所有父节点。</p><p>当修改的是一个区间的值时，需要维护懒标记。懒标记代表<strong>当前节点的所有子节点</strong>应该加上的值，每次pushdown操作是将当前节点的懒标记推送到了子节点，并且将上次的操作真正的实际写到节点中。比如modify操作，pushdown之后所有子节点的值已经落实了修改，递归之后值完全正确，这时也要pushup更新父节点的值。总结上讲，当build和modify操作结束时，需要用pushup来更新当前节点值。当modify和query开始时，必须保证当前节点的值已经正确，因此需要用pushdown操作。</p><p>当查询某一个区间内的值时，只需要将包含在该区间内的所有最大区间的值进行计算即可得出，这一点和树状数组思想一致。</p><p>因此线段树可以进行<strong>单点和区间修改</strong>，<strong>区间查询</strong>。修改和查询的时间复杂度为O(logn)。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//需要开4倍空间，最多有4n - 1个节点存在。struct Node{    int l, r;    int v;}tr[N * 4];//pushup操作，用子节点的信息计算父节点void pushup(int u){    tr[u].v = max(tr[u &lt;&lt; 1].v, tr[u &lt;&lt; 1 | 1].v);}//可以对pushup再加一层封装，这样可以计算任意Nodevoid pushup(int u) {pushup(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);}void pushup(Node&amp; u, Node&amp; l, Node&amp; r){    u.sum = l.sum + r.sum;    u.lsum = max(l.lsum, l.sum + r.lsum);    u.rsum = max(r.rsum, r.sum + l.rsum);    u.tsum = max({l.rsum + r.lsum, l.tsum, r.tsum});}//build操作，建立线段树，确定每个节点维护的区间void build(int u, int l, int r){    tr[u] = {l, r};    if (l == r) return;    int mid = l + r &gt;&gt; 1;    build(u &lt;&lt; 1, l, mid);    build(u &lt;&lt; 1 | 1, mid + 1, r);}//单点修改操作，修改某一个叶子节点的值void modify(int u, int x, int v){    if (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u].v = v;       else    {        int mid = tr[u].l + tr[u].r &gt;&gt; 1;        if (x &lt;= mid) modify(u &lt;&lt; 1, x, v);        else modify(u &lt;&lt; 1 | 1, x, v);        //修改完子节点之后，要更新父节点的值        pushup(u);    }}//查找操作，查找某个区间内的最大值int query(int u, int l, int r){    //如果当前树节点被查询区间包含了，不用再递归了    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].v;    int ret = 0;    //否则找到树节点区间中点（因为要继续向下看看哪个区间能完全被包含）    int mid = tr[u].l + tr[u].r &gt;&gt; 1;    //如果l在mid左边，则说明向下一层的节点中有部分在当前查找区间中，递归    if (l &lt;= mid) ret = query(u &lt;&lt; 1, l, r);    //如果r在mid右边，也是需要再向下查找    if (r &gt; mid) ret = max(ret, query(u &lt;&lt; 1 | 1, l, r));    return ret;}//懒标记的pushdown操作void pushdown(int u){    auto &amp;root = tr[u], &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1];    if (root.add)    {        left.add += root.add, left.sum += (left.r - left.l + 1) * root.add;        right.add += root.add, right.sum += (right.r - right.l + 1) * root.add;        root.add = 0;    }}//使用懒标记修改区间的值void modify(int u, int l, int r, int d){    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)    {        tr[u].sum += (tr[u].r - tr[u].l + 1) * d;        tr[u].add += d;    }    else    {        //开始之前保证当前u节点如果带有懒标记，一定计算完毕子节点，且将懒标记传递给子节点        pushdown(u);        int mid = tr[u].l + tr[u].r &gt;&gt; 1;        if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, d);        if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r d);        //最后结束的时候要更新当前节点值        pushup(u);    }}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/description/1277/" target="_blank" rel="noopener">AW.1275 最大数（中等）</a></p><p><a href="https://www.acwing.com/problem/content/246/" target="_blank" rel="noopener">AW.245 你能回答这些问题吗（简单）</a></p><p><a href="https://www.acwing.com/problem/content/244/" target="_blank" rel="noopener">AW.243 一个简单的整数问题2（困难）</a></p><p><a href="https://leetcode-cn.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/" target="_blank" rel="noopener">LC.5467 找到最接近目标值的函数值（困难）</a></p><p>线段树 + 双指针，这里主要关注线段树</p>]]></content>
    
    <summary type="html">
    
      线段树
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="/2020/07/16/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>/2020/07/16/算法/二分查找/</id>
    <published>2020-07-16T13:41:30.000Z</published>
    <updated>2020-07-30T03:55:54.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="二分查找元素"><a href="#二分查找元素" class="headerlink" title="二分查找元素"></a>二分查找元素</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;二分使用的条件是有<strong>单调性</strong>，比如有序的序列，事实上二分是<strong>分治算法</strong>思想。本质是将问题抽象化为<strong>找一个分界面</strong>，分界面左边不满足某一性质，而右边满足某一个性质。这时候左边边界缩减时需要多缩减一个，因为左边不满足性质；右边边界缩减到当前mid，不用多缩减。下边代码的check函数即是满足某种性质的判断函数，当满足性质时返回 true, 不满足时返回false。</p><p>&emsp;&emsp;当搜素结束时，左右边界重合，即<code>l == r</code>。如果有<code>l = mid</code>的情况，需要<code>l + r + 1 &gt;&gt; 1</code>才能够避免最后两个数相邻时，mid永远更新为左边界的死循环。</p><p>&emsp;&emsp;二分查找分为整数二分和浮点数二分，浮点数查找时原理相同，但是要求精度小于一定数时停止。浮点数二分比整数二分容易很多，不需要考虑很多边界条件的情况。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//每次右边界缩减为mid的情况while (l &lt; r){    int mid = l + r &gt;&gt; 1;    if (check(mid)) r = mid;    else l = mid + 1;}//每次左边界缩减为mid的情况while (l &lt; r){    int mid = l + r + 1 &gt;&gt; 1;    if (check(mid)) l = mid;    else r = mid + 1;}//例子：求一个有序序列中的左右边界//1 【2 2 2】 3 3 //   ↑    ↑//   ①    ②while (l &lt; r){    int mid = l + r &gt;&gt; 1;    if (a[mid] &gt;= x) r = mid;    else l = mid + 1;}while (l &lt; r){    int mid = l + r + 1 &gt;&gt; 1;    if (a[mid] &lt;= x) l = mid;    else r = mid - 1;}//浮点数二分const double eps = 1e-8;while (r - l &gt; eps){    int mid = l + r / 2.0;    if (check(mid)) l = mid;    else r = mid;}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">LC.704 二分查找（简单）</a></p><p><a href="https://www.acwing.com/problem/content/792/" target="_blank" rel="noopener">AW.790 数的三次方根（简单）</a></p><p><a href="https://www.acwing.com/problem/content/791/" target="_blank" rel="noopener">AW.789 数的范围（简单）</a></p><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">LC.209 长度最小的子数组（中等）</a></p><p>构造单调性+二分查找，重点在于单调性的构造</p><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">LC.剑指offer11.旋转数组的最小数字（简单）</a></p><p>有趣的二分，如何解决有重复数字无法确定左右边界收缩的情况</p><h2 id="二分搜索答案"><a href="#二分搜索答案" class="headerlink" title="二分搜索答案"></a>二分搜索答案</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;答案很多时候是<strong>有范围的</strong>，当某一个问题<strong>验证某一个答案</strong>的时间复杂度乘以二分区间范围的log时，可以考虑搜索答案。通过不断的尝试排除错误答案，且是以指数速度排除，最终得到正确答案。这里一般在验证答案的时候，可以采用某种程度的贪心策略，并且将原问题中单调性质进行转化，能够通过一次的验证缩小答案范围。</p><p>&emsp;&emsp;这类题往往不是简单的搜索答案，而是将问题某种程度的转化之后，再搜索答案。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LC.287 寻找重复数（中等）</a></p><p>这道题是二分搜索答案比较经典和简单的例证</p><p><a href="https://www.acwing.com/problem/content/104/" target="_blank" rel="noopener">AW.102 最佳牛围栏（简单）</a></p><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank" rel="noopener">LC.5438 制作m束花所需最少天数（中等）(193周赛第三题）</a></p><p><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">LC.1300 转变数组后最接近目标值的数组和（中等）</a></p><p><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">LC.410 分割数组的最大值（困难）</a></p>]]></content>
    
    <summary type="html">
    
      二分查找模板和常见套路
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>单调栈与单调队列</title>
    <link href="/2020/07/15/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <id>/2020/07/15/算法/单调栈与单调队列/</id>
    <published>2020-07-15T14:58:03.000Z</published>
    <updated>2020-07-15T09:57:08.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调栈与单调队列"><a href="#单调栈与单调队列" class="headerlink" title="单调栈与单调队列"></a>单调栈与单调队列</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;单调栈使用范围比较小，已知有两种用法，其中第一种用法比较经典，用的较多，第二种用法出现较少。</p><ol><li><p><strong>寻找数组中某一个数左边、右边第一个比它大或小的数</strong>。首先要找到最近的一个数，并且满足这个数和当前数的单调关系（比它大或者小）。栈的特点是后进先出，在这里其实利用了栈“<strong>最近</strong>”的思想，而单调性能够确保与栈顶比较时，相当于比较了所有之前的数据，降低了时间复杂度。</p><p>&emsp;&emsp;Condition 1 ：以寻找数列中每一个数左边第一个比它小的数为例，如果使用单调递增栈，<strong>当前元素大于栈顶元素</strong>，则相当于大于栈中所有元素，当前元素左侧第一个比它小的数就是栈顶元素；</p><p>&emsp;&emsp;Condition 2 ：如果<strong>当前元素小于栈顶元素</strong>，那么当前元素<strong>左侧比当前元素还大的</strong>那些元素（即已经在栈中）就永远不需要考虑了（我要找的是更小的！），并且可以在这个过程中直接出栈。原因是，这些出栈的元素在更靠后的元素考虑时，肯定不会是答案，因为使得这个元素出栈的元素，会距离更近且更小，具体看下图会更加清晰。可以看到，4号元素在找左侧更小的元素时，一定不会找到2号元素，因为3号元素一定更早被选择。</p><p><img src="https://i.loli.net/2020/06/10/nPoi2mMvOVHt1uy.jpg" alt></p></li><li><p><strong>寻找数组中两个数之间满足i &lt; j 且 A[i] &lt;= A[j]的情况下，下标之间的最大距离</strong>。这种可以看做<strong>全局的单调性和“最近”性质</strong>的应用，并且还有<strong>双指针</strong>的思想。这里有个重点是，当从右向左考虑元素时，只需要考虑当前元素左侧是否会产生最大值，不用考虑右侧的情况，因为右侧已经考虑过了。首先从左向右初始化单调递减栈，之后从右向左每次元素和栈顶元素比较，通过出栈每次确认当前最小的元素是否更新了答案，直到栈顶元素大于当前遍历元素：</p><p>&emsp;&emsp;Condition 1 ：如果当前元素小于栈顶（当前最小值），则栈内其他元素均不满足A[i] &lt;= A[j]的要求，更进一步说明栈顶元素左侧所有元素均无法产生答案；栈顶右侧元素一定已经和当前元素右侧的元素更新过答案（因此才被弹出栈），所以再和当前元素产生的答案，肯定无法更新答案（从右向左，每次都在递减）。</p><p>&emsp;&emsp;Condition 2 ：如果当前元素大于栈顶，由于栈顶元素右边的元素更靠近序列右侧，所以最大距离一定更小，即便和当前元素能产生正确大小关系，也不会更新答案。之后我们无法确定左侧元素是否还能继续产生更大答案，所以栈顶元素出栈，继续比较。能够安全出栈的原因是，右侧当前元素每次都在减少，因此贪心的认为，之后即便有满足要求的元素，也不会更新最大距离（与第一种情况的栈顶右侧元素一致）。</p></li></ol><p>&emsp;&emsp;假设序列是 <strong><u>A</u> <u>B</u> C <u>D</u> E F G H</strong>，从左到右入递减栈的是A B D，那么假设当前元素为G：</p><ol><li>如果G &gt;= D，D出栈，考虑B，如果G &gt;= B, 即使G &gt;= C没有产生更大答案，如果G &lt; B，因为从左到右是单调栈，因此C &gt; B, 若G &gt; C，可以推导出C &lt; G &lt; B, B &gt; C，冲突，所以不用考虑G &gt; C的情况。</li><li>如果G &lt; D,  比最小值还小，那么栈顶元素左侧没有可以满足条件的情况；而右侧E F即便有更小，也无法更新答案。</li></ol><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//寻找数组中某一个数左边第一个比他大的数for (int i = 0; i &lt; n; i ++ ){    while (!st.size() &amp;&amp; s[i] &gt;= st.top()) st.pop();    if (st.size()) cout &lt;&lt; st.top() &lt;&lt; &quot; &quot;;    else cout &lt;&lt; &quot;-1 &quot;;    st.push(s[i]);}//寻找i &lt; j 且 A[i] &lt; A[j]条件的最大j - istack&lt;int&gt; st;int n = A.size();for (int i = 0; i &lt; n; i ++ )    if (st.empty() || A[i] &lt; A[st.top()])        st.push(i);int ans = 0;for (int i = n - 1; i &gt;= 0; i -- ){    while (st.size() &amp;&amp; A[i] &gt;= A[st.top()])    {        ans = max(ans, i - st.top());        st.pop();    }    if (!st.size()) break;}return ans;</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/832/" target="_blank" rel="noopener">AW.830 单调栈（简单）</a></p><p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">LC.739 每日问题（中等）</a></p><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">LC.42 接雨水（困难）</a></p><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">LC.84 柱状图中最大的矩形（困难）</a></p><p><a href="https://leetcode-cn.com/problems/maximum-width-ramp/" target="_blank" rel="noopener">LC.962 最大宽度坡（中等）</a></p><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;单调队列是队头维护的是整个队列中最大或者最小的元素，每次有新元素入队时，如果不满足当前队列维护的单调性，则将所有不满足的元素全部出队。单调队列本质是一个<strong>双端队列</strong>，每次出队时是从队尾出队，而不是从队头出队。<strong>单调队列可以解决滑动窗口的最值问题</strong>，以及与之相关的优化。</p><p>&emsp;&emsp;单调队列操作顺序也比较重要，在不同需要的时候有不同的操作顺序。</p><ol><li>计算是否当前元素和队头元素距离之差大于规定值，如果大于则队头出队。</li><li>计算答案，此时是计算的[0, r - 1]范围内的最值，因此放在第二步。</li><li>保持队列单调性，while循环从队尾出队。</li><li>将当前元素入队。</li><li>*若计算答案在这里，则是求的[0, r]范围内的最值。</li></ol><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//k是窗口大小, 计算最大值, 手动模拟队列int q[N];int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ ){    //如果下标是不连续的，这里要写while，因为这里每次最多下标+1所以可以写if    if (hh &lt;= tt &amp;&amp; i - q[hh] + 1 &gt; k) hh ++ ;    //这里大于等于和大于都能过，但是推荐写大于等于，当相等的时候，每次只保留最新的一个即可    while (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) tt -- ;    q[ ++ tt ] = i;    //这里事实上求的[0, i]范围的最值    if (i &gt;= k - 1) cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;;}//stl版本deque&lt;int&gt; q;for (int i = 0; i &lt; n; i ++ ){    if (q.size() &amp;&amp; i - q.front() + 1 &gt; k) q.pop_front();    //这里求的是[0, i - 1]的最值    if (i &gt;= k - 1) cout &lt;&lt; a[q.front()] &lt;&lt; &quot; &quot;;    while (q.size() &amp;&amp; a[i] &lt;= a[q.back()]) q.pop_back();}</code></pre><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/156/" target="_blank" rel="noopener">AW.154 滑动窗口（简单）</a></p><p><a href="https://leetcode-cn.com/problems/max-value-of-equation/" target="_blank" rel="noopener">LC.1499 满足不等式的最大值（困难）</a></p>]]></content>
    
    <summary type="html">
    
      单调栈和单调队列总结
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="/2020/07/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>/2020/07/14/计算机基础知识/数据库/</id>
    <published>2020-07-14T13:05:08.000Z</published>
    <updated>2020-08-19T13:55:57.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库知识"><a href="#数据库知识" class="headerlink" title="数据库知识"></a>数据库知识</h1><h2 id="事物的四个特性"><a href="#事物的四个特性" class="headerlink" title="事物的四个特性"></a>事物的四个特性</h2><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。ACID：原子性、一致性、隔离性、持久性。</p><ol><li><p>A: 原子性（Atomicity)。原子性是指事务包含的所有操作<strong>要么全部成功，要么全部失败</strong>回滚，因此事务的操作如果成功就必须要<strong>完全应用到数据库</strong>，如果操作失败则<strong>不能对数据库有任何影响</strong>。</p></li><li><p>C:一致性（Consistency)。一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p><p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p></li><li><p>I:隔离性（Isolation）。隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p></li><li><p>D:持久性（Durability）。持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p></li></ol><h2 id="脏读、幻读和不可重复读"><a href="#脏读、幻读和不可重复读" class="headerlink" title="脏读、幻读和不可重复读"></a>脏读、幻读和不可重复读</h2><p>这几种情况在读取和写入数据库的时候会产生，事务虽然有原子性，但是读写的并发并不影响原子性，因此最终导致了以下的数据并发问题。解决这几种错误的数据库现象，需要了解<strong>数据库的事务隔离级别</strong>，下方有详细介绍。</p><ul><li>脏读：事务A读取的事务B中尚未提交的数据，如果事务B回滚，则<strong>A读取使用了错误的数据</strong>。比如我给你转了100万，但是我还没有提交，此时你查询自己账户，多了100万，很开心。然后我发现转错人了，回滚了事物。然后你100万就没了。 在过程中你查到了没有提交事物的数据（多出的100万），这就是脏读。</li><li>不可重复读：指在对于数据库中的某个数据，一个事务范围内<strong>多次查询却返回了不同的数据值</strong>（这里主要指某一表项的修改），这是由于在查询间隔，被另一个事务修改并提交了。这里的不可重复读主要说的是数据库表的某一项，和幻读的区别在于<strong>幻读是数据库内表中的查询不一致</strong>。在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如<strong>同一个事物前后两次</strong>查询同一个数据，期望两次读的内容是一样的，但是因为读的过程中，因为另一个事务写了该数据，导致不可重复读。</li><li>幻读：在事务A的多次读取构成中，事务B对数据（这里主要指的是<strong>表内的插入操作</strong>）进行了新增操作，导致事务A多次读取的数据不一样，好像出现了幻觉一样。不可重复度是表项的update操作，幻读是对表内的insert操作。比如第一次读取表内是10个查询结果，在第二次查询之前，另一个事务加了一条（因为不是对同一个数据项写入，不是不可重复读），这时再次查询就变成了11个，不一致了。</li><li>第一类事务丢失（回滚丢失）：A和B在同时写一个数据，B事务已经提交，修改了数据，然后<strong>A事务因为某种原因回滚了</strong>，导致B事务的提交因A事务的回滚而丢失了。举例子来说，比如我有1000元。买一个东西，花了100元。然后我朋友给我转了1000元。理论上这两个事物（转账和买东西）正常的话，我应该还有1900元。 但是现在两个事物A和B同时进行，第一步都先查询我余额还有1000元，然后B事物给我转了1000元，提交了，理论上我还有2000元。然后我买东西，100元的，买到一半，我事物回滚，就回滚成了1000元(少了1000）。如果我不回滚，也提交了，我就还剩900元（也就是下面介绍的第二类事物丢失，覆盖丢失，也是少了1000）。</li><li>第二类事务丢失（提交覆盖丢失）：A和B同时执行事务，两个事务同时取到一个数据，B事务首先提交，但是A事务接下来又提交，这样就覆盖了B事务。</li></ul><p><a href="https://blog.csdn.net/qq_35206244/article/details/82493215" target="_blank" rel="noopener">CSDN.数据库ACID四大特性及脏读，不可重复读，幻读，事物丢失</a></p><p><a href="https://blog.csdn.net/ITWANGBOIT/article/details/102953327" target="_blank" rel="noopener">CSDN.对数据库幻读的理解</a></p><p><a href="https://blog.csdn.net/paopaopotter/article/details/79259686" target="_blank" rel="noopener">CSDN.数据库第一类第二类丢失更新</a></p><h2 id="数据库的事务隔离级别"><a href="#数据库的事务隔离级别" class="headerlink" title="数据库的事务隔离级别"></a>数据库的事务隔离级别</h2><p>事务的隔离级别实际上就是用锁来处理并发操作中，对于数据读写之后的不一致情况。下方的加锁的等级从低到高，而且加锁越多，数据库的效率越低，因为如果串行化就没有并发了。</p><ol><li>未提交读（Read uncommitted)。写操作加锁，读操作不加锁，禁止第一类丢失更新，但是其他数据并发问题还会发生。</li><li>提交读（Read committed)。写操作加写锁，读操作加读锁。禁止第一类丢失更新和脏读。指你已经开始读了数据，然后一个事物开始写，然后写的事物不提交的话，是不能进行读的事物，避免了脏读。</li><li>可重复读（Read repeatable)。对于读操作加读锁到事务结束，其他事务的更新操作只能等到事务结束之后进行。和提交 读的区别在于，提交读的读操作是加读锁到本次读操作结束，可重复读的锁粒度更大。禁止两类丢失更新，禁止脏读和不可 重复度，但是可能出现幻读.一个事物读的时候，我们把两次读看成整体，在读的过程中，不允许写的操作，这样就可以禁止不可重复读。就是两次读操作不允许其他事物。这是大部分关系数据库的<strong>默认隔离级别</strong>。</li><li>序列化（Serializable)。对表级读和写加锁。读操作加表级读锁至事务结束。可以禁止幻读。</li></ol><p>好好看看下边的博客，里面图片比较容易理解。</p><p><a href="https://www.cnblogs.com/shan-kylin/p/9543294.html" target="_blank" rel="noopener">Blog.ZhuoQiLin 数据库的四大特性以及四个隔离级别和引发的问题</a></p><h2 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h2><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树是2-3树的一种扩展，用于对数据的排序和快速查找（时间复杂度为O(logn)）。B树是一颗多路平衡查找树，并且满足以下的定义，其中m是B树的阶数：</p><ol><li>每个节点最多有m - 1个关键字（键值对）。</li><li>根节点最少可以只有1个关键字。</li><li>非根节点至少有m / 2个关键字。</li><li>每个节点中的所有关键字都按照从下到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的都大于它。</li><li>所有叶子节点都位于同一层，即根节点到每个叶子节点的长度都相同。</li><li>每一个节点都存有索引和数据（这点和B+树不一样，因此特别说明）。</li></ol><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>相比于B树，B+树有两种类型的节点：<strong>内部节点</strong>（也称索引节点）和<strong>叶子节点</strong>。其中内部节点是不存储数据的，只存储索引，数据都存储在叶子节点。内部节点中的key都从小到大排列，左子树的key都更小，右子树都更大。叶子节点也是有序的。<strong>每个叶子节点都存有相邻叶子节点的指针</strong>，这样可以从一个叶子节点直接找到另一个叶子节点。父节点存有右孩子的第一个元组的索引。</p><p>插入操作简单来说，就是如果大于等于m个了，就将中间的作为索引放到父节点，然后右边多一个。</p><p>删除操作相比于B树更加容易，只需要从左右边兄弟节点结元素，并且修改父亲的索引即可，如果借不到，就合并，之后还是修改父亲索引。</p><p><a href="https://segmentfault.com/a/1190000020416577" target="_blank" rel="noopener">Blog.SF 面试官问你B树和B+树，就把这篇文章丢给他</a></p><h2 id="MySql常用语句"><a href="#MySql常用语句" class="headerlink" title="MySql常用语句"></a>MySql常用语句</h2><pre><code class="lang-sql">select Emailfrom Person--使用group by将所有不同Email分组group by Email--having子句作为挑选Email分组的条件having count(Email) &gt; 1select distinct p1.Email --自连接，将左边和右边的表一起查询from Person as p1 inner join Person as p2--条件是如下where子句where p1.Email = p2.Email and p1.Id != p2.Idselect A.Name as Customers--左连接，即便右边是空的也连接from Customers as A left join Orders as B--on语句，条件连接on A.Id = B.CustomerId--在连接之后的表中查询B.Id是空的情况where B.Id is null</code></pre><p><a href="https://leetcode-cn.com/problems/duplicate-emails/solution/" target="_blank" rel="noopener">LC.182 查找重复的电子邮箱（简单）</a></p><p><a href="https://leetcode-cn.com/problems/customers-who-never-order/" target="_blank" rel="noopener">LC.183 从不订购的客户（简单）</a></p>]]></content>
    
    <summary type="html">
    
      数据库知识
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>有向图的强联通分量</title>
    <link href="/2020/07/14/%E7%AE%97%E6%B3%95/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F/"/>
    <id>/2020/07/14/算法/有向图的强联通分量/</id>
    <published>2020-07-14T06:44:08.000Z</published>
    <updated>2020-07-17T14:39:27.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有向图的强联通分量"><a href="#有向图的强联通分量" class="headerlink" title="有向图的强联通分量"></a>有向图的强联通分量</h1><h2 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Tarjan算法通过对于有向图的dfs，将图看成一颗树的形式，并且把树中的边分为四类：</p><ol><li>树枝边：树中从a到b在dfs中相邻的边。</li><li>前向边：树中在dfs过程中，从祖先某个节点连接到未来某个节点的边。其中树枝边是前向边的特例。</li><li>后向边：从当前dfs遍历的节点连接回dfs路径上某个点的边。</li><li>横插边：从当前dfs遍历的节点连接回某个祖先节点的边。</li></ol><p>在遍历的过程中，用dfn数组记录第一次遍历到时的时间戳，用low数组记录<strong>当前节点可以走到的最早的祖先节点的时间戳</strong>，这样如果dfn[u] == low[u]表示当前节点是遍历的当前强联通分量的最早的节点，因此将栈中记录的所有点进行回溯，放到同一个联通分量中。</p><p>一般来说Tarjan算法求完强联通分量之后，都会进行缩点操作，然后进行拓扑图上的拓扑顺序的遍历。当求完所有强联通分量之后，scc_cnt递减的顺序就是当前拓扑图的拓扑遍历顺序，不用再写拓扑排序进行遍历。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">void tarjan(int u){    dfn[u] = low[u] = ++ timestamp;      stk[ ++ top ] = u, in_stk[u] = true;    for (int i = h[u]; ~i; i = ne[i])    {        int j = e[i];        if (!dfn[j])        {            tarjan(j);            low[u] = min(low[u], low[j]);        }        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);    }    if (dfn[u] == low[u])    {        int y;        ++ scc_cnt;        do {            y = stk[top -- ];            in_stk[y] = false;            id[y] = scc_cnt;            sz[scc_cnt] ++ ;        }    }}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/1176/" target="_blank" rel="noopener">AW.1174 最受欢迎的牛（中等）</a></p>]]></content>
    
    <summary type="html">
    
      Tarjan算法求有向图的强联通分量
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Trie树</title>
    <link href="/2020/07/14/%E7%AE%97%E6%B3%95/Trie%E6%A0%91/"/>
    <id>/2020/07/14/算法/Trie树/</id>
    <published>2020-07-14T06:41:01.000Z</published>
    <updated>2020-07-17T14:38:09.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;Trie树又叫字典树，可以<strong>快速插入和查询某一字符串是否在当前集合之中</strong>。限制条件是当前字符集合所有字符总数不能太大，否则效率低下且耗费空间。</p><p>&emsp;&emsp;这里存储树是通过<code>son[N][26]</code>类型的二维数组来存储，本质是一个单向查询函数，其中son的第一个维度为当前<strong>指针地址</strong>，用idx从0开始分配。树根被分配为0，之后依次分配地址递增。第二个维度26是当前确定的字符，当确定了当前节点和当前字符之后，就确定了son中存储值，即下一个节点的地址。通过这种逻辑来用数组存储树和图是一种较为方便和快捷的方法。</p><p>&emsp;&emsp;AC自动机是Trie树和KMP算法的结合，通过KMP算法的ne数组在Trie树上进行匹配，完成多个模板串在某一原串中出现次数的统计。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 100010;int son[N * 32][2];int val[N * 32];int idx;int n;void build(int x){    int p = 0;    for (int i = 31; i &gt;= 0; i -- )    {        int t = x &gt;&gt; i &amp; 1;        if (!son[p][t]) son[p][t] = ++ idx;        p = son[p][t];    }    val[p] = x;}int query(int x){    int p = 0;    for (int i = 31; i &gt;= 0; i -- )    {        int t = x &gt;&gt; i &amp; 1;        if (!son[p][!t]) p = son[p][t];        else p = son[p][!t];    }    return x ^ val[p];}int main(){    scanf(&quot;%d&quot;, &amp;n);    int res = 0;    for (int i = 0; i &lt; n; i ++ )    {        int t;        scanf(&quot;%d&quot;, &amp;t);        res = max(res, query(t));        build(t);    }    printf(&quot;%d\n&quot;, res);    return 0;}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/145/" target="_blank" rel="noopener">AW.143 最大亦或对（简单）</a></p>]]></content>
    
    <summary type="html">
    
      Trie树
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>离散化</title>
    <link href="/2020/07/11/%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <id>/2020/07/11/算法/离散化/</id>
    <published>2020-07-11T13:48:11.000Z</published>
    <updated>2020-07-11T13:48:10.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="通过哈希表进行离散化"><a href="#通过哈希表进行离散化" class="headerlink" title="通过哈希表进行离散化"></a>通过哈希表进行离散化</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;建立一个哈希表，通过每次将新的值映射为一个递增的n来达到离散化的目的。这种离散化不要求顺序，只需要值的对应即可。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">int find(int x){    if (S.count(x) == 0) S[x] = ++ n;    return S[x];}</code></pre><p><img src="https://i.loli.net/2020/06/11/Ghvsez17FXYmINB.jpg" alt></p><h2 id="排序-去重-二分查找进行离散化"><a href="#排序-去重-二分查找进行离散化" class="headerlink" title="排序+去重+二分查找进行离散化"></a>排序+去重+二分查找进行离散化</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;当要求有序的离散化时，需要将需要离散化的坐标排序，之后去重，最后使用二分查找获得映射后的坐标。这里其实相当于将排序后的数组下标作为离散化后的值。这种离散化的好处就是保序，当计算原下标3-7之间的结果时，直接计算离散化之后find(3)-find(7) = 3 - 5之间的结果即可。</p><p><img src="https://i.loli.net/2020/06/11/vIzDqYwVsuAeUaN.jpg" alt></p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//通过find函数找到原值的对应下标，即离散化之后的值int find(int x){    int l = 0, r = n - 1;    while (l &lt; r)    {        int mid = l + r &gt;&gt; 1;        if (a[mid] &gt;= x) r = mid;        else l = mid + 1;    }    return r;}//排序+去重sort(pts.begin(), pts.end());pts.erase(unique(pts.begin(), pts.end()), pts.end());</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/804/" target="_blank" rel="noopener">AW.802 区间和（简单）</a></p>]]></content>
    
    <summary type="html">
    
      离散化模板和常见套路
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="/2020/07/11/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>/2020/07/11/算法/树状数组/</id>
    <published>2020-07-11T13:48:04.000Z</published>
    <updated>2020-07-17T14:35:20.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="树状数组-1"><a href="#树状数组-1" class="headerlink" title="树状数组"></a>树状数组</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>树状数组可以在O(logn)的时间复杂度内计算前缀和。相比于前缀和数组和原数组，树状数组相当于两者进行了权衡。<strong>即满足单点修改，区间查询</strong>。使用差分数组可以使得树状数组在差分数组上计算，这样可以获得<strong>区间修改，单点查询</strong>的功能。</p><ul><li>前缀和数组计算前缀和为O(1)，修改操作之后重新计算前缀和时间复杂度为O(n)。</li><li>原数组计算前缀和为O(n)，修改操作只需要O(1)的时间复杂度不用重新计算。</li><li>树状数组计算前缀和为O(logn)，修改操作重新计算数组的时间复杂度也为O(logn)。</li></ul><p>树状数组的原理是将查询区间的右端点x（左端点一般为1）按照二进制展开，对于任一数字x都可以通过2的幂组合，从而快速的查询当前前缀和是多少。比如位置7的前缀和等于7 + 6 + 4位置数组之和，只需要log次操作就可以得到。</p><p>具体原理可以看下图：</p><p><img src="https://oi-wiki.org/ds/images/fenwick1.png" alt></p><p>在差分数组上建立树状数组，其中add操作和sum操作不变，但是由于是差分数组，对一个区间[l,r] + C相当于对差分数组add(l, c) &amp;&amp; add(r + 1, -c)。如果求某个位置上的数字，相当于sum(x)。</p><p>另外，树状数组还可以进行<strong>区间修改，区间和查询</strong>。需要推导一下公式，当然线段树也可以很好的完成这项操作。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">int n;//和需要求前缀和的数组大小相等//lowbit操作，得到当前数字二进制位的最后一个1int lowbit(int x){    return x &amp; -x;}//add操作，在某一位置 + c之后，更新所有需要变化的树状数组位置void add(int x, int c){    for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;}//sum操作，求某一个位置x的前缀和int sum(int x){    int res = 0;    for (int i = x; i; i -= lowbit(i)) res += tr[i];    return res;}//差分数组与树状数组结合int main(){    int l, r, c;    cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;    add(l, c), add(r + 1, -c);    int x;    cin &gt;&gt; x;    cout &lt;&lt; sum(x) &lt;&lt; endl;}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode-cn.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/" target="_blank" rel="noopener">LC.1505 最多K次交换相邻数位后得到的最小整数（困难）</a></p><p><a href="https://www.acwing.com/problem/content/248/" target="_blank" rel="noopener">AW.242 一个简单的整数问题（简单）</a></p>]]></content>
    
    <summary type="html">
    
      树状数组
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划（一）背包专题</title>
    <link href="/2020/07/08/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E8%83%8C%E5%8C%85%E4%B8%93%E9%A2%98/"/>
    <id>/2020/07/08/算法/动态规划（一）背包专题/</id>
    <published>2020-07-08T07:26:40.000Z</published>
    <updated>2020-07-29T05:36:56.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背包专题"><a href="#背包专题" class="headerlink" title="背包专题"></a>背包专题</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>dp[i][j]</code>表示考虑到第i个元素时，背包容量为j的情况下的最大价值。初始条件为<code>dp[0][i]</code> = 0，表示当考虑前0个物品时，无论背包容量为多少，最大价值都是0。状态转移方程可以通过定义得到，当前状态由前一个状态拿当前物品i或者不拿当前物品i转移过来。一维空间形式循环顺序要从m到v[i]，原因是省略了i - 1维度。</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])</script><script type="math/tex; mode=display">dp[j] = max(dp[j], dp[j - v[i] + w[i]]), j ∈(m,v[i])</script><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">for (int i = 1; i &lt;= n; i ++ )    for (int j = m; j &gt;= v[i];j -- )        f[j] = max(f[j], f[j - v[i]] + w[i]);</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">AW.2 01背包问题（简单）</a></p><p><a href="https://www.acwing.com/problem/content/280/" target="_blank" rel="noopener">AW.278 数字组合（简单）</a></p><p>01背包求可能方案种数</p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>如果按照01背包的状态定义和状态转移方程思维方式，我们不难得出如下的状态转移方程。</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i], ... , dp[i - 1][j - s * v[i]] + s * w[i]);</script><p>如果直接循环则需要3重循环来实现，但是我们发现上述部分项已经计算过了。</p><script type="math/tex; mode=display">dp[i][j - v[i]] + w[i] = max(dp[i - 1][j - v[i]] + w[i], dp[i - 1][j - 2 * v[i]] + 2 * w[i] , ... , dp[i - 1][j - s * v[i]] + s * w[i]);</script><p>所以<code>dp[i][j]</code>可以进行简化为：</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]), j∈(v[i], m)</script><p>如果化简为一维形式，由于需要简化的是<code>dp[i][j - v[i]]</code>，应该体积从小到大循环。这里可以优化的原因是，体积一定的情况下，如果可以随意拿取，那么拿取的s件一定是固定值，注意和下边的多重背包区分。</p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">for (int i = 1; i &lt;= n; i ++ )    for (int j = v[i]; j &lt;= m; j ++ )        f[j] = max(f[j], f[j - v[i]] + w[i]);</code></pre><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">AW. 完全背包问题（简单）</a></p><p><a href="https://www.acwing.com/problem/content/1023/" target="_blank" rel="noopener">AW.1021 货币系统（简单）</a></p><p>完全背包求可能方案种数</p><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">LC.322 零钱兑换（中等）</a></p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><ul><li>多重背包问题可以使用三重循环直接暴力求解，也可以使用二进制优化。暴力求解和上述完全背包问题相似，在于每次要确定s个物品，这里无法进行完全背包的优化，因为每次求解的s并不是固定值。</li><li>二进制优化的原理是将多个物品打包成一个物品来看，将最多选s个物品的问题转化成log(s)个物品的 01背包问题，从而降低复杂度。可以证明每次选取1,2,4,8,16…(s- 2^k - 1)个物品打包之后，每个物品选与不选的组合（看做01背包）可以得到s种结果。这里二进制优化的思想很有意思，可以类比快速幂和龟速乘。时间复杂度为O(N logS M)</li><li>多重背包的终极优化方式是单调队列优化。在将多重背包的公式展开之后，类比完全背包可以发现对于<code>f[i][j]</code>的计算相当于是j之前s大小滑动窗口内极值的计算，因此可以用线性方法直接计算，将时间复杂度从O(ns)优化到O(n)，最终的整体时间复杂度为O(nm)。</li></ul><p>多重背包的单调队列优化中，可以将背包体积展开成如下公式，其中公式二中的（s + 1）是因为本身体积为j - v但是还可以选择s个物品，因此最终剩下的体积就是j - (s + 1) * v。公式三种的r表示总体积对v取余之后的值，所以其实r = j % v，在代码中需要枚举所有的r，因为最终的余数可以是0到j % v的所有数，题目没有要求一定用完体积。</p><script type="math/tex; mode=display">f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2 * v] + 2 * w, ... , f[i - 1][j - s * v] + s * w)①\\f[i][j - v] = max(f[i - 1][j - v], f[i - 1][j - 2 * v] + w), f[i - 1][j - 3*v] + 2 * w, ... ,f[i - 1][j - (s + 1)* v] + s*w)②\\...\\f[i][r + v] = max(f[i - 1][r + v], f[i - 1][r] + w)③\\f[i][r] = max(f[i - 1][r])④</script><p>可以对比公式1和公式2，发现公式1比2所求的极值多了一个<code>f[i - 1][j]</code>,少了一个<code>f[i - 1][j - (s + 1) * v] + s * w</code>，类比之后所有项都有同样的规律，因此可以用单调队列优化。但是仔细观察，每一项虽然是相同的，但是每次会多一个w的偏移量，所以每次比较的都只能是前边的项，刚好减去j * w可以实现，在求值的时候可以再加上获得正确结果。</p><h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//暴力求解多重背包问题for (int i = 1; i &lt;= n; i ++ )    for (int j = 0; j &lt;= m; j ++ )        for (int t = 0; t &lt;= s[i]; t ++ )            if (j - s * v[i] &gt;= 0)                f[i][j] = max(f[i][j], f[i - 1][j - s * v[i]] + s * w[i]);//二进制优化#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 12010, M = 2010;int V[N], W[N];int idx;int n, m;int f[M];int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    //对于每一个物品将s件拆解成log(s)件打包的物品    for (int i = 0; i &lt; n; i ++ )    {        int v, w, s;        scanf(&quot;%d%d%d&quot;, &amp;v, &amp;w, &amp;s);        int k = 1;        while (k &lt;= s)        {            ++ idx;            V[idx] = k * v;            W[idx] = k * w;            s -= k;            k *= 2;        }        //如果还有剩余不满足2的幂次也要打包        if (s)        {            ++ idx;            V[idx] = s * v;            W[idx] = s * w;        }    }    //用01背包求解    for (int i = 1; i &lt;= idx; i ++ )        for (int j = m; j &gt;= V[i]; j -- )            f[j] = max(f[j], f[j - V[i]] + W[i]);    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}//多重背包二进制优化的一种更好的写法#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2010;int f[N];int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i ++ )    {        int v, w, s;        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;        for (int k = 1; k &lt;= s; k *= 2)        {            for (int j = m; j &gt;= k * v; j -- )                f[j] = max(f[j], f[j - k * v] + k * w);            s -= k;        }            if (s)                for (int j = m; j &gt;= s * v; j -- )                    f[j] = max(f[j], f[j - s * v] + s * w);    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}//单调队列优化#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010, M = 20010;int n, m;int f[M], g[M]; //滚动数组优化空间复杂度int q[M];int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i ++ )    {        int v, w, s;        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;        memcpy(g, f, sizeof f);        int R = m % v;        //枚举余数        for (int r = 0; r &lt;= R; r ++ )        {            int hh = 0, tt = -1;            //枚举当前体积下需要计算的每一项            //每次要记得减去j * w进行比较，因为窗口在滑动过程中，每次值都在增大，无法比较            for (int j = 0; j &lt;= (m - r) / v; j ++ )            {                //如果单调队列的滑动窗口已经超过s了就向前                if (hh &lt;= tt &amp;&amp; j - q[hh] &gt; s) hh ++ ;                //如果当前值大于单调队列的末尾，则出队                while (hh &lt;= tt &amp;&amp; g[r + j * v] - j * w &gt; g[r + q[tt] * v] - q[tt] * w) tt -- ;                //无条件入队当前元素                q[++ tt] = j;                //用当前最大值更新f数组得到当前结果                //f[r + j * v] = g[r + q[hh] * v] - q[hh] * w + j * w;                f[r + j * v] = g[r + q[hh] * v] + (j - q[hh]) * w;            }        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><p><a href="https://www.acwing.com/problem/content/4/" target="_blank" rel="noopener">AW.4 多重背包问题I（简单）</a></p><p><a href="https://www.acwing.com/problem/content/5/" target="_blank" rel="noopener">AW.5 多重背包问题II（中等）</a></p><p>第二题主要考察二进制优化</p><p><a href="https://www.acwing.com/problem/content/6/" target="_blank" rel="noopener">AW.6 多重背包问题III（困难）</a></p><p>第三题考察多重背包问题的单调队列优化</p><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>分组背包问题指有很多物品组，从每组中只能挑选一个物品，求最大价值。相当于每组之内物品互斥，且每组之间可以看成01背包问题。分组背包是有依赖的背包问题的前序问题。</p><h3 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int f[N];int v[N][N], w[N][N];int s[N];int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i ++ )    {        cin &gt;&gt; s[i];        for (int j = 0; j &lt; s[i]; j ++ )            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];    }    //先循环物品组，再循环体积，再循环组内物品    for (int i = 1; i &lt;= n; i ++ )        for (int j = m; j &gt;= 0; j -- )            for (int k = 0; k &lt; s[i]; k ++ )                if (j &gt;= v[i][k])                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);                    //这里枚举最后一个的时候是互斥的，因为确定了体积    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/9/" target="_blank" rel="noopener">AW.9 分组背包问题（中等）</a></p><h2 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>二维费用背包在一维费用背包 基础上，多一维度费用的判断，必须满足两者的费用均满足转移条件时，才可以转移。</p><h3 id="模板-4"><a href="#模板-4" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">int f[N][M];int v1[K], v2[K], w[K];for (int i = 1; i &lt;= n; i ++ )    for (int j = m1; j &gt;= v1[i]; j -- )        for (int k = m2; j &gt;= v2[i]; j -- )            f[j][k] = max(f[j][k], f[j - v1[i]][k - v2[i]] + w[i]);</code></pre><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/8/" target="_blank" rel="noopener">AW.8 二维费用背包问题（中等）</a></p><p><a href="https://www.acwing.com/problem/content/1024/" target="_blank" rel="noopener">AW.1022 宠物小精灵之收服（简单）</a></p><h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>输入很多个物品，每个物品可能有三种情况，01物品，无限次用物品和只能取用s个物品。其实可以将01背包看成多重背包的特例，之后分开进行状态转移。甚至完全背包也是多重背包的特例，每次可以取用的物品数一定不超过m / v  + 1个。</p><h3 id="模板-5"><a href="#模板-5" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int f[N];int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i ++ )    {        int v, w, s;        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;        if (s == -1) s = 1;        else if (s == 0) s = m / v + 1;        //二进制优化一种更好的写法        for (int k = 1; k &lt;= s; k *= 2)        {            for (int j = m; j &gt;= k * v; j -- )                f[j] = max(f[j], f[j - k * v] + k * w);            s -= k;        }        if (s)        {            for (int j = m; j &gt;= s * v; j -- )                f[j] = max(f[j], f[j - s * v] + s * w);        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/7/" target="_blank" rel="noopener">AW.7 混合背包问题（中等）</a></p>]]></content>
    
    <summary type="html">
    
      动态规划背包专题
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="/2020/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>/2020/07/06/计算机基础知识/计算机网络/</id>
    <published>2020-07-06T07:14:17.000Z</published>
    <updated>2020-08-16T01:53:31.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol><li>Client将标志位SYN置为1，<strong>随机产生一个值</strong>seq=j，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。（<strong>第一个SYN</strong>）</li><li>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=j+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。(<strong>第二个SYN + ACK</strong>)</li><li>Client收到确认后，检查ack是否为j+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。(<strong>第三个ACK</strong>)</li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p><ol><li>数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。</li><li>服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。</li><li>当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认</li><li>客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。其中MSL是任何报文在网络上存在的最长时间，超过这个时间的报文将被丢弃。等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次挥手的FIN包。</li></ol><p>图片理解：</p><p><img src="https://i.loli.net/2020/07/08/RzkDXJysi3vYlSQ.png" alt></p><h2 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h2><h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>发送方在发送数据之前计算校验和，填充校验和。接收方收到数据后，再次计算校验和，并和发送方的对比。</p><h3 id="序列号和确认应答"><a href="#序列号和确认应答" class="headerlink" title="序列号和确认应答"></a>序列号和确认应答</h3><p>TCP传输时对于每一个包进行了编号。ACK可以通过带有对应的确认序列号告诉发送方下一个应该发送报文的序号，如果有丢包会重新发送。接收方也可以根据序列号排序所有的报文，得到正确的数据。</p><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>如果在确认应答机制中，ACK报文有可能丢失。有两种可能：</p><ol><li>发送方发了，接收方一个都没收到。</li><li>接收方收到了，但是ACK回去的时候丢了。</li></ol><p>为了解决这个问题，引入了超时重传。发送方在发送完之后等待一个时间，如果时间结束没有接收到ACK报文，那么就重发一遍。接收方如果收到二次重发的数据，则丢弃，再发一次ACK。这个等待时间是<strong>动态计算</strong>的。</p><p>在Linux中（BSD Unix和Windows下也是这样）超时以<strong>500ms为一个单位</strong>进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2 x 500ms的时间后，再次重传。等待4 x 500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，<strong>强制关闭连接</strong>。</p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>三次握手和四次挥手。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP协议中根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。防止接收端接收太多数据，缓冲区填满之后引发超时重传等机制。</p><p>接收方会不停把自己缓冲区剩余大小放在ACK报文中，发送方通过ACK中窗口大小调节自己发送的速度。如果窗口大小为0，则<strong>停止发送数据</strong>，并定期向接收端发送窗口探测数据段。（心跳检测）</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>详细看下方的拥塞控制详解。</p><p><a href="https://blog.csdn.net/liuchenxia8/article/details/80428157" target="_blank" rel="noopener">CSDN.网络基础：TCP协议-如何保证传输可靠性</a></p><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，产生大量的超时重传，严重影响传输。</p><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，<strong>取较小的值作为实际发送的窗口</strong>，如下公式所述：</p><script type="math/tex; mode=display">real\_send\_window = min(rwnd, cwnd)</script><p>这里慢启动不是指报文发送的很慢，而是指发送窗口较小。首先发送1个包，收到回复报文之后，<strong>加倍发送</strong>窗口，以此类推直到门限值为止。</p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>慢启动的拥塞窗口增长是指数级别的，为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是<strong>线性的增长</strong>。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为<strong>原来的一半</strong>（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口<strong>重置为 1</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20190731165743903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70" alt></p><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>TCP传输中，如果某一序号的报文丢失，发送方还可以继续发送报文，这时每发一个报文，接收方都会发现当前接收的报文在未接收的报文序列之后，就会要求重传。当发送方接收到3个要求重传的请求报文之后，就不会进行发送方对3号报文的超时重传，而是直接收到了快重传。</p><p><img src="https://img-blog.csdnimg.cn/20190731184314574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70" alt></p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>快恢复算法是在收到三个重复ACK的时候，不直接把cwnd变成1，因为当前只是有个别的报文没有接收到，不需要重置网络传输窗口。</p><p><img src="https://img-blog.csdnimg.cn/20190731184640178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20190731184935595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70" alt></p><p><a href="https://blog.csdn.net/qq_41431406/article/details/97926927" target="_blank" rel="noopener">CSDN.TCP拥塞控制（详解）</a></p><h2 id="HTTP1-0-HTTP1-1-HTTP2-0的区别"><a href="#HTTP1-0-HTTP1-1-HTTP2-0的区别" class="headerlink" title="HTTP1.0/HTTP1.1/HTTP2.0的区别"></a>HTTP1.0/HTTP1.1/HTTP2.0的区别</h2><ol><li>1.0和1.1的区别在于<strong>长连接</strong>的使用，1.0每次请求使用新的TCP连接，之后关闭。1.1实现单个TCP连接可以复用，但是无法并行，2.0增加了多路复用，可以并行发送HTTP请求。</li><li>2.0使用二进制数据帧和流的概念，添加了二进制分帧层。1.0和1.1默认使用文本形式。二进制分帧层在发送过程中，将多个请求分成数据帧和头部帧，且拥有每一个<strong>请求的顺序号</strong>，在接收的过程中，可以进行组合，这样就可以在一个TCP连接中进行多个HTTP请求的发送。</li></ol><h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><h2 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h2><p>Cookie和Session都是来解决http协议中无状态的问题，可以使得当前连接状态被存储。都是用来验证客户端的身份的一种信息，但是这两者的区别主要在以下几点：</p><ol><li>Cookie存储在本地，Session存储在服务器上。</li><li>Cookie有maxAge，Session是临时性的，当网页关闭时Session立刻消失。</li></ol><p><a href="https://www.cnblogs.com/l199616j/p/11195667.html" target="_blank" rel="noopener">Blog.cookie和session的详解和区别</a></p><h2 id="HTTP中PUT和POST的区别"><a href="#HTTP中PUT和POST的区别" class="headerlink" title="HTTP中PUT和POST的区别"></a>HTTP中PUT和POST的区别</h2>]]></content>
    
    <summary type="html">
    
      计算机网络知识
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>最短路径算法</title>
    <link href="/2020/07/05/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    <id>/2020/07/05/算法/最短路径算法/</id>
    <published>2020-07-05T08:20:29.000Z</published>
    <updated>2020-07-06T07:11:53.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h1><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;使用邻接矩阵存储图更为合理，因为floyd算法要求每两个点之间的最短路径。循环顺序是kij其中k是阶段，从ik到kj点的最短路径由松弛操作</p><script type="math/tex; mode=display">g[i][j] = min(g[i][j], g[i][k] + g[k][j])</script><p>给出。当有重边和自环时，每两个点之间存储的<code>g[i][j]</code>只存储最短的一条即可。时间复杂度为<strong>O(n^3)</strong>。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/856/" target="_blank" rel="noopener">AW.854 Floyd求最短路（简单）</a></p><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;使用dist数组来维护所有点到源点的最短距离，用st数组维护已经确定最短距离的点。<strong>st数组一定要从空集开始</strong>，这样才能更新1号点。从所有点中选择<strong>距离源点最近的点</strong>来更新，将其所有临接点到源点的最短距离更新。最终更新了n个点后，所有点到达最短距离。时间复杂度为<strong>O(n^2)</strong>。</p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int d[N][N];int n, m;int dist[N];bool st[N];void dijkstra(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for (int i = 1; i &lt;= n; i ++ )    {        int t = -1;        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        st[t] = true;        for (int j = 1; j &lt;= n; j ++ )            if (dist[j] &gt; dist[t] + d[t][j])                dist[j] = dist[t] + d[t][j];    }    if (dist[n] == INF) cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;}int main(){    cin &gt;&gt; n &gt;&gt; m;    memset(d, 0x3f, sizeof d);    for (int i = 1; i &lt;= m; i ++ )    {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        d[a][b] = min(d[a][b], c);    }    dijkstra();    return 0;}</code></pre><h2 id="堆优化的Dijkstra"><a href="#堆优化的Dijkstra" class="headerlink" title="堆优化的Dijkstra"></a>堆优化的Dijkstra</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;维护一个堆，堆中储存一对信息（<strong>距离源点距离</strong>，<strong>当前点序号</strong>），从而每次得到距离源点最近的点的编号，扩展所有邻接点。这里不能保证每个点只入堆一次，因此当第一次从堆出来以后，再出来的就是错误的更新点，因此使用判重布尔数组st来continue。时间复杂度因为有堆进行优化，所以是<strong>O(mlogn)</strong>。</p><h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 150010, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], w[N], idx;int n, m;int dist[N];bool st[N];void dijkstra(){    memset(dist, 0x3f, sizeof dist);    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    dist[1] = 0;    heap.push({0, 1});    while (heap.size())    {        auto t = heap.top();        heap.pop();        int ver = t.y, distance = t.x;        if (st[ver]) continue;        st[ver] = true;        for (int i = h[ver]; ~i; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[ver] + w[i])            {                dist[j] = dist[ver] + w[i];                heap.push({dist[j], j});            }        }    }    if (dist[n] == INF) cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;}void add(int a, int b, int c){    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;}int main(){    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);    while (m -- )    {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);    }    dijkstra();    return 0;}</code></pre><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman Ford"></a>Bellman Ford</h2><p>&emsp;&emsp;可以求解不超过k条边的最短路径，通过k次循环，每次备份dist数组，每次遍历所有的边，通过上次dist数组更新本次dist数组，可以求取负边权的情况。时间复杂度是<strong>O(km)</strong>，因为每次经过k次迭代，每次迭代m条边。</p><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;SPFA算法是<strong>队列优化</strong>的Bellman Ford算法，由于Bellman Ford算法需要k次更新所有的边，但是其中某些边在没有最短路径涉及时不需要更新。SPFA算法通过维护队列，将<strong>每次被更新的点加入队列</strong>，每次只更新队列内部的点，这样就减少了很多不必要点的更新操作。队列里是所有被更新过的点，因此可以<strong>维护st数组</strong>，当某个点被多个点更新时，就不用重复进入队列作为一下步扩展更新了。时间复杂度是<strong>O(nm)</strong>，但是实际上会比这个复杂度快很多，接近于<strong>O(m)</strong>。有可能会被特殊的图卡时间复杂度，如果没有卡，算是最短路径里面最好用的算法了。</p><p>&emsp;&emsp;SPFA算法优化的一个重要原理是当元素出队的时候，已经在之前的过程中被多次更新，因此每次出队的时候，都是用当前很小的值去更新邻接点。</p><p>&emsp;&emsp;实现过程中，使用<strong>循环队列</strong>，因为一共需要更新多少次不一定，如果使用n * m的队列太大了。</p><h3 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010;const int INF = 0x3f3f3f3f;int h[N], e[N], ne[N], w[N], idx;int n, m;int dist[N], q[N];bool st[N];//这里spfa使用了循环队列void spfa(){    int hh = 0, tt = 1;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    q[0] = 1;    st[1] = true;    while (hh != tt)    {        int t = q[hh ++ ];        if (hh == N) hh = 0;        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            {                dist[j] = dist[t] + w[i];                if (!st[j])                 {                    q[tt ++ ] = j;                    st[j] = true;                }                if (tt == N) tt = 0;            }        }    }    if (dist[n] &gt;= INF / 2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;    else cout &lt;&lt; dist[n] &lt;&lt; endl;}void add(int a, int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;}int main(){    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);    while (m -- )    {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);    }    spfa();    return 0;}</code></pre><h2 id="SPFA判断负环"><a href="#SPFA判断负环" class="headerlink" title="SPFA判断负环"></a>SPFA判断负环</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;SPFA算法当队列不空的时候就会不断的更新图中路径的最短值，每次更新相当于多走一条边，当有负环的时候，某些节点一定会被无限次更新到负无穷，因此用cnt数组来记录每一个点的被更新次数，当某个点更新次数大于n – 1时，说明存在一条路径当更新n – 1次之后，还可以更小，这样就是存在负环了。开始时一定要把所有点都加入到队列中，否则只更新某一个点，也许去其他点的路径可以不经过负环，也就不会无限更新，就找不到负环来判断。</p><p>&emsp;&emsp;SPFA判断负环可以用栈代替队列。这样做的好处是可以快速的将当前元素不停更新，这样如果进入负环，无限次的更新很快即可以满足cnt[j] &gt;= n的条件，从而判断到负环。当超时的时候，可以考虑进行这种优化。另外，也可以设置一个经验值，比如2 <em> n或者3 </em> n以上，当SPFA算法更新次数超过这个次数的时候，也认为有负环，是一个大概率对但是不一定全对的优化。</p><h3 id="模板-4"><a href="#模板-4" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N = 2010, M = 10010;int h[N], e[M], ne[M], w[M], idx;int dist[N];int cnt[N];int n, m;bool spfa(){    memset(dist, 0x3f, sizeof dist);    queue&lt;int&gt; q;    for (int i = 1; i &lt;= n; i ++ )        q.push(i);    while (q.size())    {        auto t = q.front();        q.pop();        for (int i = h[t]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[t] + w[i] &lt; dist[j])            {                dist[j] = dist[t] + w[i];                cnt[j] = cnt[t] + 1 ;//表示当前路径下的该点已经经过了t + 1条边                //cnt[j] ++ ; 也可以这样写，代表有某点被更新多于n - 1次也是有负环存在，但是效率低                if (cnt[j] &gt;= n) return true;                q.push(j);            }        }    }    return false;}void add(int a, int b, int c){    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;}int main(){    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);    while (m -- )    {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);    }    if (spfa()) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;    else puts(&quot;No&quot;);    return 0;}</code></pre><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/854/" target="_blank" rel="noopener">AW.852 spfa判断负环（简单）</a></p>]]></content>
    
    <summary type="html">
    
      最短路径算法
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>DFS</title>
    <link href="/2020/07/01/%E7%AE%97%E6%B3%95/DFS/"/>
    <id>/2020/07/01/算法/DFS/</id>
    <published>2020-07-01T13:03:53.000Z</published>
    <updated>2020-07-01T13:38:54.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="DFS全局变量记录最值"><a href="#DFS全局变量记录最值" class="headerlink" title="DFS全局变量记录最值"></a>DFS全局变量记录最值</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每次DFS过程的时候都搜索到状态树的叶子节点，如果找到了答案就更新一下全局变量记录的最值，当搜索完整棵树的时候，就得到答案了。这种DFS的实现一般来说没有返回值，但是需要每次进行剪枝，如果答案已经比当前最优答案差了，就没有必要再搜下去了。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">int ans = 0;void dfs(int u, int sum){    if (sum &gt; ans) return;    if (u == n)    {        ans = max(ans, sum);        return;    }    //dfs进一步的逻辑}</code></pre><h2 id="DFS迭代加深"><a href="#DFS迭代加深" class="headerlink" title="DFS迭代加深"></a>DFS迭代加深</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>用BFS的思想来写DFS就是迭代加深，相当于每次搜索的时候，一层一层的搜索整颗树。用depth来标志搜索到哪一层了。适合答案比较浅的情况，理论来说会产生重复搜索，如果答案较深的话，不适合。这里的剪枝可以叫做乐观估计函数，即搜到多少肯定就没戏了。</p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">bool dfs(int depth, int u, int sum){    if (sum &gt; depth) return false;//如果超过当前深度就不继续搜了    if (u == n) return true;//如果搜到底了，那么一定得返回了    //具体下一步dfs的逻辑}int main(){    int depth = 0;    while (!dfs(depth, 0, 0)) depth ++ ;//每次迭代加深一      cout &lt;&lt; depth &lt;&lt; endl;    return 0;}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/189/" target="_blank" rel="noopener">AW.187 导弹防御系统（中等）</a></p><p>这题主要看迭代加深和全局记录DFS的解方法</p>]]></content>
    
    <summary type="html">
    
      DFS
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>/2020/06/30/计算机基础知识/操作系统/</id>
    <published>2020-06-30T07:56:08.000Z</published>
    <updated>2020-08-07T05:29:52.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ol><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（<strong>资源分配给进程，同一进程的所有线程共享该进程的所有资源</strong>。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</li><li>进程是CPU<strong>资源分配</strong>的最小单位，线程是CPU<strong>调度</strong>的最小单位；</li><li>系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、IO设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，<strong>进程切换的开销也远大于线程切换的开销</strong>。</li><li><strong>线程间比进程间通信更容易</strong>。由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预。</li><li>进程编程<strong>调试简单可靠性高</strong>，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程<strong>调试相对复杂</strong>。</li><li>进程间不会相互影响 ，而一个线程挂掉将导致整个进程挂掉。</li></ol><h2 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h2><p>进程间通信主要包括<strong>管道</strong>、<strong>系统IPC</strong>（包括消息队列、信号量、共享内存、信号等）、以及<strong>套接字socket</strong>。</p><h3 id="1-管道："><a href="#1-管道：" class="headerlink" title="1.管道："></a><strong>1.管道：</strong></h3><p>管道主要包括<strong>无名管道</strong>和<strong>命名管道</strong>。管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p><p><strong>1.1 普通管道PIPE（无名管道）：</strong></p><p>1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端，fd[0] 和fd[1]，0是读端，1是写端。</p><p>2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</p><p>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并<strong>不属于其他任何文件系统</strong>，并且<strong>只存在于内存</strong>中。</p><p><strong>Linux下实现代码</strong>：</p><pre><code class="lang-c++">int main(){    char buf[1024]=&quot;change world!\n&quot;;    int fds[2];    if(pipe(fds) == -1)        perror(&quot;pipe&quot;),exit(1);    pid_t pid = fork(); //创建子进程    if(pid == 0)//如果是父进程    {        close(fds[0]); //关闭管道读描述符        if(write(fds[1],buf,1024)==-1) //写进管道            perror(&quot;write&quot;),exit(1);        close(fds[1]);         exit(1);    }    else    {        memset(buf,0x00,1024);        close(fds[1]); //关闭管道写描述符        if(read(fds[0],buf,1024)==-1) //从管道读内容            perror(&quot;read&quot;),exit(1);        if(write(1,buf,1024)==-1)            perror(&quot;write&quot;),exit(1);        close(fds[0]);        exit(1);    }    return 0;}</code></pre><p><strong>1.2 命名管道FIFO：</strong></p><p>1)FIFO可以在<strong>无关的进程</strong>之间交换数据</p><p>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式<strong>存在于文件系统</strong>中。</p><p><strong>Linux下实现代码</strong>：</p><p>在Linux系统中，使用下边命令创建命名管道</p><pre><code class="lang-shell">mkfifo filename</code></pre><pre><code class="lang-shell">[centos@localhost fifo]$ mkfifo myfifo[centos@localhost fifo]$ lsmyfifo[centos@localhost fifo]$ file myfifomyfifo: fifo (named pipe)</code></pre><p>也可以在程序内部创建</p><pre><code class="lang-c++">int mkfifo(const char *pathname, mode_t mode);int main(){    mkfifo(&quot;my.p&quot;, 0644);    return 0;}</code></pre><p>从命名管道中读入读出</p><pre><code class="lang-c++">#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;//读入示例int main(){    mkfifo(&quot;my.p&quot;,0664);//八进制0664 = 110 110 100    int outfd = open(&quot;my.p&quot;,O_WRONLY);    if(outfd == -1)        perror(&quot;open my.txt&quot;),exit(1);    char buf[1024]={};    int n = 0;    while(fgets(buf,1024,stdin))    {           write(outfd,buf,1024);        memset(buf,0x00,1024);    }      close(outfd);}//读出示例int main(){    int infd = open(&quot;my.p&quot;,O_RDONLY);    if(infd==-1)        perror(&quot;open my.p&quot;),exit(1);    char buf[1024]={};    int n = 0;    while((n = read(infd,buf,1024))&gt;0)    {        write(1,buf,n);        memset(buf,0x00,1024);    }    close(infd);                                                                                                             unlink(&quot;my.p&quot;); //删除管道    return 0;}</code></pre><p><strong>总结：</strong></p><p>匿名管道由pipe函数创建并打开。命名管道由mkfifo函数创建，打开⽤用open。FIFO（命名管道）与pipe（匿名管道）之间唯一的区别在它们创建与打开的⽅方式不同，一但这些工作完成之后，它们具有相同的语义。</p><p><a href="https://www.cnblogs.com/zhonglongbo/p/8976730.html" target="_blank" rel="noopener">参考资料.Blog龙跃十二.利用管道实现进程间通信</a></p><h3 id="2-系统IPC（Inter-Process-Communication"><a href="#2-系统IPC（Inter-Process-Communication" class="headerlink" title="2.系统IPC（Inter-Process Communication)"></a><strong>2.系统IPC（Inter-Process Communication)</strong></h3><p><strong>2.1 消息队列</strong></p><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道<strong>只能承载无格式字节流</strong>以及缓冲区大小受限等特点)具有写权限的进程可以按照一定的规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p><p>特点：</p><p>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p><p>2)消息队列<strong>独立于发送与接收进程</strong>。进程终止时，消息队列及其内容并不会被删除。</p><p>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,<strong>也可以按消息的类型读取</strong>。</p><p>Linux下消息队列实现主要通过四个函数，msgget(),msgsnd(),msgrcv(),msgctl()。</p><pre><code class="lang-c++">#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;//调用成功返回一个keykey_t ftok(const char *pathname, int proj_id);//创建和获取消息队列int msgget(key_t key, int msgflg);//key : 消息队列关联的键，即id, 使用ftok()产生,不同进程通过相同key可以得到相同消息队列//msgflg ：消息队列的建立标志和存取权限//IPC_CREAT 单独使用是如果没有就创建 //IPC_EXCL + IPC_CREAT 是已经存在则执行失败//返回创建的消息队列的标识符msqid，msqid是IPC对象内部名，失败返回-1//使用的例子int open_queue(int keyval){    int qid;    qid = msgget(keyval, IPC_CREAT | 0666);    if (qid == -1)    {        perror(&quot;Failed in calling msgget&quot;);        return -1;    }    return qid;}//发送一条消息到指定的消息队列int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflag);//msqid为消息队列标识符//msgp指向准备发送消息的指针//msgsz上述指针指向消息的长度//msgflag默认为0（IPC_NOWAIT)，表示阻塞，1表示非阻塞。阻塞表示如果队列满了就一直等到有地方，如果非阻塞满了，就直接返回-1。//消息结构一方面必须小于系统规定的上限，另一方面必须以一个long int长整型开始，接受者以此来确定消息的类型（协议必须的部分）//实际例子struct msgbuf{    long mtype;    char mtext[1024];}int sendMsgQueue(int msg_id, int who, char* msg){    struct msgbuf buf;    buf.mtype = who;    strcpy(buf.mtext, msg);//前目的，后源    if (msgsnd(msg_id, (void*) &amp;buf, sizeof(buf.mtext), 0) &lt; 0)    {        perror(&quot;Fail to send message to MsgQueue!&quot;);        return -1;    }    return 0;}//从指定消息队列接收一条消息int msgrcv(int msqid, const void* msgp, size_t msgsz, long msgtype, int msgflg);//参数和msgsnd相同//例子int recvMsgQueue(int msg_id, int recvType, char out[]){    struct msgbuf buf;    int size = sizeof(buf.mtext);    if (msgrcv(msg_id, (void*)&amp;buf, size, recvType, 0) &lt; 0)    {        perror(&quot;Fail to receive message from MsgQueue!&quot;);        return -1;    }    strncpy(out, buf.mtext, size);//将特定大小的字符串复制    out[size] = 0;//字符串设置为&#39;\0&#39;    return 0;}//消息控制int msgctl(int msqid, int cmd, struct msgid_ds *buf);//msqid是由msgget返回的消息队列id//cmd有三种值 //IPC_RMID 删除消息队列//PIC_STAT 把msgid_ds结构中的数据设置为消息队列的当前关联值//IPC_SET 在进程有足够权限的前提下，把消息队列的当前关联值设置为msgid_ds数据结构中给出的值int destoryMsgQueue(int msg_id){    if (msgctl(msg_id, IPC_RMID, NULL) &lt; 0)    {        perror(&quot;Remove MsgQueue Fail!&quot;);        return -1;    }    return 0;}</code></pre><pre><code class="lang-shell">#ipcs 显示IPC资源 -q是消息队列， -m是共享内存#ipcrm 手动删除IPC资源[root@localhost code]# ipcs -q------ Message Queues --------                                                 key        msqid      owner      perms      used-bytes   messages0x66020001 524288     root       666        0            0[root@localhost code]# ipcrm -q 524288[root@localhost code]# ipcs -q------ Message Queues --------                                                 key        msqid      owner      perms      used-bytes   messages[root@localhost code]#</code></pre><p><a href="https://blog.csdn.net/wei_cheng18/article/details/79661495" target="_blank" rel="noopener">CSDN. Linux进程间通信之消息队列</a></p><p><a href="https://blog.csdn.net/xiaohuangcat/article/details/8203734?locationNum=6" target="_blank" rel="noopener">CSDN. Linux进程通信之消息队列-项目实践</a></p><p><strong>2.2 共享内存（Shared Memory）</strong></p><p>它使得<strong>多个进程</strong>可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种<strong>同步操作</strong>，如互斥锁和信号量等。</p><p>特点：</p><p>1)共享内存是<strong>最快</strong>的一种IPC，因为进程是直接对内存进行存取。</p><p>2)因为多个进程可以同时操作，所以需要进行同步。</p><p>3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</p><p>Linux下共享内存机制实现代码，因为是IPC所以很多差不多：</p><pre><code class="lang-c++">#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;//建立（获得）一块共享存储区，返回共享存储区的描述符shmid，新建立后初始化为0//key还是ftok函数生成的int shmget(key_t key, size_t size, int shmflg);//这里的key和size与消息队列相同//shmflg有 IPC_CREAT IPC_EXCL用法同消息队列//SHM_HUGETLB 使用“huge pages”来分配共享区段//SHM_NORESERVE 不要为共享区段保留交换空间//对共享存储区shmid执行操作cmd，对其状态进行修改和控制int shmctl(int shmid, int cmd, struct shmid_ds *buf);//cmd有五种，除了消息队列的三种，还多了两种//IPC_STAT IPC_SET IPC_RMID 删除的时候会等待最后一个使用该存储区的进程终止，但是标识符会立刻删除，无法再使用shmat与该段相连//SHM_LOCK SHM_UNLOCK 锁住和解锁共享存储区，需要superuser权限//获得了shmid后，系统需要使用shmat将该共享存储区附接到用户给定的某个进程的虚拟地址void *shmat(int shmid, const void *addr, int flag);//addr指定共享内存出现在进程地址的什么位置，指定为NULL可以让内核自己决定//flag是对于数据的操作，SHM_RDONLY（010000）是只读，其他为读写方式//成功返回指向共享存储段的指针，错误返回-1（0xffffffff)//当进程不再需要一个共享存储段时，可以使用shmdtint shmdt(void * addr);//addr是调用shmat的返回值//成功返回0，错误返回-1//实际例子struct Info{    char name[100];    int age;};int main(){    key_t key = ftok(&quot;/tmp&quot;, 66);    int shmid = shmget(key, sizeof(Info), IPC_CREAT|0666);    Info *p;    p = (Info *)shmat(shmid, NULL, 0);    char name[100] = &quot;ScarofSky&quot;;    int age = 25;    strcpy(p -&gt; name, name);    p -&gt; age = age;    if (shmdt(p) == -1)    {        perror(&quot;Dettach Fail!&quot;);        return -1;    }    return 0;}</code></pre><p>总结：相当于对于共享内存的读写，转换为当前进程中虚拟地址（指针）的读写。</p><p><a href="https://blog.csdn.net/qq_27664167/article/details/81277096" target="_blank" rel="noopener">CSDN.Linux下共享内存编程</a></p><p><strong>2.3 信号量semaphore</strong></p><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。<strong>信号量用于实现进程间的互斥与同步</strong>，而<strong>不是用于存储进程间通信数据</strong>。</p><p>特点：</p><ol><li>信号量用于进程间同步，<strong>若要在进程间传递数据需要结合共享内存</strong>。</li><li><p>信号量基于操作系统的 PV 操作，程序对信号量的操作都是<strong>原子操作</strong>。</p></li><li><p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且<strong>可以加减任意正整数</strong>。</p></li><li><p>支持信号量组。</p></li></ol><p>PV操作的具体意义：</p><ul><li>P(s):将信号量value值减1,若结果小于0,则执行P操作的进程被阻塞，若结果大于等于0,则执行P操作的进程将继续执行。</li><li>V(s):将信号量的值加1,若结果不大于0,则执行V操作的进程从信号量s有关的list所知队列中释放一个进程，使其转化为就绪态，自己则继续执行，若结果大于0,则执行V操作的进程继续执行。</li></ul><p>PV操作先对value值加减，再判断和0的关系，之后再决定阻塞和唤醒，是上述逻辑。信号量在Linux中有两种规范，一个是System V标准，另一个是Posix标准。如下的具体代码只涉及Posix标准，System V只列出。</p><pre><code class="lang-c++">//System V 标准APIint semget(key_t key, int num_sems, int sem_flags);int semop(int sem_id, struct sembuf *sops, size_t nsops);int semctl(int sem_id, int sem_num, int cmd);//Posix 标准API#include &quot;semaphore.h&quot;//初始化一个信号量int sem_init(sem_t *sem, int pshared, unsigned int value);//sem为指向信号量结构的一个指针//pshared != 0在进程间共享，pshared == 0 只在当前进程的所有线程共享//value是初始值//等同于V操作int sem_post(sem_t *sem);//调用后value ++ , 线程调度策略决定唤醒哪个阻塞的线程//等同于P操作int sem_wait(sem_t *sem);//如果信号量值大于0， 则值-1， 如果值小于等于0，则阻塞当前进程//if (sem &gt; 0) sem -- ;//else if (sem &lt;= 0) //{//    sem -- ;//    sleep();//}</code></pre><p><a href="https://blog.csdn.net/sunxiaopengsun/article/details/79898884" target="_blank" rel="noopener">CSDN. Linux信号量操作</a></p><p><strong>2.4 信号signal</strong></p><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p><strong>软中断</strong>信号（signal，又简称为信号）用来通知进程发生了异步事件。<strong>在软件层次上是对中断机制的一种模拟</strong>，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。</p><p><a href="https://www.cnblogs.com/sky-heaven/p/10176422.html" target="_blank" rel="noopener">Blog.sky</a></p><p><strong>3.套接字SOCKET：</strong></p><p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p><p><a href="https://blog.csdn.net/kkkkde/article/details/81698124" target="_blank" rel="noopener">CSDN.Linux网络编程 套接字编程</a></p><h2 id="线程间通信的方式"><a href="#线程间通信的方式" class="headerlink" title="线程间通信的方式"></a><strong>线程间通信的方式</strong></h2><p>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p><p>互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p><p>信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p><p>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><h2 id="死锁的必要条件和解决方法"><a href="#死锁的必要条件和解决方法" class="headerlink" title="死锁的必要条件和解决方法"></a>死锁的必要条件和解决方法</h2><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：</p><ol><li>互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。</li><li>占有和等待：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。</li><li>非抢占：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放。</li><li>循环等待：进程发生死锁后，必然存在一个进程-资源之间的环形链。</li></ol><p>死锁的处理方法是<strong>死锁预防</strong>、<strong>死锁避免</strong>、<strong>死锁检测</strong>和<strong>死锁恢复</strong>。</p><ul><li>死锁预防的方法：</li></ul><ol><li><strong>资源一次性分配</strong>，从而剥夺占有并等待条件。当一个进程申请一个资源时，它不能占有其他资源。缺点是资源利用率低和可能发生饥饿，当资源一次性分配之后，可能有些最后才用到；如果进程需要多个常用资源，可能会发生饥饿导致一直分配不到资源，一直等待。</li><li><strong>抢占式协议</strong>：如果一个进程占有资源并申请另一个不能立即分配的资源，那么现在已经分配的资源允许其他进程抢占。换句话说，这些资源被<strong>隐式释放</strong>了。如果有新的进程请求资源，那么系统先考虑自由资源，再考虑等待中进程的资源，如果都不够，那么该进程也进入等待。</li><li><strong>资源有序分配法</strong>：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件。</li></ol><ul><li>死锁避免的方法：获得以后进程如何申请资源的附加信息，由操作系统来综合考虑如何分配资源，使用已有的死锁避免算法。</li></ul><ol><li>安全状态</li><li>资源分配图算法（每种资源都有单个实例）</li><li>银行家算法（每种资源有多个实例）</li></ol><ul><li>死锁检测和恢复的方法：系统提供检测算法 + 恢复算法</li></ul><h2 id="缺页置换算法"><a href="#缺页置换算法" class="headerlink" title="缺页置换算法"></a>缺页置换算法</h2><p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：</p><ol><li>先进先出（FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后顺序排列。</li><li>最近最少使用（LRU)算法：置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。被使用的页就会被刷新，放到最近的位置，长时间未被使用的就会慢慢排到最后。</li></ol><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul><li>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在<strong>单核CPU上的多任务</strong>。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</li><li>并行（parallelism）：指<strong>严格物理意义上的同时运行</strong>，比如多核CPU，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</li></ul><h2 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h2><p><strong>大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。</strong>我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。</p><pre><code class="lang-c++">//判断系统是大端序还是小端序int fun1(){    union  test    {        int i;        char c;    };    test t;    t.i = 1;    return (t.c == 1);}</code></pre><p>比如0x12345678如果是小端序，存储地址从低到高应该是78 56 34 12，如果是大端序，从低到高地址存储应该是12 34 56 78。</p><p>大端序：</p><p>低地址 ——————————&gt; 高地址<br>0x12  |  0x34  |  0x56  |  0x78</p><p>小端序：</p><p>低地址 ——————————&gt; 高地址<br>0x78  |  0x56  |  0x34  |  0x12</p><h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h2 id="CPP到EXE过程"><a href="#CPP到EXE过程" class="headerlink" title="CPP到EXE过程"></a>CPP到EXE过程</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><ol><li>删除注释</li><li>宏替换，#define删除并且替换所有的宏定义位置的值</li><li>处理所有条件预编译指令，#if #ifdef #endif #elif #else，处理#include，将包含的文件直接复制到当前位置。保留#pragma的编译指令，编译器会使用</li><li>添加行号和文件名表示，以便于调试时能显示编译错误或警告产生。</li></ol><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><ol><li>词法分析</li><li>语法分析</li><li>语义分析与中间代码生成</li><li>优化（对于中间代码）</li><li>目标代码生成</li></ol><p>目标代码的形式可以是<strong>绝对指令代码</strong>或<strong>可重定位的指令代码</strong>或<strong>汇编指令代码</strong>。</p><p>如目标代码是绝对指令代码，则这种目标代码可立即执行。</p><p>如果目标代码是汇编指令代码，则需汇编器汇编之后才行运行。</p><p>现在多数实用编译程序所产生的目标代码都是一种可重定位的指令代码。这种目标代码在运行前必须借助于一个连接装配程序（<strong>链接器</strong>）把各个目标模块（包括系统提供的库函数）连接在一起，确定程序变量（或常数）在主存中的位置，装入内存中指定的起始地址，使之<strong>成为一个可以运行的绝对指令代码程序</strong>。</p><p><a href="https://blog.csdn.net/wilsonpeng3/article/details/21327667" target="_blank" rel="noopener">Blog.CSDN 编译过程的五个阶段</a></p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>将汇编语言翻译成二进制代码，构建可重定位的二进制文件（.o/.obj文件）。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接主要是将多个文件编译出来的.o文件合成最终的可执行程序，这样可以将程序按照模块开发，降低开发的难度。这样会带来问题是不同文件会互相使用其他文件中定义的全局变量和函数，编译时只能解决当前文件中地址，但是真实运行时的具体地址，要靠链接器来决定。</p><p><strong>可重定位目标文件</strong>中包含代码和数据，即.text段.data段.bss段。同时也包括<strong>符号表</strong>来提供链接时需要的信息。</p><ol><li>合并段。</li><li>调整段地址偏移量和段长度。</li><li>合并所有的符号：进行符号解析。</li><li>空间与地址的分配。</li><li>符号重定位。</li></ol><p>可执行文件加载到内存之后的分布：</p><p><img src="https://img2018.cnblogs.com/blog/1193092/201904/1193092-20190424125528050-1062178045.png" alt></p><p><a href="https://www.cnblogs.com/snsart/p/10761642.html" target="_blank" rel="noopener">Blog.snsart 文件的链接过程</a></p>]]></content>
    
    <summary type="html">
    
      操作系统知识 面试
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划（二）其他DP</title>
    <link href="/2020/06/30/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E5%85%B6%E4%BB%96DP/"/>
    <id>/2020/06/30/算法/动态规划（二）其他DP/</id>
    <published>2020-06-30T07:30:01.000Z</published>
    <updated>2020-07-29T14:53:28.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="其他DP"><a href="#其他DP" class="headerlink" title="其他DP"></a>其他DP</h1><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>区间DP是在区间上进行动态规划，本质是用更小区间的最优解来求更大区间的最优解。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">for (int len = 2; len &lt;= n; len ++ )    for (int i = 1; i + len - 1 &lt;= n; i ++ )    {        int j = i + len - 1;        for (int k = i; k &lt; j; k ++ )            f[i][j] = max(f[i][j], f[i][k] + f[k][j] + ****);    }</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/284/" target="_blank" rel="noopener">AW.284 石子合并（简单）</a></p><h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><p>状压DP分为两类，一类是棋盘式（基于连通性）的模型，另一类是基于集合。</p><h3 id="棋盘式原理"><a href="#棋盘式原理" class="headerlink" title="棋盘式原理"></a>棋盘式原理</h3><p>蒙德里安的梦想这道题，是求把N<em>M的棋盘分割成若干个1</em>2的的长方形，有多少种方案。通过将每一列看成一个状态，其中放了小块的格子为1，没放的为0，这样可以通过枚举所有的状态到状态的转移来进行计数。</p><h3 id="基于集合原理"><a href="#基于集合原理" class="headerlink" title="基于集合原理"></a>基于集合原理</h3><p>最短哈密尔顿路径，给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。对所有点构成的集合考虑，已经走过的点为1，还没有到达过的点为0，可以确定一个n位状态state，但如果需要从一个点转移到下一个点，则还需要记录当前停在了哪一个点上。因此用<code>f[state][j]</code>表示到达j号点时，已经走过的状态为state的路径集合中的最小值。</p><p>  因此可以得到状态转移方程：</p><script type="math/tex; mode=display">f[state][j] = min(f[state][j], f[state - (1 << k)][k] + w[k][j]), state >> k \ \& \ 1 = 1</script><p>当然如果从终点考虑，这样的转移方程也是合法的：</p><script type="math/tex; mode=display">f[i \ \| \ (1 << k)][k] = min(f[i \ \| \ (1 << k)][k], f[i][j] + d[j][k]), state >> k\  \& \ 1 = 0</script><h3 id="基于集合模板"><a href="#基于集合模板" class="headerlink" title="基于集合模板"></a>基于集合模板</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const long N = 21, M = 1 &lt;&lt; N;int n;int f[M][N];int d[N][N];int main(){    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i ++ )        for (int j = 0; j &lt; n; j ++ )            scanf(&quot;%d&quot;, &amp;d[i][j]);    memset(f, 0x3f, sizeof f);    f[1][0] = 0;    for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )        for (int j = 0; j &lt; n; j ++ )            if (i &gt;&gt; j &amp; 1)                for (int k = 0; k &lt; n; k ++ )                    //if (i &gt;&gt; k &amp; 1)                        //f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + d[k][j]);                    if (!(i &gt;&gt; k &amp; 1))                        f[i | (1 &lt;&lt; k)][k] = min(f[i | (1 &lt;&lt; k)][k], f[i][j] + d[j][k]);    cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;    return 0;}</code></pre><h2 id="LIS问题"><a href="#LIS问题" class="headerlink" title="LIS问题"></a>LIS问题</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>LIS问题有两种解法，基于动态规划定义f[i]为以i结尾的最长上升子序列的最大长度。如果基于贪心，将i之前所有上升子序列长度存储下来，则可以发现其必然是单调上升的，因此可以通过二分来优化时间复杂度为O(nlogn）。</p><p>关于贪心解法的证明：</p><ol><li>首先我们发现，在求解LIS问题时，如果a b c序列，c可以接到a后边即c &gt; a，那么如果b &lt; a则c一定也可以接到b后边。因此在这种思想的指导下，我们可以存储i位置之前所有长度的上升子序列的最后一位的<strong>最小值</strong>。</li><li>其次，对于上述存储方式，我们发现应该是单调递增的。因为如果长度为x的末尾的值，大于长度x + 1末尾的值，则在长度x + 1的情况下，一定存在一个长度为x的序列，其末尾值又严格小于现在x的末尾的值，由此发现不是最小值，矛盾，因此一定是严格上升的。</li></ol><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//基于DP的O(n^2)解法for (int i = 1; i &lt;= n; i ++ ){    f[i] = 1;    for (int j = 1; j &lt; i; j ++ )        if (a[i] &gt; a[j])            f[i] = max(f[i], f[j] + 1);}//基于贪心的O(nlogn)的解法int q[N];int a[N];int len = 0;q[0] = -2e9; //哨兵，表示长度为0的最长上升子序列的末尾值for (int i = 0; i &lt; n; i ++ ){    int l = 0, r = len;    while (l &lt; r)    {        int mid = l + r + 1 &gt;&gt; 1;        if (q[mid] &lt; a[i]) l = mid; //如果q[mid] &lt; a[i]表示当前的mid的值比a[i]要小，因此mid可以再大点        else r = mid - 1;    }    len = max(len, r + 1);    q[r + 1] = a[i];}cout &lt;&lt; len &lt;&lt; endl;</code></pre><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">LC.718 最长重复子数组（中等）</a></p><p>LIS + LCS的混合定义，和下边的LCS问题一起参考</p><h2 id="LCS问题"><a href="#LCS问题" class="headerlink" title="LCS问题"></a>LCS问题</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>一般两个序列的匹配问题可以考虑是不是LCS问题。这里<code>f[i][j]</code>的定义是匹配到A序列的第i个字符和B序列的第j个字符位置时，最长公共子序列的长度。如此定义不需要考虑是否当前最后一位被选择，因为如果最后一位字符两个序列不相同，则最长就是再之前的匹配结果<code>f[i - 1][j]</code>和<code>f[i][j - 1]</code>中的最大值。这里没有连续性的要求。</p><h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">//下方例题1#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1010;char a[N], b[N];int f[N][N];int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;    cin &gt;&gt; a + 1 &gt;&gt; b + 1;    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= m; j ++ )            if (a[i] == b[j]) f[i][j] = f[i - 1][j - 1] + 1;            else f[i][j] = max(f[i - 1][j], f[i][j - 1]);    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}//下方例题2int dp[510][510];class Solution {public:    int maxDotProduct(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {        //dp[i][j]表示考虑A[i]和B[j]时的最大值，A[i]和B[j]要么都选，要么都不选        int n = A.size(), m = B.size();        memset(dp, -0x3f, sizeof dp);        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= m; j ++ )            {                dp[i][j] = A[i - 1] * B[j - 1];                dp[i][j] = max({dp[i][j], dp[i - 1][j - 1] + A[i - 1] * B[j - 1], dp[i - 1][j], dp[i][j - 1]});            }        return dp[n][m];    }};</code></pre><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.acwing.com/problem/content/description/899/" target="_blank" rel="noopener">AW.899 最长公共子序列（简单）</a></p><p><a href="https://leetcode-cn.com/problems/max-dot-product-of-two-subsequences/" target="_blank" rel="noopener">LC.1458 两个子序列的最大点积（困难）</a></p>]]></content>
    
    <summary type="html">
    
      动态规划其他DP
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
