{"meta":{"title":"天の痕的博客","subtitle":null,"description":"欢迎~","author":"天の痕","url":""},"pages":[{"title":"bangumi","date":"2020-06-02T13:32:48.000Z","updated":"2020-06-02T12:52:12.141Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2020-06-02T14:14:36.000Z","updated":"2020-06-03T10:10:38.223Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくらと天痕] 与&nbsp; 天痕 （ ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2020-06-02T15:13:48.000Z","updated":"2020-06-04T06:31:24.354Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2020-06-02T15:13:05.000Z","updated":"2020-06-03T09:25:26.875Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"links","date":"2020-06-02T15:11:06.000Z","updated":"2020-06-02T12:54:45.292Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2020-06-02T15:14:28.000Z","updated":"2020-06-02T14:07:28.172Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-06-04T03:30:51.633Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"KMP算法","slug":"KMP算法","date":"2020-06-04T06:26:01.000Z","updated":"2020-06-04T06:27:39.800Z","comments":true,"path":"2020/06/04/KMP算法/","link":"","permalink":"/2020/06/04/KMP算法/","excerpt":"","text":"KMP算法算法原理&emsp;&emsp;KMP算法核心是ne数组，其定义是：从0到第i个模板串字符的子串为止，子串中前缀和后缀相等的最大长度，其中前缀和后缀不包括子串本身。 &emsp;&emsp;对于字符串ababab，ne[0]总是0的原因是空串最长前缀也是0。ne[1] = 0的原因是长度为1的子串前缀如果不包括子串本身，也只有长度为0的空串。ne[2] = 0，(ab)abab此时子串ab的前缀没有和后缀相等的可能性。ne[3] = 1，(aba)bab的前缀可以看到0号a和3号a相等。ne[4] = 2，(abab)ab的前缀可以看到ab和ab相等，这里由于只增加了一个字母，且当前最长前缀用到了长度为3子串时的最长前缀，所以不可能最长前缀长度增加2。ne[5] = 3，(ababa)b，可以看到aba和aba相等。ne[6] = 4。 &emsp;&emsp;通过ne数组的定义，我们可以知道，当两个字符不匹配的时候，此时匹配位置就不必向后错一个位置继续从头匹配，而是从下一个前缀已经匹配完全的位置开始。 &emsp;&emsp;这里通过将开始下标设置为1，之前定义的ne数组是前后缀的最大长度，正好也是当不匹配时，模板串应该移动到的下标位置。 &emsp;&emsp;KMP算法求模板串ne数组的方法实际上是一种动态规划。每次使用了之前模板串中相同的长度，并且每次最长前缀最多+1，来计算下一次的最长前缀。 &emsp;&emsp;当无法匹配的时候，正好通过定义j = ne[j]来跳到最大匹配位置继续。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"二分查找","slug":"二分查找","date":"2020-06-04T06:26:01.000Z","updated":"2020-06-04T06:27:23.602Z","comments":true,"path":"2020/06/04/二分查找/","link":"","permalink":"/2020/06/04/二分查找/","excerpt":"","text":"二分二分查找元素&emsp;&emsp;就使用以下万能模板，本质是将问题抽象化为找一个分界面，分界面左边不满足某一性质，而右边满足某一个性质，这时候左边边界缩减时需要多缩减一个，右边边界缩减到当前mid即可。当搜素结束时，左右边界重合，即l == r。如果有l = mid的情况，需要l + r + 1 &gt;&gt; 1才能够避免到最后两个数相邻时，mid永远更新为左边界的死循环。 while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; } 二分搜索答案&emsp;&emsp;二分搜索答案的套路是当某一个问题验证某一个答案正确或者计算某一个阈值下的答案的时间复杂度乘以二分区间范围的log时，可以考虑搜索答案。一般都是整数答案，浮点数想直接二分搜索答案比较困难，因为在精度比较高的情况下，二分次数会比较多。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"动态规划（一）背包专题","slug":"动态规划（一）背包专题","date":"2020-06-04T06:26:01.000Z","updated":"2020-06-04T06:27:30.128Z","comments":true,"path":"2020/06/04/动态规划（一）背包专题/","link":"","permalink":"/2020/06/04/动态规划（一）背包专题/","excerpt":"","text":"背包专题01背包&emsp;&emsp;dp[i][j]表示考虑到第i个元素时，背包容量为j的情况下的最大价值。 $$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]])$$表示当前状态由前一个状态拿当前物品i或者不拿物品i转移。 一维形式循环顺序要从m到v[i]，原因是省略了i - 1维度。 for (int i = 01; i &lt;= n; i ++ ) for (int j = m; j &gt;= v[i];j -- ) f[j] = max(f[j], f[j - v[i]] + w[i]); 完全背包$$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i], … , dp[i - 1][j - s v[i]] + s w[i]);$$ 如果直接循环则需要3重循环来实现，但是我们发现上述部分项已经计算过了。$$dp[i][j - v[i]] = max(dp[i - 1][j - v[i]] + w[i], dp[i - 1][j - 2 v[i]] + 2 w[i] , … , dp[i - 1][j - s v[i]] + s w[i]);$$所以dp[i][j]可以进行简化为：$$dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]]);$$如果化简为一维形式，由于需要比较的是dp[i][j - v[i]]和01背包对应的，应该体积从小到大循环。 for (int i = 1; i &lt;= n; i ++ ) for (int j = v[i]; j &lt;= m; j ++ ) f[j] = max(f[j], f[j - v[i]] + w[i]);","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"图论算法","slug":"图论算法","date":"2020-06-04T06:26:01.000Z","updated":"2020-06-04T06:27:02.842Z","comments":true,"path":"2020/06/04/图论算法/","link":"","permalink":"/2020/06/04/图论算法/","excerpt":"","text":"图论算法最短路径算法Floyd&emsp;&emsp;使用邻接矩阵存储图更为合理，因为floyd算法要求每两个点之间的最短路径。循环顺序是kij其中k是阶段，从ik到kj点的最短路径由松弛操作$$g[i][j] = min(g[i][j], g[i][k] + g[k][j])$$给出。当有重边和自环时，每两个点之间存储的g[i][j]只存储最短的一条即可。 总结：图论算法主要包括几部分，有最短路径、最小生成树。下图可以比较清楚地将最短路径算法分类。 Dijkstra&emsp;&emsp;使用dist数组来维护所有点到源点的最短距离，用st数组维护已经确定最短距离的点。st数组一定要从空集开始，这样才能更新1号点。从所有点中选择距离源点最近的点来更新，将其所有临接点到源点的最短距离更新。最终更新了n个点后，所有点到达最短距离。时间复杂度为O(n^2)。 堆优化的Dijkstra&emsp;&emsp;维护一个堆，堆中储存一对信息（距离源点距离，当前点序号），从而每次得到距离源点最近的点的编号，扩展所有邻接点。这里不能保证每个点只入堆一次，因此当第一次从堆出来以后，再出来的就是错误的更新点，因此continue。时间复杂度因为有堆进行优化，所以是O(nlogn)。 Bellman Ford&emsp;&emsp;可以求解不超过k条边的最短路径，通过k次循环，每次备份dist数组，每次遍历所有的边，通过上次dist数组更新本次dist数组，可以求取负边权的情况。时间复杂度是O(km)，因为每次经过k次迭代，每次迭代m条边。 SPFA&emsp;&emsp;SPFA算法是队列优化的Bellman Ford算法，由于Bellman Ford算法需要k次更新所有的边，但是其中某些边在没有最短路径涉及时不需要更新。SPFA算法通过维护队列，将每次被更新的点加入队列，每次只更新队列内部的点，这样就减少了很多不必要点的更新操作。队列里是所有被更新过的点，因此可以维护st数组，当某个点被多个点更新时，就不用重复进入队列作为一下步扩展更新了。时间复杂度是O(nm)，但是实际上会比这个复杂度快很多。 SPFA判断负环&emsp;&emsp;SPFA算法当队列不空的时候就会不断的更新图中路径的最短值，每次更新相当于多走一条边，当有负环的时候，某些节点一定会被无限次更新到负无穷，因此用cnt数组来记录每一个点的被更新次数，当某个点更新次数大于n – 1时，说明存在一条路径当我更新n – 1次之后，还可以更小，这样就是存在负环了。开始时一定要把所有点都加入到队列中，否则只更新某一个点，也许去其他点的路径可以不经过负环，也就不会无限更新，就找不到负环来判断。 最小生成树算法Prim&emsp;&emsp;用st数组维护一个集合，最开始为空，每次扩充一个距离当前集合最近的点进入集合，并且更新其他点到集合的最近距离。所有点到集合的初始最近距离为INF，将所有点均加入到集合时算法结束。如果某一次扩充的点到集合的最近距离为正无穷，则说明不存在最小生成树。 Kruskal&emsp;&emsp;通过排序得到所有边的序列，从最小的边开始扩展，贪心的思路。维护一个并查集来确定两个点是否属于同一个集合，如果属于同一个集合的两个点还需要增加一条边，则该条边增加后则成环。因此维护一个计数器cnt，当算法结束之后，cnt如果小于n – 1则说明不存在有效的生成树，否则并查集维护的点就是当前生成树。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"单调栈与单调队列","slug":"单调栈与单调队列","date":"2020-06-04T06:26:01.000Z","updated":"2020-06-04T06:27:35.045Z","comments":true,"path":"2020/06/04/单调栈与单调队列/","link":"","permalink":"/2020/06/04/单调栈与单调队列/","excerpt":"","text":"单调栈与单调队列单调栈&emsp;&emsp;单调栈使用范围比较小，已知有两种用法。 &emsp;&emsp;第一种，寻找数组中某一个数左边、右边第一个比它大、小的数。如果要寻找数列中每一个数左边比他小的数，那么有一个性质就是当a b c序列时，如果b小于a，则c的左边更小的数，是无论如何也不可能是a的。因此如果使用一个栈来存储所有的可能的数，则只需要存储比a大的数即可，因此是单调递增栈。栈的特点是后进先出，在这里其实利用了“后”即“最近”的思想，而单调性能够确保与栈顶比较时，相当于比较了所有之前的数据，降低了时间复杂度。 &emsp;&emsp;第二种，寻找数组中两个数之间满足i &lt; j 且 A[i] &lt;= A[j]的情况下，下标之间的最大距离。这种可以看做全局的单调性和“最近”性质的应用。方法是从左向右初始化单调递减栈，之后从右向左每次元素和栈顶元素比较，利用单调性，可以得到如果当前元素小于栈顶（最小值），则其他元素均不满足A[i] &lt;= A[j]的要求；如果当前元素大于栈顶，则栈顶元素右边的元素最大距离一定更小，因此栈顶元素右边的元素不做考虑，同时通过出栈每次确认当前最小的元素是否更新了答案，直到栈顶元素大于当前遍历元素。出栈的原因是，右侧当前元素每次都在减少，因此贪心的认为，之后即便有满足要求的元素，也不会更新最大距离。 单调队列&emsp;&emsp;单调队列是队头维护的是整个队列中最大或者最小的元素，每次有新元素入队时，如果不满足当前队列维护的单调性，则将所有不满足的元素全部出队。单调队列本质是一个双端队列，每次出队时是从队尾出队，而不是从队头出队。 &emsp;&emsp;单调队列操作顺序也比较重要，在不同需要的时候有不同的操作顺序。 计算是否当前元素和队头元素距离之差大于规定值，如果大于则队头出队。 计算答案，此时是计算的[0, r - 1]范围内的最值，因此放在第二步。 保持队列单调性，while循环从队尾出队。 将当前元素入队。 *若计算答案在这里，则是求的[0, r]范围内的最值。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"离散化","slug":"离散化","date":"2020-06-04T06:26:01.000Z","updated":"2020-06-04T06:27:12.803Z","comments":true,"path":"2020/06/04/离散化/","link":"","permalink":"/2020/06/04/离散化/","excerpt":"","text":"离散化通过哈希表进行离散化&emsp;&emsp;建立一个哈希表，通过每次将新的值映射为一个递增的n来达到离散化的目的。这种离散化不要求顺序，只需要值的对应即可。 int find(int x) { if (S.count(x) == 0) S[x] = ++ n; return S[x]; } 排序+去重+二分查找进行离散化&emsp;&emsp;当要求有序的离散化时，需要将需要离散化的坐标排序，之后去重，最后使用二分查找来通过下标映射的递增值为多少。 int find(int x) { int l = 0, r = n - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (a[mid] &gt;= x) r = mid; else l = mid + 1; } return r; } //排序+去重 sort(pts.begin(), pts.end()); pts.erase(unique(pts.begin(), pts.end()), pts.end());","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"数据结构","slug":"高级数据结构","date":"2020-06-04T06:26:01.000Z","updated":"2020-06-04T06:27:18.497Z","comments":true,"path":"2020/06/04/高级数据结构/","link":"","permalink":"/2020/06/04/高级数据结构/","excerpt":"","text":"数据结构并查集&emsp;&emsp;并查集重点在于通过集合维护什么额外信息来解决问题。额外信息可以是集合内元素数量、当前元素和根节点的距离。当前元素和根节点的距离可以用来维护多个相互关系。 树状数组&emsp;&emsp;树状数组能够以logn的时间复杂度计算前缀和并且单点修改某一位置的值。 堆&emsp;&emsp;在动态的求中位数时，可以用对顶堆，上边是一个小根堆，下边是一个大根堆，用来维护中位数在中间。 Trie树&emsp;&emsp;Trie树又叫字典树，可以快速插入和查询某一字符串是否在当前集合之中。限制条件是当前字符集合所有字符总数不能太大，否则效率低下且耗费空间。 &emsp;&emsp;这里存储树是通过son[N][26]类型的二维数组来存储，本质是一个单向查询函数，其中son的第一个维度为当前指针地址，用idx从0开始分配。树根被分配为0，之后依次分配地址递增。第二个维度26是当前确定的字符，当确定了当前节点和当前字符之后，就确定了son中存储值，即下一个节点的地址。通过这种逻辑来用数组存储树和图是一种较为方便和快捷的方法。 &emsp;&emsp;AC自动机是Trie树和KMP算法的结合，通过KMP算法的ne数组在Trie树上进行匹配，完成多个模板串在某一原串中出现次数的统计。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"生活","slug":"生活","date":"2020-06-01T14:16:01.000Z","updated":"2020-06-04T06:30:41.296Z","comments":true,"path":"2020/06/01/生活/","link":"","permalink":"/2020/06/01/生活/","excerpt":"","text":"生活近期更新，敬请期待~","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"随笔","slug":"随笔","date":"2020-06-01T14:16:01.000Z","updated":"2020-06-04T06:30:32.191Z","comments":true,"path":"2020/06/01/随笔/","link":"","permalink":"/2020/06/01/随笔/","excerpt":"","text":"随笔近期更新，敬请期待~","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"读书笔记","slug":"读书","date":"2020-06-01T14:16:01.000Z","updated":"2020-06-04T06:30:48.012Z","comments":true,"path":"2020/06/01/读书/","link":"","permalink":"/2020/06/01/读书/","excerpt":"","text":"读书笔记近期更新，敬请期待~","categories":[{"name":"读书","slug":"读书","permalink":"/categories/读书/"}],"tags":[],"keywords":[{"name":"读书","slug":"读书","permalink":"/categories/读书/"}]}]}