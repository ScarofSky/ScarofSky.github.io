{"meta":{"title":"天の痕的博客","subtitle":null,"description":"欢迎~","author":"天の痕","url":""},"pages":[{"title":"bangumi","date":"2020-06-02T13:32:48.000Z","updated":"2020-07-02T14:04:55.155Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2020-06-02T15:13:48.000Z","updated":"2020-06-04T06:31:24.354Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2020-06-02T15:13:05.000Z","updated":"2020-06-03T09:25:26.875Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"music","date":"2020-06-02T15:14:28.000Z","updated":"2020-06-02T14:07:28.172Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"about","date":"2020-06-02T14:14:36.000Z","updated":"2020-06-15T13:21:57.571Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[天痕の轨迹线] 与&nbsp; 天痕 （ ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-06-04T03:30:51.633Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"links","date":"2020-06-02T15:11:06.000Z","updated":"2020-06-15T08:49:31.321Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"}],"posts":[{"title":"线段树","slug":"线段树","date":"2020-07-17T07:20:12.000Z","updated":"2020-07-17T14:34:44.714Z","comments":true,"path":"2020/07/17/线段树/","link":"","permalink":"/2020/07/17/线段树/","excerpt":"","text":"线段树线段树原理将一个区间和其所有不重叠的子区间分别存储到数组中，形成一个满二叉树，并且在线段树中每一个节点维护当前区间的值。 当某一个节点进行修改之后，需要修改当前节点和所有父节点。 当修改的是一个区间的值时，需要维护懒标记。懒标记代表当前节点的所有子节点应该加上的值，每次pushdown操作是将当前节点的懒标记推送到了子节点，并且将上次的操作真正的实际写到节点中。比如modify操作，pushdown之后所有子节点的值已经落实了修改，递归之后值完全正确，这时也要pushup更新父节点的值。总结上讲，当build和modify操作结束时，需要用pushup来更新当前节点值。当modify和query开始时，必须保证当前节点的值已经正确，因此需要用pushdown操作。 当查询某一个区间内的值时，只需要将包含在该区间内的所有最大区间的值进行计算即可得出，这一点和树状数组思想一致。 因此线段树可以进行单点和区间修改，区间查询。修改和查询的时间复杂度为O(logn)。 模板//需要开4倍空间，最多有4n - 1个节点存在。 struct Node { int l, r; int v; }tr[N * 4]; //pushup操作，用子节点的信息计算父节点 void pushup(int u) { tr[u].v = max(tr[u &lt;&lt; 1].v, tr[u &lt;&lt; 1 | 1].v); } //可以对pushup再加一层封装，这样可以计算任意Node void pushup(int u) {pushup(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);} void pushup(Node&amp; u, Node&amp; l, Node&amp; r) { u.sum = l.sum + r.sum; u.lsum = max(l.lsum, l.sum + r.lsum); u.rsum = max(r.rsum, r.sum + l.rsum); u.tsum = max({l.rsum + r.lsum, l.tsum, r.tsum}); } //build操作，建立线段树，确定每个节点维护的区间 void build(int u, int l, int r) { tr[u] = {l, r}; if (l == r) return; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); } //单点修改操作，修改某一个叶子节点的值 void modify(int u, int x, int v) { if (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u].v = v; else { int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (x &lt;= mid) modify(u &lt;&lt; 1, x, v); else modify(u &lt;&lt; 1 | 1, x, v); //修改完子节点之后，要更新父节点的值 pushup(u); } } //查找操作，查找某个区间内的最大值 int query(int u, int l, int r) { //如果当前树节点被查询区间包含了，不用再递归了 if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].v; int ret = 0; //否则找到树节点区间中点（因为要继续向下看看哪个区间能完全被包含） int mid = tr[u].l + tr[u].r &gt;&gt; 1; //如果l在mid左边，则说明向下一层的节点中有部分在当前查找区间中，递归 if (l &lt;= mid) ret = query(u &lt;&lt; 1, l, r); //如果r在mid右边，也是需要再向下查找 if (r &gt; mid) ret = max(ret, query(u &lt;&lt; 1 | 1, l, r)); return ret; } //懒标记的pushdown操作 void pushdown(int u) { auto &amp;root = tr[u], &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1]; if (root.add) { left.add += root.add, left.sum += (left.r - left.l + 1) * root.add; right.add += root.add, right.sum += (right.r - right.l + 1) * root.add; root.add = 0; } } //使用懒标记修改区间的值 void modify(int u, int l, int r, int d) { if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) { tr[u].sum += (tr[u].r - tr[u].l + 1) * d; tr[u].add += d; } else { //开始之前保证当前u节点如果带有懒标记，一定计算完毕子节点，且将懒标记传递给子节点 pushdown(u); int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, d); if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r d); //最后结束的时候要更新当前节点值 pushup(u); } } 例题AW.1275 最大数（中等） AW.245 你能回答这些问题吗（简单） AW.243 一个简单的整数问题2（困难）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"二分查找","slug":"二分查找","date":"2020-07-16T13:41:30.000Z","updated":"2020-07-16T07:45:10.103Z","comments":true,"path":"2020/07/16/二分查找/","link":"","permalink":"/2020/07/16/二分查找/","excerpt":"","text":"二分二分查找元素原理&emsp;&emsp;二分使用的条件是有单调性，比如有序的序列，事实上二分是分治算法思想。本质是将问题抽象化为找一个分界面，分界面左边不满足某一性质，而右边满足某一个性质。这时候左边边界缩减时需要多缩减一个，因为左边不满足性质；右边边界缩减到当前mid，不用多缩减。下边代码的check函数即是满足某种性质的判断函数，当满足性质时返回 true, 不满足时返回false。 &emsp;&emsp;当搜素结束时，左右边界重合，即l == r。如果有l = mid的情况，需要l + r + 1 &gt;&gt; 1才能够避免最后两个数相邻时，mid永远更新为左边界的死循环。 &emsp;&emsp;二分查找分为整数二分和浮点数二分，浮点数查找时原理相同，但是要求精度小于一定数时停止。浮点数二分比整数二分容易很多，不需要考虑很多边界条件的情况。 模板//每次右边界缩减为mid的情况 while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; } //每次左边界缩减为mid的情况 while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid + 1; } //例子：求一个有序序列中的左右边界 //1 【2 2 2】 3 3 // ↑ ↑ // ① ② while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (a[mid] &gt;= x) r = mid; else l = mid + 1; } while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (a[mid] &lt;= x) l = mid; else r = mid - 1; } //浮点数二分 const double eps = 1e-8; while (r - l &gt; eps) { int mid = l + r / 2.0; if (check(mid)) l = mid; else r = mid; } 例题LC.704 二分查找（简单） AW.790 数的三次方根（简单） AW.789 数的范围（简单） LC.209 长度最小的子数组（中等） 构造单调性+二分查找，重点在于单调性的构造 二分搜索答案原理&emsp;&emsp;答案很多时候是有范围的，当某一个问题验证某一个答案的时间复杂度乘以二分区间范围的log时，可以考虑搜索答案。通过不断的尝试排除错误答案，且是以指数速度排除，最终得到正确答案。这里一般在验证答案的时候，可以采用某种程度的贪心策略，并且将原问题中单调性质进行转化，能够通过一次的验证缩小答案范围。 &emsp;&emsp;这类题往往不是简单的搜索答案，而是将问题某种程度的转化之后，再搜索答案。 例题AW.102 最佳牛围栏（简单） LC.287 寻找重复数（中等） LC.5438 制作m束花所需最少天数（中等）(193周赛第三题） LC.1300 转变数组后最接近目标值的数组和（中等）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"单调栈与单调队列","slug":"单调栈与单调队列","date":"2020-07-15T14:58:03.000Z","updated":"2020-07-15T09:57:08.108Z","comments":true,"path":"2020/07/15/单调栈与单调队列/","link":"","permalink":"/2020/07/15/单调栈与单调队列/","excerpt":"","text":"单调栈与单调队列单调栈原理&emsp;&emsp;单调栈使用范围比较小，已知有两种用法，其中第一种用法比较经典，用的较多，第二种用法出现较少。 寻找数组中某一个数左边、右边第一个比它大或小的数。首先要找到最近的一个数，并且满足这个数和当前数的单调关系（比它大或者小）。栈的特点是后进先出，在这里其实利用了栈“最近”的思想，而单调性能够确保与栈顶比较时，相当于比较了所有之前的数据，降低了时间复杂度。 &emsp;&emsp;Condition 1 ：以寻找数列中每一个数左边第一个比它小的数为例，如果使用单调递增栈，当前元素大于栈顶元素，则相当于大于栈中所有元素，当前元素左侧第一个比它小的数就是栈顶元素； &emsp;&emsp;Condition 2 ：如果当前元素小于栈顶元素，那么当前元素左侧比当前元素还大的那些元素（即已经在栈中）就永远不需要考虑了（我要找的是更小的！），并且可以在这个过程中直接出栈。原因是，这些出栈的元素在更靠后的元素考虑时，肯定不会是答案，因为使得这个元素出栈的元素，会距离更近且更小，具体看下图会更加清晰。可以看到，4号元素在找左侧更小的元素时，一定不会找到2号元素，因为3号元素一定更早被选择。 寻找数组中两个数之间满足i &lt; j 且 A[i] &lt;= A[j]的情况下，下标之间的最大距离。这种可以看做全局的单调性和“最近”性质的应用，并且还有双指针的思想。这里有个重点是，当从右向左考虑元素时，只需要考虑当前元素左侧是否会产生最大值，不用考虑右侧的情况，因为右侧已经考虑过了。首先从左向右初始化单调递减栈，之后从右向左每次元素和栈顶元素比较，通过出栈每次确认当前最小的元素是否更新了答案，直到栈顶元素大于当前遍历元素： &emsp;&emsp;Condition 1 ：如果当前元素小于栈顶（当前最小值），则栈内其他元素均不满足A[i] &lt;= A[j]的要求，更进一步说明栈顶元素左侧所有元素均无法产生答案；栈顶右侧元素一定已经和当前元素右侧的元素更新过答案（因此才被弹出栈），所以再和当前元素产生的答案，肯定无法更新答案（从右向左，每次都在递减）。 &emsp;&emsp;Condition 2 ：如果当前元素大于栈顶，由于栈顶元素右边的元素更靠近序列右侧，所以最大距离一定更小，即便和当前元素能产生正确大小关系，也不会更新答案。之后我们无法确定左侧元素是否还能继续产生更大答案，所以栈顶元素出栈，继续比较。能够安全出栈的原因是，右侧当前元素每次都在减少，因此贪心的认为，之后即便有满足要求的元素，也不会更新最大距离（与第一种情况的栈顶右侧元素一致）。 &emsp;&emsp;假设序列是 A B C D E F G H，从左到右入递减栈的是A B D，那么假设当前元素为G： 如果G &gt;= D，D出栈，考虑B，如果G &gt;= B, 即使G &gt;= C没有产生更大答案，如果G &lt; B，因为从左到右是单调栈，因此C &gt; B, 若G &gt; C，可以推导出C &lt; G &lt; B, B &gt; C，冲突，所以不用考虑G &gt; C的情况。 如果G &lt; D, 比最小值还小，那么栈顶元素左侧没有可以满足条件的情况；而右侧E F即便有更小，也无法更新答案。 模板//寻找数组中某一个数左边第一个比他大的数 for (int i = 0; i &lt; n; i ++ ) { while (!st.size() &amp;&amp; s[i] &gt;= st.top()) st.pop(); if (st.size()) cout &lt;&lt; st.top() &lt;&lt; &quot; &quot;; else cout &lt;&lt; &quot;-1 &quot;; st.push(s[i]); } //寻找i &lt; j 且 A[i] &lt; A[j]条件的最大j - i stack&lt;int&gt; st; int n = A.size(); for (int i = 0; i &lt; n; i ++ ) if (st.empty() || A[i] &lt; A[st.top()]) st.push(i); int ans = 0; for (int i = n - 1; i &gt;= 0; i -- ) { while (st.size() &amp;&amp; A[i] &gt;= A[st.top()]) { ans = max(ans, i - st.top()); st.pop(); } if (!st.size()) break; } return ans; 例题AW.830 单调栈（简单） LC.739 每日问题（中等） LC.42 接雨水（困难） LC.84 柱状图中最大的矩形（困难） LC.962 最大宽度坡（中等） 单调队列原理&emsp;&emsp;单调队列是队头维护的是整个队列中最大或者最小的元素，每次有新元素入队时，如果不满足当前队列维护的单调性，则将所有不满足的元素全部出队。单调队列本质是一个双端队列，每次出队时是从队尾出队，而不是从队头出队。单调队列可以解决滑动窗口的最值问题，以及与之相关的优化。 &emsp;&emsp;单调队列操作顺序也比较重要，在不同需要的时候有不同的操作顺序。 计算是否当前元素和队头元素距离之差大于规定值，如果大于则队头出队。 计算答案，此时是计算的[0, r - 1]范围内的最值，因此放在第二步。 保持队列单调性，while循环从队尾出队。 将当前元素入队。 *若计算答案在这里，则是求的[0, r]范围内的最值。 模板//k是窗口大小, 计算最大值, 手动模拟队列 int q[N]; int hh = 0, tt = -1; for (int i = 0; i &lt; n; i ++ ) { //如果下标是不连续的，这里要写while，因为这里每次最多下标+1所以可以写if if (hh &lt;= tt &amp;&amp; i - q[hh] + 1 &gt; k) hh ++ ; //这里大于等于和大于都能过，但是推荐写大于等于，当相等的时候，每次只保留最新的一个即可 while (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) tt -- ; q[ ++ tt ] = i; //这里事实上求的[0, i]范围的最值 if (i &gt;= k - 1) cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;; } //stl版本 deque&lt;int&gt; q; for (int i = 0; i &lt; n; i ++ ) { if (q.size() &amp;&amp; i - q.front() + 1 &gt; k) q.pop_front(); //这里求的是[0, i - 1]的最值 if (i &gt;= k - 1) cout &lt;&lt; a[q.front()] &lt;&lt; &quot; &quot;; while (q.size() &amp;&amp; a[i] &lt;= a[q.back()]) q.pop_back(); } 例题AW.154 滑动窗口（简单） LC.1499 满足不等式的最大值（困难）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"数据库","slug":"数据库","date":"2020-07-14T13:05:08.000Z","updated":"2020-07-17T14:36:06.256Z","comments":true,"path":"2020/07/14/数据库/","link":"","permalink":"/2020/07/14/数据库/","excerpt":"","text":"数据库知识事物的四个特性事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。ACID：原子性、一致性、隔离性、持久性。 A: 原子性（Atomicity)。原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 C:一致性（Consistency)。一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 I:隔离性（Isolation）。隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 D:持久性（Durability）。持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 脏读、幻读和不可重复读这几种情况在读取和写入数据库的时候会产生，事务虽然有原子性，但是读写的并发并不影响原子性，因此最终导致了以下的数据并发问题。解决这几种错误的数据库现象，需要了解数据库的事务隔离级别，下方有详细介绍。 脏读：事务A读取的事务B中尚未提交的数据，如果事务B回滚，则A读取使用了错误的数据。比如我给你转了100万，但是我还没有提交，此时你查询自己账户，多了100万，很开心。然后我发现转错人了，回滚了事物。然后你100万就没了。 在过程中你查到了没有提交事物的数据（多出的100万），这就是脏读。 不可重复读：指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值（这里主要指某一表项的修改），这是由于在查询间隔，被另一个事务修改并提交了。这里的不可重复读主要说的是数据库表的某一项，和幻读的区别在于幻读是数据库内表中的查询不一致。在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如同一个事物前后两次查询同一个数据，期望两次读的内容是一样的，但是因为读的过程中，因为另一个事务写了该数据，导致不可重复读。 幻读：在事务A的多次读取构成中，事务B对数据（这里主要指的是表内的插入操作）进行了新增操作，导致事务A多次读取的数据不一样，好像出现了幻觉一样。不可重复度是表项的update操作，幻读是对表内的insert操作。比如第一次读取表内是10个查询结果，在第二次查询之前，另一个事务加了一条（因为不是对同一个数据项写入，不是不可重复读），这时再次查询就变成了11个，不一致了。 第一类事务丢失（回滚丢失）：A和B在同时写一个数据，B事务已经提交，修改了数据，然后A事务因为某种原因回滚了，导致B事务的提交因A事务的回滚而丢失了。举例子来说，比如我有1000元。买一个东西，花了100元。然后我朋友给我转了1000元。理论上这两个事物（转账和买东西）正常的话，我应该还有1900元。 但是现在两个事物A和B同时进行，第一步都先查询我余额还有1000元，然后B事物给我转了1000元，提交了，理论上我还有2000元。然后我买东西，100元的，买到一半，我事物回滚，就回滚成了1000元(少了1000）。如果我不回滚，也提交了，我就还剩900元（也就是下面介绍的第二类事物丢失，覆盖丢失，也是少了1000）。 第二类事务丢失（提交覆盖丢失）：A和B同时执行事务，两个事务同时取到一个数据，B事务首先提交，但是A事务接下来又提交，这样就覆盖了B事务。 CSDN.数据库ACID四大特性及脏读，不可重复读，幻读，事物丢失 CSDN.对数据库幻读的理解 CSDN.数据库第一类第二类丢失更新 数据库的事务隔离级别事务的隔离级别实际上就是用锁来处理并发操作中，对于数据读写之后的不一致情况。下方的加锁的等级从低到高，而且加锁越多，数据库的效率越低，因为如果串行化就没有并发了。 未提交读（Read uncommitted)。写操作加锁，读操作不加锁，禁止第一类丢失更新，但是其他数据并发问题还会发生。 提交读（Read committed)。写操作加写锁，读操作加读锁。禁止第一类丢失更新和脏读。指你已经开始读了数据，然后一个事物开始写，然后写的事物不提交的话，是不能进行读的事物，避免了脏读。 可重复读（Read repeatable)。对于读操作加读锁到事务结束，其他事务的更新操作只能等到事务结束之后进行。和提交 读的区别在于，提交读的读操作是加读锁到本次读操作结束，可重复读的锁粒度更大。禁止两类丢失更新，禁止脏读和不可 重复度，但是可能出现幻读.一个事物读的时候，我们把两次读看成整体，在读的过程中，不允许写的操作，这样就可以禁止不可重复读。就是两次读操作不允许其他事物。这是大部分关系数据库的默认隔离级别。 序列化（Serializable)。对表级读和写加锁。读操作加表级读锁至事务结束。可以禁止幻读。 好好看看下边的博客，里面图片比较容易理解。 Blog.ZhuoQiLin 数据库的四大特性以及四个隔离级别和引发的问题","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"有向图的强联通分量","slug":"有向图的强联通分量","date":"2020-07-14T06:44:08.000Z","updated":"2020-07-17T14:39:27.736Z","comments":true,"path":"2020/07/14/有向图的强联通分量/","link":"","permalink":"/2020/07/14/有向图的强联通分量/","excerpt":"","text":"有向图的强联通分量Tarjan算法原理Tarjan算法通过对于有向图的dfs，将图看成一颗树的形式，并且把树中的边分为四类： 树枝边：树中从a到b在dfs中相邻的边。 前向边：树中在dfs过程中，从祖先某个节点连接到未来某个节点的边。其中树枝边是前向边的特例。 后向边：从当前dfs遍历的节点连接回dfs路径上某个点的边。 横插边：从当前dfs遍历的节点连接回某个祖先节点的边。 在遍历的过程中，用dfn数组记录第一次遍历到时的时间戳，用low数组记录当前节点可以走到的最早的祖先节点的时间戳，这样如果dfn[u] == low[u]表示当前节点是遍历的当前强联通分量的最早的节点，因此将栈中记录的所有点进行回溯，放到同一个联通分量中。 一般来说Tarjan算法求完强联通分量之后，都会进行缩点操作，然后进行拓扑图上的拓扑顺序的遍历。当求完所有强联通分量之后，scc_cnt递减的顺序就是当前拓扑图的拓扑遍历顺序，不用再写拓扑排序进行遍历。 模板void tarjan(int u) { dfn[u] = low[u] = ++ timestamp; stk[ ++ top ] = u, in_stk[u] = true; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (!dfn[j]) { tarjan(j); low[u] = min(low[u], low[j]); } else if (in_stk[j]) low[u] = min(low[u], dfn[j]); } if (dfn[u] == low[u]) { int y; ++ scc_cnt; do { y = stk[top -- ]; in_stk[y] = false; id[y] = scc_cnt; sz[scc_cnt] ++ ; } } } 例题AW.1174 最受欢迎的牛（中等）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Trie树","slug":"Trie树","date":"2020-07-14T06:41:01.000Z","updated":"2020-07-17T14:38:09.976Z","comments":true,"path":"2020/07/14/Trie树/","link":"","permalink":"/2020/07/14/Trie树/","excerpt":"","text":"Trie树原理&emsp;&emsp;Trie树又叫字典树，可以快速插入和查询某一字符串是否在当前集合之中。限制条件是当前字符集合所有字符总数不能太大，否则效率低下且耗费空间。 &emsp;&emsp;这里存储树是通过son[N][26]类型的二维数组来存储，本质是一个单向查询函数，其中son的第一个维度为当前指针地址，用idx从0开始分配。树根被分配为0，之后依次分配地址递增。第二个维度26是当前确定的字符，当确定了当前节点和当前字符之后，就确定了son中存储值，即下一个节点的地址。通过这种逻辑来用数组存储树和图是一种较为方便和快捷的方法。 &emsp;&emsp;AC自动机是Trie树和KMP算法的结合，通过KMP算法的ne数组在Trie树上进行匹配，完成多个模板串在某一原串中出现次数的统计。 模板#include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int N = 100010; int son[N * 32][2]; int val[N * 32]; int idx; int n; void build(int x) { int p = 0; for (int i = 31; i &gt;= 0; i -- ) { int t = x &gt;&gt; i &amp; 1; if (!son[p][t]) son[p][t] = ++ idx; p = son[p][t]; } val[p] = x; } int query(int x) { int p = 0; for (int i = 31; i &gt;= 0; i -- ) { int t = x &gt;&gt; i &amp; 1; if (!son[p][!t]) p = son[p][t]; else p = son[p][!t]; } return x ^ val[p]; } int main() { scanf(&quot;%d&quot;, &amp;n); int res = 0; for (int i = 0; i &lt; n; i ++ ) { int t; scanf(&quot;%d&quot;, &amp;t); res = max(res, query(t)); build(t); } printf(&quot;%d\\n&quot;, res); return 0; } 例题AW.143 最大亦或对（简单）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"离散化","slug":"离散化","date":"2020-07-11T13:48:11.000Z","updated":"2020-07-11T13:48:10.809Z","comments":true,"path":"2020/07/11/离散化/","link":"","permalink":"/2020/07/11/离散化/","excerpt":"","text":"离散化通过哈希表进行离散化原理&emsp;&emsp;建立一个哈希表，通过每次将新的值映射为一个递增的n来达到离散化的目的。这种离散化不要求顺序，只需要值的对应即可。 模板int find(int x) { if (S.count(x) == 0) S[x] = ++ n; return S[x]; } 排序+去重+二分查找进行离散化原理&emsp;&emsp;当要求有序的离散化时，需要将需要离散化的坐标排序，之后去重，最后使用二分查找获得映射后的坐标。这里其实相当于将排序后的数组下标作为离散化后的值。这种离散化的好处就是保序，当计算原下标3-7之间的结果时，直接计算离散化之后find(3)-find(7) = 3 - 5之间的结果即可。 模板//通过find函数找到原值的对应下标，即离散化之后的值 int find(int x) { int l = 0, r = n - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (a[mid] &gt;= x) r = mid; else l = mid + 1; } return r; } //排序+去重 sort(pts.begin(), pts.end()); pts.erase(unique(pts.begin(), pts.end()), pts.end()); 例题AW.802 区间和（简单）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"树状数组","slug":"树状数组","date":"2020-07-11T13:48:04.000Z","updated":"2020-07-17T14:35:20.572Z","comments":true,"path":"2020/07/11/树状数组/","link":"","permalink":"/2020/07/11/树状数组/","excerpt":"","text":"树状数组树状数组原理树状数组可以在O(logn)的时间复杂度内计算前缀和。相比于前缀和数组和原数组，树状数组相当于两者进行了权衡。即满足单点修改，区间查询。使用差分数组可以使得树状数组在差分数组上计算，这样可以获得区间修改，单点查询的功能。 前缀和数组计算前缀和为O(1)，修改操作之后重新计算前缀和时间复杂度为O(n)。 原数组计算前缀和为O(n)，修改操作只需要O(1)的时间复杂度不用重新计算。 树状数组计算前缀和为O(logn)，修改操作重新计算数组的时间复杂度也为O(logn)。 树状数组的原理是将查询区间的右端点x（左端点一般为1）按照二进制展开，对于任一数字x都可以通过2的幂组合，从而快速的查询当前前缀和是多少。比如位置7的前缀和等于7 + 6 + 4位置数组之和，只需要log次操作就可以得到。 具体原理可以看下图： 在差分数组上建立树状数组，其中add操作和sum操作不变，但是由于是差分数组，对一个区间[l,r] + C相当于对差分数组add(l, c) &amp;&amp; add(r + 1, -c)。如果求某个位置上的数字，相当于sum(x)。 另外，树状数组还可以进行区间修改，区间和查询。需要推导一下公式，当然线段树也可以很好的完成这项操作。 模板int n;//和需要求前缀和的数组大小相等 //lowbit操作，得到当前数字二进制位的最后一个1 int lowbit(int x) { return x &amp; -x; } //add操作，在某一位置 + c之后，更新所有需要变化的树状数组位置 void add(int x, int c) { for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; } //sum操作，求某一个位置x的前缀和 int sum(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } //差分数组与树状数组结合 int main() { int l, r, c; cin &gt;&gt; l &gt;&gt; r &gt;&gt; c; add(l, c), add(r + 1, -c); int x; cin &gt;&gt; x; cout &lt;&lt; sum(x) &lt;&lt; endl; } 例题LC.1505 最多K次交换相邻数位后得到的最小整数（困难） AW.242 一个简单的整数问题（简单）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"动态规划（一）背包专题","slug":"动态规划（一）背包专题","date":"2020-07-08T07:26:40.000Z","updated":"2020-07-09T13:37:11.799Z","comments":true,"path":"2020/07/08/动态规划（一）背包专题/","link":"","permalink":"/2020/07/08/动态规划（一）背包专题/","excerpt":"","text":"背包专题01背包原理dp[i][j]表示考虑到第i个元素时，背包容量为j的情况下的最大价值。初始条件为dp[0][i] = 0，表示当考虑前0个物品时，无论背包容量为多少，最大价值都是0。状态转移方程可以通过定义得到，当前状态由前一个状态拿当前物品i或者不拿当前物品i转移过来。一维空间形式循环顺序要从m到v[i]，原因是省略了i - 1维度。 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]) dp[j] = max(dp[j], dp[j - v[i] + w[i]]), j ∈(m,v[i])模板for (int i = 1; i &lt;= n; i ++ ) for (int j = m; j &gt;= v[i];j -- ) f[j] = max(f[j], f[j - v[i]] + w[i]); 例题AW.2 01背包问题（简单） AW.278 数字组合（简单） 01背包求可能方案种数 完全背包原理如果按照01背包的状态定义和状态转移方程思维方式，我们不难得出如下的状态转移方程。 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i], ... , dp[i - 1][j - s * v[i]] + s * w[i]);如果直接循环则需要3重循环来实现，但是我们发现上述部分项已经计算过了。 dp[i][j - v[i]] + w[i] = max(dp[i - 1][j - v[i]] + w[i], dp[i - 1][j - 2 * v[i]] + 2 * w[i] , ... , dp[i - 1][j - s * v[i]] + s * w[i]);所以dp[i][j]可以进行简化为： dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]), j∈(v[i], m)如果化简为一维形式，由于需要简化的是dp[i][j - v[i]]，应该体积从小到大循环。这里可以优化的原因是，体积一定的情况下，如果可以随意拿取，那么拿取的s件一定是固定值，注意和下边的多重背包区分。 模板for (int i = 1; i &lt;= n; i ++ ) for (int j = v[i]; j &lt;= m; j ++ ) f[j] = max(f[j], f[j - v[i]] + w[i]); 例题AW. 完全背包问题（简单） AW.1021 货币系统（简单） 完全背包求可能方案种数 LC.322 零钱兑换（中等） 多重背包原理 多重背包问题可以使用三重循环直接暴力求解，也可以使用二进制优化。暴力求解和上述完全背包问题相似，在于每次要确定s个物品，这里无法进行完全背包的优化，因为每次求解的s并不是固定值。 二进制优化的原理是将多个物品打包成一个物品来看，将最多选s个物品的问题转化成log(s)个物品的 01背包问题，从而降低复杂度。可以证明每次选取1,2,4,8,16…(s- 2^k - 1)个物品打包之后，每个物品选与不选的组合（看做01背包）可以得到s种结果。这里二进制优化的思想很有意思，可以类比快速幂和龟速乘。时间复杂度为O(N logS M) 多重背包的终极优化方式是单调队列优化。在将多重背包的公式展开之后，类比完全背包可以发现对于f[i][j]的计算相当于是j之前s大小滑动窗口内极值的计算，因此可以用线性方法直接计算，将时间复杂度从O(ns)优化到O(n)，最终的整体时间复杂度为O(nm)。 多重背包的单调队列优化中，可以将背包体积展开成如下公式，其中公式二中的（s + 1）是因为本身体积为j - v但是还可以选择s个物品，因此最终剩下的体积就是j - (s + 1) * v。公式三种的r表示总体积对v取余之后的值，所以其实r = j % v，在代码中需要枚举所有的r，因为最终的余数可以是0到j % v的所有数，题目没有要求一定用完体积。 f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2 * v] + 2 * w, ... , f[i - 1][j - s * v] + s * w)①\\\\ f[i][j - v] = max(f[i - 1][j - v], f[i - 1][j - 2 * v] + w), f[i - 1][j - 3*v] + 2 * w, ... ,f[i - 1][j - (s + 1)* v] + s*w)②\\\\ ...\\\\ f[i][r + v] = max(f[i - 1][r + v], f[i - 1][r] + w)③\\\\ f[i][r] = max(f[i - 1][r])④可以对比公式1和公式2，发现公式1比2所求的极值多了一个f[i - 1][j],少了一个f[i - 1][j - (s + 1) * v] + s * w，类比之后所有项都有同样的规律，因此可以用单调队列优化。但是仔细观察，每一项虽然是相同的，但是每次会多一个w的偏移量，所以每次比较的都只能是前边的项，刚好减去j * w可以实现，在求值的时候可以再加上获得正确结果。 模板//暴力求解多重背包问题 for (int i = 1; i &lt;= n; i ++ ) for (int j = 0; j &lt;= m; j ++ ) for (int t = 0; t &lt;= s[i]; t ++ ) if (j - s * v[i] &gt;= 0) f[i][j] = max(f[i][j], f[i - 1][j - s * v[i]] + s * w[i]); //二进制优化 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 12010, M = 2010; int V[N], W[N]; int idx; int n, m; int f[M]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); //对于每一个物品将s件拆解成log(s)件打包的物品 for (int i = 0; i &lt; n; i ++ ) { int v, w, s; scanf(&quot;%d%d%d&quot;, &amp;v, &amp;w, &amp;s); int k = 1; while (k &lt;= s) { ++ idx; V[idx] = k * v; W[idx] = k * w; s -= k; k *= 2; } //如果还有剩余不满足2的幂次也要打包 if (s) { ++ idx; V[idx] = s * v; W[idx] = s * w; } } //用01背包求解 for (int i = 1; i &lt;= idx; i ++ ) for (int j = m; j &gt;= V[i]; j -- ) f[j] = max(f[j], f[j - V[i]] + W[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } //多重背包二进制优化的一种更好的写法 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 2010; int f[N]; int n, m; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) { int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for (int k = 1; k &lt;= s; k *= 2) { for (int j = m; j &gt;= k * v; j -- ) f[j] = max(f[j], f[j - k * v] + k * w); s -= k; } if (s) for (int j = m; j &gt;= s * v; j -- ) f[j] = max(f[j], f[j - s * v] + s * w); } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } //单调队列优化 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1010, M = 20010; int n, m; int f[M], g[M]; //滚动数组优化空间复杂度 int q[M]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) { int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; memcpy(g, f, sizeof f); int R = m % v; //枚举余数 for (int r = 0; r &lt;= R; r ++ ) { int hh = 0, tt = -1; //枚举当前体积下需要计算的每一项 //每次要记得减去j * w进行比较，因为窗口在滑动过程中，每次值都在增大，无法比较 for (int j = 0; j &lt;= (m - r) / v; j ++ ) { //如果单调队列的滑动窗口已经超过s了就向前 if (hh &lt;= tt &amp;&amp; j - q[hh] &gt; s) hh ++ ; //如果当前值大于单调队列的末尾，则出队 while (hh &lt;= tt &amp;&amp; g[r + j * v] - j * w &gt; g[r + q[tt] * v] - q[tt] * w) tt -- ; //无条件入队当前元素 q[++ tt] = j; //用当前最大值更新f数组得到当前结果 //f[r + j * v] = g[r + q[hh] * v] - q[hh] * w + j * w; f[r + j * v] = g[r + q[hh] * v] + (j - q[hh]) * w; } } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } AW.4 多重背包问题I（简单） AW.5 多重背包问题II（中等） 第二题主要考察二进制优化 AW.6 多重背包问题III（困难） 第三题考察多重背包问题的单调队列优化 分组背包原理分组背包问题指有很多物品组，从每组中只能挑选一个物品，求最大价值。相当于每组之内物品互斥，且每组之间可以看成01背包问题。分组背包是有依赖的背包问题的前序问题。 模板#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110; int f[N]; int v[N][N], w[N][N]; int s[N]; int n, m; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) { cin &gt;&gt; s[i]; for (int j = 0; j &lt; s[i]; j ++ ) cin &gt;&gt; v[i][j] &gt;&gt; w[i][j]; } //先循环物品，再循环体积，再循环组内物品 for (int i = 1; i &lt;= n; i ++ ) for (int j = m; j &gt;= 0; j -- ) for (int k = 0; k &lt; s[i]; k ++ ) if (j &gt;= v[i][k]) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); //这里枚举最后一个的时候是互斥的，因为确定了体积 cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 例题AW.9 分组背包问题（中等） 二维费用背包原理二维费用背包在一维费用背包 基础上，多一维度费用的判断，必须满足两者的费用均满足转移条件时，才可以转移。 模板int f[N][M]; int v1[K], v2[K], w[K]; for (int i = 1; i &lt;= n; i ++ ) for (int j = m1; j &gt;= v1[i]; j -- ) for (int k = m2; j &gt;= v2[i]; j -- ) f[j][k] = max(f[j][k], f[j - v1[i]][k - v2[i]] + w[i]); 例题AW.8 二维费用背包问题（中等） AW.1022 宠物小精灵之收服（简单） 混合背包原理输入很多个物品，每个物品可能有三种情况，01物品，无限次用物品和只能取用s个物品。其实可以将01背包看成多重背包的特例，之后分开进行状态转移。甚至完全背包也是多重背包的特例，每次可以取用的物品数一定不超过m / v + 1个。 模板#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1010; int f[N]; int n, m; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) { int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; if (s == -1) s = 1; else if (s == 0) s = m / v + 1; //二进制优化一种更好的写法 for (int k = 1; k &lt;= s; k *= 2) { for (int j = m; j &gt;= k * v; j -- ) f[j] = max(f[j], f[j - k * v] + k * w); s -= k; } if (s) { for (int j = m; j &gt;= s * v; j -- ) f[j] = max(f[j], f[j - s * v] + s * w); } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 例题AW.7 混合背包问题（中等）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2020-07-06T07:14:17.000Z","updated":"2020-07-13T08:36:17.284Z","comments":true,"path":"2020/07/06/计算机网络/","link":"","permalink":"/2020/07/06/计算机网络/","excerpt":"","text":"计算机网络TCP的三次握手和四次挥手三次握手 Client将标志位SYN置为1，随机产生一个值seq=j，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。（第一个SYN） Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=j+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。(第二个SYN + ACK) Client收到确认后，检查ack是否为j+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。(第三个ACK) 四次挥手由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。 数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。 服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。 当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认 客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。 图片理解： TCP如何保证可靠性校验和发送方在发送数据之前计算校验和，填充校验和。接收方收到数据后，再次计算校验和，并和发送方的对比。 序列号和确认应答TCP传输时对于每一个包进行了编号。ACK可以通过带有对应的确认序列号告诉发送方下一个应该发送报文的序号，如果有丢包会重新发送。接收方也可以根据序列号排序所有的报文，得到正确的数据。 超时重传如果在确认应答机制中，ACK报文有可能丢失。有两种可能： 发送方发了，接收方一个都没收到。 接收方收到了，但是ACK回去的时候丢了。 为了解决这个问题，引入了超时重传。发送方在发送完之后等待一个时间，如果时间结束没有接收到ACK报文，那么就重发一遍。接收方如果收到二次重发的数据，则丢弃，再发一次ACK。这个等待时间是动态计算的。 在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2 x 500ms的时间后，再次重传。等待4 x 500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。 连接管理三次握手和四次挥手。 流量控制TCP协议中根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。防止接收端接收太多数据，缓冲区填满之后引发超时重传等机制。 接收方会不停把自己缓冲区剩余大小放在ACK报文中，发送方通过ACK中窗口大小调节自己发送的速度。如果窗口大小为0，则停止发送数据，并定期向接收端发送窗口探测数据段。（心跳检测） 拥塞控制详细看下方的拥塞控制详解。 CSDN.网络基础：TCP协议-如何保证传输可靠性 TCP的拥塞控制TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，产生大量的超时重传，严重影响传输。 慢启动所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口，如下公式所述： real\\_send\\_window = min(rwnd, cwnd)这里慢启动不是指报文发送的很慢，而是指发送窗口较小。首先发送1个包，收到回复报文之后，加倍发送窗口，以此类推直到门限值为止。 拥塞避免慢启动的拥塞窗口增长是指数级别的，为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。 快重传TCP传输中，如果某一序号的报文丢失，发送方还可以继续发送报文，这时每发一个报文，接收方都会发现当前接收的报文在未接收的报文序列之后，就会要求重传。当发送方接收到3个要求重传的请求报文之后，就不会进行发送方对3号报文的超时重传，而是直接收到了快重传。 快恢复快恢复算法是在收到三个重复ACK的时候，不直接把cwnd变成1，因为当前只是有个别的报文没有接收到，不需要重置网络传输窗口。 CSDN.TCP拥塞控制（详解）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"最短路径算法","slug":"最短路径算法","date":"2020-07-05T08:20:29.000Z","updated":"2020-07-06T07:11:53.028Z","comments":true,"path":"2020/07/05/最短路径算法/","link":"","permalink":"/2020/07/05/最短路径算法/","excerpt":"","text":"最短路径算法Floyd原理&emsp;&emsp;使用邻接矩阵存储图更为合理，因为floyd算法要求每两个点之间的最短路径。循环顺序是kij其中k是阶段，从ik到kj点的最短路径由松弛操作 g[i][j] = min(g[i][j], g[i][k] + g[k][j])给出。当有重边和自环时，每两个点之间存储的g[i][j]只存储最短的一条即可。时间复杂度为O(n^3)。 模板void floyd() { for (int k = 1; k &lt;= n; k ++ ) for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) g[i][j] = min(g[i][j], g[i][k] + g[k][j]); } 例题AW.854 Floyd求最短路（简单） Dijkstra原理&emsp;&emsp;使用dist数组来维护所有点到源点的最短距离，用st数组维护已经确定最短距离的点。st数组一定要从空集开始，这样才能更新1号点。从所有点中选择距离源点最近的点来更新，将其所有临接点到源点的最短距离更新。最终更新了n个点后，所有点到达最短距离。时间复杂度为O(n^2)。 模板#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const int N = 510, INF = 0x3f3f3f3f; int d[N][N]; int n, m; int dist[N]; bool st[N]; void dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 1; i &lt;= n; i ++ ) { int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; st[t] = true; for (int j = 1; j &lt;= n; j ++ ) if (dist[j] &gt; dist[t] + d[t][j]) dist[j] = dist[t] + d[t][j]; } if (dist[n] == INF) cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; else cout &lt;&lt; dist[n] &lt;&lt; endl; } int main() { cin &gt;&gt; n &gt;&gt; m; memset(d, 0x3f, sizeof d); for (int i = 1; i &lt;= m; i ++ ) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; d[a][b] = min(d[a][b], c); } dijkstra(); return 0; } 堆优化的Dijkstra原理&emsp;&emsp;维护一个堆，堆中储存一对信息（距离源点距离，当前点序号），从而每次得到距离源点最近的点的编号，扩展所有邻接点。这里不能保证每个点只入堆一次，因此当第一次从堆出来以后，再出来的就是错误的更新点，因此使用判重布尔数组st来continue。时间复杂度因为有堆进行优化，所以是O(mlogn)。 模板#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #define x first #define y second using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 150010, INF = 0x3f3f3f3f; int h[N], e[N], ne[N], w[N], idx; int n, m; int dist[N]; bool st[N]; void dijkstra() { memset(dist, 0x3f, sizeof dist); priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; dist[1] = 0; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.y, distance = t.x; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; ~i; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == INF) cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; else cout &lt;&lt; dist[n] &lt;&lt; endl; } void add(int a, int b, int c) { e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ; } int main() { cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); while (m -- ) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); } dijkstra(); return 0; } Bellman Ford&emsp;&emsp;可以求解不超过k条边的最短路径，通过k次循环，每次备份dist数组，每次遍历所有的边，通过上次dist数组更新本次dist数组，可以求取负边权的情况。时间复杂度是O(km)，因为每次经过k次迭代，每次迭代m条边。 SPFA原理&emsp;&emsp;SPFA算法是队列优化的Bellman Ford算法，由于Bellman Ford算法需要k次更新所有的边，但是其中某些边在没有最短路径涉及时不需要更新。SPFA算法通过维护队列，将每次被更新的点加入队列，每次只更新队列内部的点，这样就减少了很多不必要点的更新操作。队列里是所有被更新过的点，因此可以维护st数组，当某个点被多个点更新时，就不用重复进入队列作为一下步扩展更新了。时间复杂度是O(nm)，但是实际上会比这个复杂度快很多，接近于O(m)。有可能会被特殊的图卡时间复杂度，如果没有卡，算是最短路径里面最好用的算法了。 &emsp;&emsp;SPFA算法优化的一个重要原理是当元素出队的时候，已经在之前的过程中被多次更新，因此每次出队的时候，都是用当前很小的值去更新邻接点。 &emsp;&emsp;实现过程中，使用循环队列，因为一共需要更新多少次不一定，如果使用n * m的队列太大了。 模板#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const int N = 100010; const int INF = 0x3f3f3f3f; int h[N], e[N], ne[N], w[N], idx; int n, m; int dist[N], q[N]; bool st[N]; //这里spfa使用了循环队列 void spfa() { int hh = 0, tt = 1; memset(dist, 0x3f, sizeof dist); dist[1] = 0; q[0] = 1; st[1] = true; while (hh != tt) { int t = q[hh ++ ]; if (hh == N) hh = 0; st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) { q[tt ++ ] = j; st[j] = true; } if (tt == N) tt = 0; } } } if (dist[n] &gt;= INF / 2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; else cout &lt;&lt; dist[n] &lt;&lt; endl; } void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } int main() { cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); while (m -- ) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); } spfa(); return 0; } SPFA判断负环原理&emsp;&emsp;SPFA算法当队列不空的时候就会不断的更新图中路径的最短值，每次更新相当于多走一条边，当有负环的时候，某些节点一定会被无限次更新到负无穷，因此用cnt数组来记录每一个点的被更新次数，当某个点更新次数大于n – 1时，说明存在一条路径当更新n – 1次之后，还可以更小，这样就是存在负环了。开始时一定要把所有点都加入到队列中，否则只更新某一个点，也许去其他点的路径可以不经过负环，也就不会无限更新，就找不到负环来判断。 &emsp;&emsp;SPFA判断负环可以用栈代替队列。这样做的好处是可以快速的将当前元素不停更新，这样如果进入负环，无限次的更新很快即可以满足cnt[j] &gt;= n的条件，从而判断到负环。当超时的时候，可以考虑进行这种优化。另外，也可以设置一个经验值，比如2 n或者3 n以上，当SPFA算法更新次数超过这个次数的时候，也认为有负环，是一个大概率对但是不一定全对的优化。 模板#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; const int N = 2010, M = 10010; int h[N], e[M], ne[M], w[M], idx; int dist[N]; int cnt[N]; int n, m; bool spfa() { memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i ++ ) q.push(i); while (q.size()) { auto t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[t] + w[i] &lt; dist[j]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1 ;//表示当前路径下的该点已经经过了t + 1条边 //cnt[j] ++ ; 也可以这样写，代表有某点被更新多于n - 1次也是有负环存在，但是效率低 if (cnt[j] &gt;= n) return true; q.push(j); } } } return false; } void add(int a, int b, int c) { e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ; } int main() { cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); while (m -- ) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); } if (spfa()) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else puts(&quot;No&quot;); return 0; } 例题AW.852 spfa判断负环（简单）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"DFS","slug":"DFS","date":"2020-07-01T13:03:53.000Z","updated":"2020-07-01T13:38:54.731Z","comments":true,"path":"2020/07/01/DFS/","link":"","permalink":"/2020/07/01/DFS/","excerpt":"","text":"DFSDFS全局变量记录最值原理每次DFS过程的时候都搜索到状态树的叶子节点，如果找到了答案就更新一下全局变量记录的最值，当搜索完整棵树的时候，就得到答案了。这种DFS的实现一般来说没有返回值，但是需要每次进行剪枝，如果答案已经比当前最优答案差了，就没有必要再搜下去了。 模板int ans = 0; void dfs(int u, int sum) { if (sum &gt; ans) return; if (u == n) { ans = max(ans, sum); return; } //dfs进一步的逻辑 } DFS迭代加深原理用BFS的思想来写DFS就是迭代加深，相当于每次搜索的时候，一层一层的搜索整颗树。用depth来标志搜索到哪一层了。适合答案比较浅的情况，理论来说会产生重复搜索，如果答案较深的话，不适合。这里的剪枝可以叫做乐观估计函数，即搜到多少肯定就没戏了。 模板bool dfs(int depth, int u, int sum) { if (sum &gt; depth) return false;//如果超过当前深度就不继续搜了 if (u == n) return true;//如果搜到底了，那么一定得返回了 //具体下一步dfs的逻辑 } int main() { int depth = 0; while (!dfs(depth, 0, 0)) depth ++ ;//每次迭代加深一 cout &lt;&lt; depth &lt;&lt; endl; return 0; } 例题AW.187 导弹防御系统（中等） 这题主要看迭代加深和全局记录DFS的解方法","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"操作系统","slug":"操作系统","date":"2020-06-30T07:56:08.000Z","updated":"2020-07-14T14:30:36.080Z","comments":true,"path":"2020/06/30/操作系统/","link":"","permalink":"/2020/06/30/操作系统/","excerpt":"","text":"操作系统进程与线程的区别 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。） 进程是CPU资源分配的最小单位，线程是CPU调度的最小单位； 系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、IO设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。 线程间比进程间通信更容易。由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预。 进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。 进程间不会相互影响 ，而一个线程挂掉将导致整个进程挂掉。 进程间通信的方式进程间通信主要包括管道、系统IPC（包括消息队列、信号量、共享内存、信号等）、以及套接字socket。 1.管道：管道主要包括无名管道和命名管道。管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。 1.1 普通管道PIPE（无名管道）： 1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端，fd[0] 和fd[1]，0是读端，1是写端。 2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。 3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。 Linux下实现代码： int main() { char buf[1024]=&quot;change world!\\n&quot;; int fds[2]; if(pipe(fds) == -1) perror(&quot;pipe&quot;),exit(1); pid_t pid = fork(); //创建子进程 if(pid == 0)//如果是父进程 { close(fds[0]); //关闭管道读描述符 if(write(fds[1],buf,1024)==-1) //写进管道 perror(&quot;write&quot;),exit(1); close(fds[1]); exit(1); } else { memset(buf,0x00,1024); close(fds[1]); //关闭管道写描述符 if(read(fds[0],buf,1024)==-1) //从管道读内容 perror(&quot;read&quot;),exit(1); if(write(1,buf,1024)==-1) perror(&quot;write&quot;),exit(1); close(fds[0]); exit(1); } return 0; } 1.2 命名管道FIFO： 1)FIFO可以在无关的进程之间交换数据 2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。 Linux下实现代码： 在Linux系统中，使用下边命令创建命名管道 mkfifo filename [centos@localhost fifo]$ mkfifo myfifo [centos@localhost fifo]$ ls myfifo [centos@localhost fifo]$ file myfifo myfifo: fifo (named pipe) 也可以在程序内部创建 int mkfifo(const char *pathname, mode_t mode); int main() { mkfifo(&quot;my.p&quot;, 0644); return 0; } 从命名管道中读入读出 #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;unistd.h&gt; #include&lt;sys/types.h&gt; #include&lt;sys/stat.h&gt; #include&lt;fcntl.h&gt; //读入示例 int main() { mkfifo(&quot;my.p&quot;,0664);//八进制0664 = 110 110 100 int outfd = open(&quot;my.p&quot;,O_WRONLY); if(outfd == -1) perror(&quot;open my.txt&quot;),exit(1); char buf[1024]={}; int n = 0; while(fgets(buf,1024,stdin)) { write(outfd,buf,1024); memset(buf,0x00,1024); } close(outfd); } //读出示例 int main() { int infd = open(&quot;my.p&quot;,O_RDONLY); if(infd==-1) perror(&quot;open my.p&quot;),exit(1); char buf[1024]={}; int n = 0; while((n = read(infd,buf,1024))&gt;0) { write(1,buf,n); memset(buf,0x00,1024); } close(infd); unlink(&quot;my.p&quot;); //删除管道 return 0; } 总结： 匿名管道由pipe函数创建并打开。命名管道由mkfifo函数创建，打开⽤用open。FIFO（命名管道）与pipe（匿名管道）之间唯一的区别在它们创建与打开的⽅方式不同，一但这些工作完成之后，它们具有相同的语义。 参考资料.Blog龙跃十二.利用管道实现进程间通信 2.系统IPC（Inter-Process Communication)2.1 消息队列 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限的进程可以按照一定的规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； 特点： 1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。 Linux下消息队列实现主要通过四个函数，msgget(),msgsnd(),msgrcv(),msgctl()。 #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/msg.h&gt; //调用成功返回一个key key_t ftok(const char *pathname, int proj_id); //创建和获取消息队列 int msgget(key_t key, int msgflg); //key : 消息队列关联的键，即id, 使用ftok()产生,不同进程通过相同key可以得到相同消息队列 //msgflg ：消息队列的建立标志和存取权限 //IPC_CREAT 单独使用是如果没有就创建 //IPC_EXCL + IPC_CREAT 是已经存在则执行失败 //返回创建的消息队列的标识符msqid，msqid是IPC对象内部名，失败返回-1 //使用的例子 int open_queue(int keyval) { int qid; qid = msgget(keyval, IPC_CREAT | 0666); if (qid == -1) { perror(&quot;Failed in calling msgget&quot;); return -1; } return qid; } //发送一条消息到指定的消息队列 int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflag); //msqid为消息队列标识符 //msgp指向准备发送消息的指针 //msgsz上述指针指向消息的长度 //msgflag默认为0（IPC_NOWAIT)，表示阻塞，1表示非阻塞。阻塞表示如果队列满了就一直等到有地方，如果非阻塞满了，就直接返回-1。 //消息结构一方面必须小于系统规定的上限，另一方面必须以一个long int长整型开始，接受者以此来确定消息的类型（协议必须的部分） //实际例子 struct msgbuf { long mtype; char mtext[1024]; } int sendMsgQueue(int msg_id, int who, char* msg) { struct msgbuf buf; buf.mtype = who; strcpy(buf.mtext, msg);//前目的，后源 if (msgsnd(msg_id, (void*) &amp;buf, sizeof(buf.mtext), 0) &lt; 0) { perror(&quot;Fail to send message to MsgQueue!&quot;); return -1; } return 0; } //从指定消息队列接收一条消息 int msgrcv(int msqid, const void* msgp, size_t msgsz, long msgtype, int msgflg); //参数和msgsnd相同 //例子 int recvMsgQueue(int msg_id, int recvType, char out[]) { struct msgbuf buf; int size = sizeof(buf.mtext); if (msgrcv(msg_id, (void*)&amp;buf, size, recvType, 0) &lt; 0) { perror(&quot;Fail to receive message from MsgQueue!&quot;); return -1; } strncpy(out, buf.mtext, size);//将特定大小的字符串复制 out[size] = 0;//字符串设置为&#39;\\0&#39; return 0; } //消息控制 int msgctl(int msqid, int cmd, struct msgid_ds *buf); //msqid是由msgget返回的消息队列id //cmd有三种值 //IPC_RMID 删除消息队列 //PIC_STAT 把msgid_ds结构中的数据设置为消息队列的当前关联值 //IPC_SET 在进程有足够权限的前提下，把消息队列的当前关联值设置为msgid_ds数据结构中给出的值 int destoryMsgQueue(int msg_id) { if (msgctl(msg_id, IPC_RMID, NULL) &lt; 0) { perror(&quot;Remove MsgQueue Fail!&quot;); return -1; } return 0; } #ipcs 显示IPC资源 -q是消息队列， -m是共享内存 #ipcrm 手动删除IPC资源 [root@localhost code]# ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages 0x66020001 524288 root 666 0 0 [root@localhost code]# ipcrm -q 524288 [root@localhost code]# ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages [root@localhost code]# CSDN. Linux进程间通信之消息队列 CSDN. Linux进程通信之消息队列-项目实践 2.2 共享内存（Shared Memory） 它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。 特点： 1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取。 2)因为多个进程可以同时操作，所以需要进行同步。 3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。 Linux下共享内存机制实现代码，因为是IPC所以很多差不多： #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; //建立（获得）一块共享存储区，返回共享存储区的描述符shmid，新建立后初始化为0 //key还是ftok函数生成的 int shmget(key_t key, size_t size, int shmflg); //这里的key和size与消息队列相同 //shmflg有 IPC_CREAT IPC_EXCL用法同消息队列 //SHM_HUGETLB 使用“huge pages”来分配共享区段 //SHM_NORESERVE 不要为共享区段保留交换空间 //对共享存储区shmid执行操作cmd，对其状态进行修改和控制 int shmctl(int shmid, int cmd, struct shmid_ds *buf); //cmd有五种，除了消息队列的三种，还多了两种 //IPC_STAT IPC_SET IPC_RMID 删除的时候会等待最后一个使用该存储区的进程终止，但是标识符会立刻删除，无法再使用shmat与该段相连 //SHM_LOCK SHM_UNLOCK 锁住和解锁共享存储区，需要superuser权限 //获得了shmid后，系统需要使用shmat将该共享存储区附接到用户给定的某个进程的虚拟地址 void *shmat(int shmid, const void *addr, int flag); //addr指定共享内存出现在进程地址的什么位置，指定为NULL可以让内核自己决定 //flag是对于数据的操作，SHM_RDONLY（010000）是只读，其他为读写方式 //成功返回指向共享存储段的指针，错误返回-1（0xffffffff) //当进程不再需要一个共享存储段时，可以使用shmdt int shmdt(void * addr); //addr是调用shmat的返回值 //成功返回0，错误返回-1 //实际例子 struct Info{ char name[100]; int age; }; int main() { key_t key = ftok(&quot;/tmp&quot;, 66); int shmid = shmget(key, sizeof(Info), IPC_CREAT|0666); Info *p; p = (Info *)shmat(shmid, NULL, 0); char name[100] = &quot;ScarofSky&quot;; int age = 25; strcpy(p -&gt; name, name); p -&gt; age = age; if (shmdt(p) == -1) { perror(&quot;Dettach Fail!&quot;); return -1; } return 0; } 总结：相当于对于共享内存的读写，转换为当前进程中虚拟地址（指针）的读写。 CSDN.Linux下共享内存编程 2.3 信号量semaphore 信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。 特点： 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。 支持信号量组。 PV操作的具体意义： P(s):将信号量value值减1,若结果小于0,则执行P操作的进程被阻塞，若结果大于等于0,则执行P操作的进程将继续执行。 V(s):将信号量的值加1,若结果不大于0,则执行V操作的进程从信号量s有关的list所知队列中释放一个进程，使其转化为就绪态，自己则继续执行，若结果大于0,则执行V操作的进程继续执行。 PV操作先对value值加减，再判断和0的关系，之后再决定阻塞和唤醒，是上述逻辑。信号量在Linux中有两种规范，一个是System V标准，另一个是Posix标准。如下的具体代码只涉及Posix标准，System V只列出。 //System V 标准API int semget(key_t key, int num_sems, int sem_flags); int semop(int sem_id, struct sembuf *sops, size_t nsops); int semctl(int sem_id, int sem_num, int cmd); //Posix 标准API #include &quot;semaphore.h&quot; //初始化一个信号量 int sem_init(sem_t *sem, int pshared, unsigned int value); //sem为指向信号量结构的一个指针 //pshared != 0在进程间共享，pshared == 0 只在当前进程的所有线程共享 //value是初始值 //等同于V操作 int sem_post(sem_t *sem); //调用后value ++ , 线程调度策略决定唤醒哪个阻塞的线程 //等同于P操作 int sem_wait(sem_t *sem); //如果信号量值大于0， 则值-1， 如果值小于等于0，则阻塞当前进程 //if (sem &gt; 0) sem -- ; //else if (sem &lt;= 0) //{ // sem -- ; // sleep(); //} CSDN. Linux信号量操作 2.4 信号signal 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。 Blog.sky 3.套接字SOCKET： socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。 CSDN.Linux网络编程 套接字编程 线程间通信的方式临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问； 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。 死锁的必要条件和解决方法死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下： 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。 占有和等待：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。 非抢占：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放。 循环等待：进程发生死锁后，必然存在一个进程-资源之间的环形链。 死锁的处理方法是死锁预防、死锁避免、死锁检测和死锁恢复。 死锁预防的方法： 资源一次性分配，从而剥夺占有并等待条件。当一个进程申请一个资源时，它不能占有其他资源。缺点是资源利用率低和可能发生饥饿，当资源一次性分配之后，可能有些最后才用到；如果进程需要多个常用资源，可能会发生饥饿导致一直分配不到资源，一直等待。 抢占式协议：如果一个进程占有资源并申请另一个不能立即分配的资源，那么现在已经分配的资源允许其他进程抢占。换句话说，这些资源被隐式释放了。如果有新的进程请求资源，那么系统先考虑自由资源，再考虑等待中进程的资源，如果都不够，那么该进程也进入等待。 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件。 死锁避免的方法：获得以后进程如何申请资源的附加信息，由操作系统来综合考虑如何分配资源，使用已有的死锁避免算法。 安全状态 资源分配图算法（每种资源都有单个实例） 银行家算法（每种资源有多个实例） 死锁检测和恢复的方法：系统提供检测算法 + 恢复算法 缺页置换算法当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下： 先进先出（FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后顺序排列。 最近最少使用（LRU)算法：置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。被使用的页就会被刷新，放到最近的位置，长时间未被使用的就会慢慢排到最后。 并发和并行 并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核CPU上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。 并行（parallelism）：指严格物理意义上的同时运行，比如多核CPU，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。 大端序和小端序大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。 //判断系统是大端序还是小端序 int fun1() { union test { int i; char c; }; test t; t.i = 1; return (t.c == 1); } 比如0x12345678如果是小端序，存储地址从低到高应该是78 56 34 12，如果是大端序，从低到高地址存储应该是12 34 56 78。 大端序： 低地址 ——————————&gt; 高地址0x12 | 0x34 | 0x56 | 0x78 小端序： 低地址 ——————————&gt; 高地址0x78 | 0x56 | 0x34 | 0x12 内核态和用户态内存管理","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"动态规划（二）其他DP","slug":"动态规划（二）其他DP","date":"2020-06-30T07:30:01.000Z","updated":"2020-07-02T13:45:48.415Z","comments":true,"path":"2020/06/30/动态规划（二）其他DP/","link":"","permalink":"/2020/06/30/动态规划（二）其他DP/","excerpt":"","text":"其他DP区间dp区间DP是在区间上进行动态规划，本质是用更小区间的最优解来求更大区间的最优解。一般的模板都是这样的： for (int len = 2; len &lt;= n; len ++ ) for (int i = 1; i + len - 1 &lt;= n; i ++ ) { int j = i + len - 1; for (int k = i; k &lt; j; k ++ ) f[i][j] = max(f[i][j], f[i][k] + f[k][j] + ****); } 状压dp状压DP分为两类，一类是棋盘式（基于连通性）的模型，另一类是基于集合。 棋盘式：蒙德里安的梦想这道题，是求把NM的棋盘分割成若干个12的的长方形，有多少种方案。通过将每一列看成一个状态，其中放了小块的格子为1，没放的为0，这样可以通过枚举所有的状态到状态的转移来进行计数。 基于集合：最短哈密尔顿路径，给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。对所有点构成的集合考虑，已经走过的点为1，还没有到达过的点为0，可以确定一个n位状态state，但如果需要从一个点转移到下一个点，则还需要记录当前停在了哪一个点上。因此用f[state][j]表示到达j号点时，已经走过的状态为state的路径集合中的最小值。 因此可以得到状态转移方程： f[state][j] = min(f[state][j], f[state - (1 < k)][k] + w[k][j]);","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"最小生成树算法","slug":"最小生成树算法","date":"2020-06-28T10:34:07.000Z","updated":"2020-06-28T10:36:33.553Z","comments":true,"path":"2020/06/28/最小生成树算法/","link":"","permalink":"/2020/06/28/最小生成树算法/","excerpt":"","text":"最小生成树算法Prim原理&emsp;&emsp;用st数组维护一个集合，最开始为空，每次扩充一个距离当前集合最近的点进入集合，并且更新其他点到集合的最近距离。所有点到集合的初始最近距离为INF，将所有点均加入到集合时算法结束。如果某一次扩充的点到集合的最近距离为正无穷，则说明不存在最小生成树。时间复杂度为O(n^2)。 模板#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const int N = 510, INF = 0x3f3f3f3f; int w[N][N]; int dist[N]; bool st[N]; int n, m; int prim() { int res = 0; memset(dist, 0x3f, sizeof dist); for (int i = 0; i &lt; n; i ++ ) { int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; if (i) res += dist[t]; if (i &amp;&amp; dist[t] == INF) return INF; st[t] = true; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], w[t][j]); } return res; } int main() { cin &gt;&gt; n &gt;&gt; m; memset(w, 0x3f, sizeof w); for (int i = 1; i &lt;= n; i ++ ) w[i][i] = 0; for (int i = 0; i &lt; m; i ++ ) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; w[a][b] = w[b][a] = min(w[a][b], c); } int t = prim(); if (t == INF) puts(&quot;impossible&quot;); else cout &lt;&lt; t &lt;&lt; endl; } Kruskal原理&emsp;&emsp;通过排序得到所有边的序列，从最小的边开始扩展，贪心的思路。维护一个并查集来确定两个点是否属于同一个集合，如果属于同一个集合的两个点还需要增加一条边，则该条边增加后则成环。因此维护一个计数器cnt，当算法结束之后，cnt如果小于n – 1则说明不存在有效的生成树，否则并查集维护的点就是当前生成树。时间复杂度因为用到了排序，因此是mlog(m)。 模板#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010, M = 200010; struct Edge { int a, b, w; bool operator &lt; (const Edge&amp; a) const { return w &lt; a.w; } }edges[M]; int n, m; int p[N]; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } void kruskal() { int res = 0, cnt = 0; for (int i = 1; i &lt;= n; i ++ ) p[i] = i; for (int i = 0; i &lt; m; i ++ ) { auto e = edges[i]; int a = e.a, b = e.b, w = e.w; int pa = find(a), pb = find(b); if (pa != pb) { res += w; cnt ++ ; p[pa] = pb; } } if (cnt &lt; n - 1) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; else cout &lt;&lt; res &lt;&lt; endl; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i ++ ) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; edges[i].a = a, edges[i].b = b, edges[i].w = c; } sort(edges, edges + m); kruskal(); return 0; } 例题AW.859 Kruskal算法求最小生成树（简单） LC.1489 找到最小生成树中的关键边和伪关键边（困难）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"双指针","slug":"双指针","date":"2020-06-28T06:09:29.000Z","updated":"2020-06-28T06:12:22.950Z","comments":true,"path":"2020/06/28/双指针/","link":"","permalink":"/2020/06/28/双指针/","excerpt":"","text":"双指针原理双指针算法一般都可以暴力求解，但是暴力求解的时间复杂度一般为O(n^2)，通过优化使用双指针可以将其时间复杂度降低为O(n)。优化的本质是寻找i和j变化的单调性，如果某个指针在单调条件之下不可能再继续遍历，就可以省略那些遍历。 有些情况下，需要先构造性质比较好的数列，之后才能应用双指针算法。 模板for (int i = 0, j = 0; i &lt; n; i ++ ) { //如果要维护集合，在这里维护即可 while (j &lt; i &amp;&amp; check(i, j)) j ++ ; //具体逻辑 } 例题AW.799 最长连续不重复子序列（简单） AW.800 数组元素的目标和（简单） 两个序列上的双指针，需要考虑如何构造单调性 LC.5450 满足条件的子序列数目（中等） 周赛第三题，需要先进行排序，再考虑双指针算法 LC.5434 删掉一个元素以后全为1的最长子数组（中等） 简单双指针或者说滑动窗口应用","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"题库题解","slug":"题库题解","date":"2020-06-27T06:56:30.000Z","updated":"2020-07-16T07:41:29.343Z","comments":true,"path":"2020/06/27/题库题解/","link":"","permalink":"/2020/06/27/题库题解/","excerpt":"","text":"题库题库+题解LC.15 三数之和（中等） 排序+双指针，排序加上双指针可以简化定和搜索。排序可以将相同元素邻接。时间复杂度O(n^2)。 class Solution { public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; ans; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size(); i ++ ) { //因为要不重复，所以当前如果在之前出现过就跳过，排序的好处体现在这里 if (i - 1 &gt;=0 &amp;&amp; nums[i - 1] == nums[i]) continue; int target = -nums[i]; //第i个左边的都遍历过了，只考虑右边即可。 int l = i + 1, r = nums.size() - 1; //双指针过程 while (l &lt; r) { if (nums[l] + nums[r] &lt; target) l ++ ; else if (nums[l] + nums[r] &gt; target) r -- ; else { vector&lt;int&gt; cur; cur.push_back(nums[i]); cur.push_back(nums[l]); cur.push_back(nums[r]); ans.push_back(cur); //重复的直接跳过 while (l + 1 &lt;= nums.size() - 1 &amp;&amp; nums[l + 1] == nums[l]) l ++ ; while (r - 1 &gt;= 0 &amp;&amp; nums[r - 1] == nums[r]) r -- ; l ++ , r -- ; } } } return ans; } }; LC.1467 两个盒子中球的颜色数相同的概率（困难） 首先要知道可重复排列数计算原理和公式，假设有1122333这样的数，要求不重复的排列数，就要用到可重复排列数计算公式。思想是首先将所有的相同的数看做不同，求总共的排列数，假设一共有sum个数，有sum!种排列方式。再对于每一种数，除以重复的种数的全排列，用公式表达如下： res = \\frac{(S_1 + S_2 + ... + S_n)!}{S_1!*S_2!*...*S_n!}其中Si表示第i个数出现的次数。这样可以计算出概率的分母，对于分子，首先其必须满足分成两部分之后，左边和右边的种类数相同，然后对于左边和右边分别计算可重复排列数，并且利用乘法原理，得到最终合并之后的排列数。另外dfs过程中需要剪枝，当左边总和个数的两倍大于整体总和的时候不要继续计算了。 这道题是典型的概率类题目，之前没遇到过，记录一下。 double fact[50]; class Solution { public: //计算阶乘 void factorial() { fact[0] = 1; for (int i = 1; i &lt;= 48; i ++ ) fact[i] = fact[i - 1] * i; } //计算可重复排列数 double get(vector&lt;int&gt;&amp; balls) { int sum = 0; for (int i = 0; i &lt; balls.size(); i ++ ) sum += balls[i]; double res = fact[sum]; for (int i = 0; i &lt; balls.size(); i ++ ) res /= fact[balls[i]]; return res; } //通过dfs计算所有可能的情况 double dfs(int u, int ts, int ls, int rs, vector&lt;int&gt;&amp; left, vector&lt;int&gt;&amp; right, vector&lt;int&gt;&amp; balls) { //剪枝 if (ls * 2 &gt; ts || rs * 2 &gt; ts) return 0; double res = 0; if (u == balls.size()) { int l = 0, r = 0; for (int i = 0; i &lt; left.size(); i ++ ) if (left[i]) l += 1; for (int i = 0; i &lt; right.size(); i ++ ) if (right[i]) r += 1; //如果左右种类数不同，不可能产生答案，直接返回0 if (l != r) return 0; return get(left) * get(right); } //对于每一种球分别枚举 for (int i = 0; i &lt;= balls[u]; i ++ ) { left[u] = i, right[u] = balls[u] - i; res += dfs(u + 1, ts, ls + i, rs + balls[u] - i, left, right, balls); } return res; } double getProbability(vector&lt;int&gt;&amp; balls) { int n = balls.size(); int sum = 0; for (int i = 0; i &lt; balls.size(); i ++ ) sum += balls[i]; factorial(); double down = get(balls); vector&lt;int&gt; left(n, 0), right(n, 0); double up = dfs(0, sum, 0, 0, left, right, balls); return up / down; } }; LC.5438 制作m束花所需的最少天数（中等） 这是周赛的第三题，答案有一个范围，并且验证答案的时间在O(n)，且具有单调性（如果第x天无法制作那么小于x天都不行，如果x天可以制作，那么大于x天都可以制作），数据规模在10^5，因此O(nlogn)的二分算法可以完成这道题。 class Solution { public: int minDays(vector&lt;int&gt;&amp; bd, int m, int k) { int n = bd.size(); //无论如果都不能制作只有花数量不够 if (m * k &gt; n) return -1; //答案是在最小值和最大值之间，增加效率 int l = INT_MAX, r = INT_MIN; for (int i = 0; i &lt; n; i ++ ) { l = min(l, bd[i]); r = max(r, bd[i]); } //标准二分查找答案模板 while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(bd, mid, m, k)) r = mid; else l = mid + 1; } return l; } //check函数用O(n)的时间判断是否当前答案可行 //这里判断是否可行有点贪心的意味 bool check(vector&lt;int&gt;&amp; bd, int mid, int m, int k) { int cnt = 0; int ans = 0; for (int i = 0; i &lt; bd.size(); i ++ ) { //如果已经过了开花时间，则连续花数 + 1 if (bd[i] &lt;= mid) { cnt ++ ; //如果有k朵花了，可以做个束 if (cnt &gt;= k) { ans ++ ; //当前连续花数清零 cnt = 0; } } else cnt = 0; } if (ans &gt;= m) return true; else return false; } }; AW.342 道路与航线（中等） 这题很有意思，是图论的题，里面使用了堆优化的dijkstra + 拓扑排序 + dfs，看起来很难写，但是事实如果理清关系，是比较好写的一道题。 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #define x first #define y second using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 25010, M = 150010, INF = 0x3f3f3f3f; int h[N], e[M], ne[M], w[M], idx; int dist[N]; bool st[N]; int id[N]; int din[N]; int bid; vector&lt;int&gt; block[N]; queue&lt;int&gt; q; int n, mr, mp, s; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } void dfs(int u, int bid) { id[u] = bid; block[bid].push_back(u); for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (!id[j]) dfs(j, bid); } } void dijkstra(int bid) { priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; for (int i = 0; i &lt; block[bid].size(); i ++ ) { int j = block[bid][i]; heap.push({dist[j], j}); } while(heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.y, distance = t.x; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; ~i; i = ne[i]) { int j = e[i]; if (id[ver] != id[j]) { din[id[j]] -- ; if (din[id[j]] == 0) q.push(id[j]); } if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; if (id[ver] == id[j]) heap.push({dist[j], j}); } } } } void top_sort() { memset(dist, 0x3f, sizeof dist); dist[s] = 0; for (int i = 1; i &lt;= bid; i ++ ) if (!din[i]) q.push(i); while (q.size()) { int t = q.front(); q.pop(); dijkstra(t); } } int main() { cin &gt;&gt; n &gt;&gt; mr &gt;&gt; mp &gt;&gt; s; memset(h, -1, sizeof h); for (int i = 0; i &lt; mr; i ++ ) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c), add(b, a, c); } for (int i = 1; i &lt;= n; i ++ ) if (!id[i]) dfs(i, ++ bid); for (int i = 0; i &lt; mp; i ++ ) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); din[id[b]] ++ ; } top_sort(); for (int i = 1; i &lt;= n; i ++ ) if (dist[i] &gt; INF / 2) cout &lt;&lt; &quot;NO PATH&quot; &lt;&lt; endl; else cout &lt;&lt; dist[i] &lt;&lt; endl; return 0; } LC.1477 找两个和为目标值且不重叠的子数组 这题的数据保证了每一个数都是正数，因此双指针算法很容易每次寻找一个区间，使得当前区间的和为target。如果要找两个和为目标值且不重叠的子数组，只需要记忆化之前所有的答案，f[i] 定义为从0到i的子数组满足和为target的最短长度，以动态规划的思想，可以每次得到f[i] = min(i - j + 1, f[i - 1])用O(1)的时间复杂度更新。很容易想到双指针算法去寻找一个区间，但是对于两个区间，没有及时想到记忆化的方法。 这里双指针应该用i做循环，这样每次计算f[i]比较容易。 这题融合了双指针算法和动态规划的思想，是好题。 class Solution { public: int minSumOfLengths(vector&lt;int&gt;&amp; arr, int target) { int n = arr.size(); vector&lt;int&gt; f(n, 1e8); int res = 1e8; for (int i = 0, j = 0, sum = 0; i &lt; n; i ++ ) { sum += arr[i]; while (sum &gt; target) sum -= arr[j ++ ]; if (sum == target) { if (j) res = min(res, i - j + 1 + f[j - 1]); f[i] = i - j + 1; } if (i) f[i] = min(f[i], f[i - 1]); } if (res &gt; arr.size()) res = -1; return res; } }; LC.10 正则表达式匹配（困难） 动态规划，dp[i][j]表示s串前i个字符和p串前j个字符是否匹配。初始条件是空串一定匹配，且s的空串可以匹配任意个以.*开头的p串位置。之后对于最后一个p串位置的字符分类讨论： p[j] != ‘*’ : 此时p[j]有两种可能，’.’或者字符，这样就是普通的匹配，如果s[i] == p[j]那么就依赖于dp[i - 1][j - 1]，否则就不可能匹配，为false。 p[j] == ‘‘ : 的意思是匹配0个或多个前边一个字符。如果匹配0个，那么当前结果依赖dp[i][j - 2]，如果匹配多个之前的字符，是依赖dp[i - 1][j - 3]、dp[i - 2][j - 4]...如此代码会比较难写，且增加时间复杂度。从i角度来看，其实是看dp[i - 1][j]，表示当前s串的第i个字符能否被j这个*所取代。 整体的转移方程如下： f[i][j] = \\left\\{ \\begin{array} if (p[j]\\ ≠\\ '*') = \\left\\{ \\begin{array} f[i - 1][j - 1], & matches(s[i], p[j])\\\\ false, & otherwise\\\\ \\end{array} \\right. \\\\ otherwise = \\left\\{ \\begin{array} f[i - 1][j]\\ or\\ f[i][j - 2],& matches(s[i], p[j - 1)\\\\ f[i][j - 2], & otherwise\\\\ \\end{array} \\right.\\\\ \\end{array} \\right.class Solution { public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1, false)); dp[0][0] = true; for (int j = 1; j &lt;= m; j ++ ) { if (p[j - 1] == &#39;*&#39;) dp[0][j] = dp[0][j - 2]; else dp[0][j] = false; } for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { if (p[j - 1] != &#39;*&#39;) { if (equal(s[i - 1], p[j - 1])) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = false; } else { if (j &gt;= 2) dp[i][j] = dp[i][j - 2]; if (j &gt;= 2 &amp;&amp; equal(s[i - 1], p[j - 2])) dp[i][j] = (dp[i][j] || dp[i - 1][j]); } } return dp[n][m]; } bool equal(char a, char b) { if (b == &#39;.&#39;) return true; else return a == b; } }; LC.124 二叉树中的最大路径和（困难） 这题主要是想总结一下树的题目主要考点。对于二叉树来说，90%都需要使用递归的方式来解决，一般是先递归解决左子树，再递归解决右子树。思考方式主要从以下几个方面： 想清楚当前层该问题是如何解决的，如何利用左子树和右子树已知的答案得到当前根节点的答案，有些树状dp的意思。 想清楚叶子节点的子节点，为nullptr的节点应该如何给上一层提供信息，也就是边界问题，或者是递归出口。 对于树中每一个节点，先考虑递归解决左子树相同的问题，再递归解决右子树相同的问题，之后返回当前节点的问题答案。 class Solution { public: const int INF = 0x3f3f3f3f; int ans = -INF; int maxPathSum(TreeNode* root) { dfs(root); return ans; } int dfs(TreeNode* root) { if (root == nullptr) return -INF; int val = root -&gt; val; int left = dfs(root -&gt;left); int right = dfs(root -&gt;right); ans = max(ans, max({left, right, 0}) + val); ans = max(ans, left + right + val); return max({left, right, 0}) + val; } }; LC.1488 避免洪水泛滥（中等） 194周赛第三题，思路是贪心。这里可以通过预处理得到当前天下一次下雨的时间点，因此可以通过贪心，每一次不下雨抽水时，优先抽走马上下次要下雨的的坑。找到马上要下雨的坑，可以通过堆来实现（寻找一个集合中的最小值）。 贪心证明首先考虑，任意一种抽水方法，如果能完成最终任务，都可以通过排序转换为当前贪心的方法。再思考，如果这样抽水最终还是无法完成防洪的任务，那么调换顺序之后，一定会更早的洪水泛滥。因此从正反两方面可以证明当前贪心是正确的。 class Solution { public: vector&lt;int&gt; avoidFlood(vector&lt;int&gt;&amp; rains) { unordered_map&lt;int, int&gt; hash; int n = rains.size(); vector&lt;int&gt; next(n, n + 1); for (int i = n - 1; i &gt;= 0; i -- ) { int r = rains[i]; if (hash.count(r) == 0) hash[r] = i; else { next[i] = hash[r]; hash[r] = i; } } typedef pair&lt;int, int&gt; PII; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; unordered_set&lt;int&gt; S; vector&lt;int&gt; ans; for (int i = 0; i &lt; n; i ++ ) { int r = rains[i]; if (r &gt; 0) { ans.push_back(-1); if (S.count(r)) return {}; else { S.insert(r); heap.push({next[i], r}); } } else { if (heap.empty()) ans.push_back(1); else{ auto t = heap.top(); heap.pop(); int r = t.second; S.erase(r); ans.push_back(r); } } } return ans; } }; LC.41 缺失的第一个正数（困难） 这道题一个隐藏的思路是，下标都是从0到n - 1递增的，如果我们能将所有不超过n的数值都按规律填好，那么就可以很轻松的找到对应第一个未出现的正整数。这里如果发现已经填好的数，则跳过，如果发现置换之后死循环，也要处理。 class Solution { public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; i ++ ) { //如果已经填好的数，则可以跳过 if (nums[i] == i + 1) continue; while (nums[i] &gt;= 1 &amp;&amp; nums[i] &lt;= n) { int t = nums[nums[i] - 1]; //如果换了的数和现在的数一样，那其实换下去没有意义，会死循环 if (t == nums[i]) break; nums[nums[i] - 1] = nums[i]; nums[i] = t; } } //找到第一个没有出现过的数 for (int i = 0; i &lt; n; i ++ ) if (nums[i] != i + 1) return i + 1; return n + 1; } }; LC.1498 满足条件的子序列数目（中等） 周赛第三题，首先读题之后，判断题目最终所求信息和数组内元素顺序无关，这样可以考虑先排序试试。如果排序，可以得到有序序列，有序序列的特点是第一个元素最小，最后一个元素最大，且单调递增。因此可以考虑使用双指针算法来求解两数相加对于某个target和的问题。 class Solution { public: const int mod = 1e9 + 7; int numSubseq(vector&lt;int&gt;&amp; nums, int target) { int n = nums.size(); vector&lt;int&gt; pow2(n + 1); pow2[0] = 1; //这里可以先预处理出2的n次幂，之后每次要增加2的n次幂种情况，就直接调用了。 for (int i = 1; i &lt;= n; i ++ ) pow2[i] = (pow2[i - 1] * 2) % mod; //排序，想到这里很重要 sort(nums.begin(), nums.end()); //标准的双指针算法 int ans = 0; for (int i = 0, j = n - 1; i &lt; n; i ++ ) { while (i &lt;= j &amp;&amp; nums[i] + nums[j] &gt; target) j -- ; if (i &gt; j) break; ans = (ans + pow2[j - i]) % mod; } return ans; } }; LC.718 最长重复子数组（中等） 本题有三种解法，很有意思。 动态规划解法，f[i][j]表示A数组的第i个数字和B数组的第j个数字作为最长公共子数组的最后一位时，最长公共子串长度。 滑动窗口解法。从后向前每次枚举重叠区间，再从前向后每次枚举重叠区间，作为窗口。窗口内部每次比较所有子串最长重叠每次取max。这里是固定了重叠位置，进行了枚举，因此减少了之前的重复计算。 哈希表 + 二分查找解法。Rabin-Karp算法，其实本质就是字符串哈希，字符串哈希可以线性时间复杂度检测字符串中长度为特定长度的子串。再加上二分，可以将时间复杂度降低为O((n + m)log(Min(n, m)))。 //动态规划解法 class Solution { public: int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) { int n = A.size(), m = B.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) if (A[i - 1] == B[j - 1]) f[i][j] = f[i - 1][j - 1] + 1; else f[i][j] = 0; int res = 0; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) res = max(res, f[i][j]); return res; } }; //滑动窗口解法 class Solution { public: int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) { int n = A.size(), m = B.size(); int ans = 0; for (int i = 0, j = m - 1; j &gt;= 0; j -- ) { int len = 0; for (int k = 0; j + k &lt; m &amp;&amp; i + k &lt; n; k ++ ) { if (A[i + k] == B[j + k]) len ++ ; else len = 0; ans = max(ans, len); } } for (int i = n - 1, j = 0; i &gt;= 0; i -- ) { int len = 0; for (int k = 0; i + k &lt; n &amp;&amp; j + k &lt; m; k ++ ) { if (A[i + k] == B[j + k]) len ++ ; else len = 0; ans = max(ans, len); } } return ans; } }; //哈希表 + 二分查找 typedef unsigned long long ULL; class Solution { public: int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) { int n = A.size(), m = B.size(); int l = 0, r = min(n, m); while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (calHash(A, B, mid)) l = mid; else r = mid - 1; } return r; } bool calHash(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, int len) { int p = 113; ULL res = 0; int n = A.size(), m = B.size(); unordered_set&lt;ULL&gt; hashA; for (int i = 0; i &lt;= len - 1; i ++ ) { res = res * p; res = res + A[i]; } hashA.insert(res); ULL mult = qmi(p, len - 1); for (int i = 1; i + len - 1 &lt; n; i ++ ) { res = (res - A[i - 1] * mult) * p + A[i + len - 1]; hashA.insert(res); } res = 0; for (int i = 0; i &lt;= len - 1; i ++ ) { res = res * p; res = res + B[i]; } if (hashA.count(res)) return true; for (int i = 1; i + len - 1 &lt; m; i ++ ) { res = (res - B[i - 1] * mult) * p + B[i + len - 1]; if (hashA.count(res)) return true; } return false; } ULL qmi(ULL p, int k) { ULL res = 1; while (k) { if (k &amp; 1) res = res * p; p = p * p; k &gt;&gt;= 1; } return res; } }; LC.剑指Offer 62 圆圈中最后剩下的数字（简单） 经典的约瑟夫环问题，如果直接链表模拟，会导致TLE。仔细思考应该发现，如果定义f(n, m)为圆圈中最后剩下的数字，可以通过下述公式利用f(n - 1, m)计算，并且当n == 1时， f(1, m) = 0,也就是一定会剩下编号为0的节点。在递归公式中则将f(n - 1, m)看做了偏移量，每次n都减少，就正好对应了删除元素的意义。 class Solution { public: int lastRemaining(int n, int m) { return f(n, m); } int f(int n, int m) { if (n == 1) return 0; return (m % n + f(n - 1, m)) % n; } }; LC.378 有序矩阵中的第K小的元素（中等） 本题和排序矩阵查找是同一题，在于发现矩阵部分排序之后的特征。如果从左下角开始向上查找，则每次查找不需要向左，每次j只会递增。在这道题里就可以通过二分统计元素个数来最终得到答案。另外，这里要找的答案一定要在矩阵中，但是二分不保证结果一定在矩阵里，为什么还能得到正确答案呢？仔细思考后发现，如果每次统计的是小于等于mid的个数，这时如果满足条件，是右边界收缩，最终一定会靠拢到左侧边界（如果真正答案右侧还有同样满足条件的不存在于矩阵中的数，并且肯定左侧不可能有满足条件且不存在于矩阵中的数），这些满足条件的不存在的数，会因为靠拢到左边界而被排除掉，因此最终答案一定是矩阵中的数。 举例子来说：1 3 (4 5 6) 7, k = 2，那么3,4,5,6都会满足check函数，而每次收缩到4,5,6的时候，r都会向3靠拢，直到r = 3。或者理解为l = mid + 1的条件是l一定不满足check函数，那么一定不会收缩到不存在的数字。 class Solution { public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) { int n = matrix.size(), m = matrix[0].size(); int l = matrix[0][0], r = matrix[n - 1][m - 1]; while (l &lt; r) { int mid = l + r &gt;&gt; 1; //如果包含mid更小的值的数量大于等于k个，说明mid要更小才行 if (check(matrix, mid, k)) r = mid; else l = mid + 1; } return l; } bool check(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int mid, int k) { int n = matrix.size(), m = matrix[0].size(); int i = n - 1, j = 0; int cnt = 0; //需要统计所有小于等于mid的值 while (i &gt;= 0 &amp;&amp; j &lt; m) { while (j &lt; m &amp;&amp; matrix[i][j] &lt;= mid) j ++ ; cnt += j; i -- ; } while (i &gt;= 0) { cnt += j; i -- ; } //当这个值&gt;=k的时候，mid可能是第k个，也可能比第k个大 //当&lt;k时，包括mid的这些值全加起来也不到k个，因此答案一定严格大于mid return cnt &gt;= k; } }; LC.315 计算右侧小于当前元素的个数（困难） 由于没有给数据范围，假设数据可以随便在int范围之内取值的话，需要首先离散化。这里离散化时保序的，因为每次需要知道比当前值小的数有多少个，因此保序离散化之后使用树状数组可以得到答案。树状数组可以O(logn)的时间复杂度计算前缀和，将个数作为树状数的存储值。 class Solution { public: vector&lt;int&gt; tr; int n; int lowbit(int x) { return x &amp; -x; } void add(int x, int c) { for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; } int sum(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } int find(int x, vector&lt;int&gt;&amp; count) { int l = 0, r = count.size() - 1; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (count[mid] &lt;= x) l = mid; else r = mid - 1; } return l; } vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ans; vector&lt;int&gt; count; vector&lt;int&gt; temp; for (int i = 0; i &lt; nums.size(); i ++ ) temp.push_back(nums[i]); sort(nums.begin(), nums.end()); nums.erase(unique(nums.begin(), nums.end()), nums.end()); n = nums.size(); tr.resize(n + 1, 0); ans.resize(temp.size(), 0); for (int i = temp.size() - 1; i &gt;= 0; i -- ) { int p = find(temp[i], nums); ans[i] = sum(p); add(p + 1, 1); } return ans; } }; LC.174 地下城游戏（困难） 动态规划的题，但是比较不太好想的是要从公主的房间开始倒着写DP。dp[i][j]表示到坐标为（i,j）的房间时，骑士所需要的最小血量。如果最小血量为负数，那么至少要有1点即可。 class Solution { public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; g) { int n = g.size(), m = g[0].size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m, 1)); //初始化公主所在房间的血量 f[n - 1][m - 1] = max(1, 1 - g[n - 1][m - 1]); //初始化最后一列的所有房间的血量，因为只能向下走，所以是确定的 for (int i = n - 2; i &gt;= 0; i -- ) f[i][m - 1] = max(1, f[i + 1][m - 1] - g[i][m - 1]); //初始化最后一行的所有房间的血量，因为只能向右走，所以是确定的 for (int j = m - 2; j &gt;= 0; j -- ) f[n - 1][j] = max(1, f[n - 1][j + 1] - g[n - 1][j]); //剩余房间的血量是由下方和右方需要血量的最小值决定的，但是不能是负数 for (int i = n - 2; i &gt;= 0; i -- ) for (int j = m - 2; j &gt;= 0; j -- ) f[i][j] = max(1, min(f[i + 1][j] - g[i][j], f[i][j + 1] - g[i][j])); return f[0][0]; } }; LC.1499 满足不等式的最大值（困难） 首先题目给出的性质x从小到大排序，要求的表达式中有绝对值符号，这样我们可以认为定义一个顺序，将绝对值符号去掉。这样就把下标相同的x和y放到一起，可以分开处理。这种方法在之前LC有题目也是这样分开处理的。在题目中限制中需要i和j的x下标之差&lt;=k，意味着当某一个下标确定的时候，另一个下标正好是大小为k的滑动窗口内的最大值时，可以求得整体的最大值。这样抽象之后，可以使用单调队列解决。 //用x作为下标的版本 class Solution { public: int findMaxValueOfEquation(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) { deque&lt;pair&lt;int, int&gt;&gt; q; int res = INT_MIN; for (int i = 0; i &lt; points.size(); i ++ ) { int x = points[i][0], y = points[i][1]; while (q.size() &amp;&amp; x - q.front().first &gt; k) q.pop_front(); if (i &amp;&amp; q.size()) res = max(res, q.front().second + x + y); while (q.size() &amp;&amp; y - x &gt;= q.back().second) q.pop_back(); q.push_back({x, y - x}); } return res; } }; //用i作为下标版本 class Solution { public: int findMaxValueOfEquation(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) { deque&lt;int&gt; q; int res = INT_MIN; for (int i = 0; i &lt; points.size(); i ++ ) { int x = points[i][0], y = points[i][1]; while (q.size() &amp;&amp; x - points[q.front()][0] &gt; k) q.pop_front(); if (q.size()) res = max(res, x + y + points[q.front()][1] - points[q.front()][0]); while (q.size() &amp;&amp; y - x &gt; points[q.back()][1] - points[q.back()][0]) q.pop_back(); q.push_back(i); } return res; } }; LC.1504 统计全1子矩阵 计数的问题重点在于不重不漏，找到某种方法将所有的答案统计在内。这里参考85题的方式来枚举所有的子矩阵，即右下角元素作为矩阵的标志，枚举每次的宽度来不重复的枚举。当然这里也可以使用85题的方式用单调队列优化，得到O(n^2)的时间复杂解法。 这里有点动态规划的思想，就是先需要预处理好以i,j为最下边1的最长个数，这样就变成了84题的问题。 //直接解法O(n^3) class Solution { public: int numSubmat(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int n = mat.size(), m = mat[0].size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) { if (mat[i][j]) { f[i][j] = 1; if (i) f[i][j] += f[i - 1][j]; } } int res = 0; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) { if (f[i][j]) { int w = 1; int s = f[i][j]; res += s; while (j &gt;= w &amp;&amp; f[i][j - w]) { s = min(s, f[i][j - w]); res += s; w ++ ; } } } return res; } }; //O(n^2)的单调队列优化 class Solution { public: int numSubmat(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int n = mat.size(), m = mat[0].size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) { if (mat[i][j]) { f[i][j] = 1; if (i) f[i][j] += f[i - 1][j]; } } int res = 0; for (int i = 0; i &lt; n; i ++ ) { //因为每次计算当前总共个数，涉及到上一个最小位置的结果，要存储一下 stack&lt;pair&lt;int, int&gt;&gt; stk; for (int j = 0; j &lt; m; j ++ ) { int s = 0; //单调递增栈，找左侧第一个小于当前值的位置 while (stk.size() &amp;&amp; f[i][j] &lt;= f[i][stk.top().first]) stk.pop(); if (stk.size()) { //如果栈不空则需要加上当前到上一个最小之间的结果个数 s += (j - stk.top().first) * f[i][j]; //同时左侧第一个更小的结果个数里的每一个，当前也需要加上才对 s += stk.top().second; } else s += (j + 1) * f[i][j]; //如果栈空的话，说明左侧全都比当前的大，那么长度就是j + 1，且没有上一个更小的数了，不存在上边的第二项 stk.push({j, s}); res += s; } } return res; } }; LC.1505 最多K次交换相邻数位后得到的最小整数（困难） 题目首先是贪心性质，对于一个长整数来说，在k次交换之内将可以交换到的最小的数字交换到最高位肯定构造出的数字更小。假设当前最高位不是最小数字，那么一定存在一个和当前一样的交换，将k次之内可交换的最小值交换到最高位，得到的数字严格小于当前值。另外一个贪心性质是，当有多个数字重复的时候，一定是将排位最近的一个换到第一个最节约k的次数，因此之后所能构造出来的整数有可能会更小。 在实现上，可以用10个队列来存储0-9数字的出现位置，并且按照从前到后的顺序遍历得到一个序列，每次从序列头取出元素保证每次得到的都是最靠前的一个数字。另外，每次一个数字经过k次调换到最高位时，相当于将所有最高位和当前位置之间的数字向后挪一位，相当于其下标全部 + 1，可以看做是区间的增加操作，每次获取某一个数的下标偏移量时，相当于求和操作，可以利用树状数组和差分来实现，降低时间复杂度。如果直接使用差分，则求下标的时间复杂度还是O(n)在当前数据规模下不符合要求，因此要使用树状数组来加速操作。 class Solution { public: int n; vector&lt;int&gt; tr; int lowbit(int x) { return x &amp; -x; } void add(int x, int c) { for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; } int sum(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } string minInteger(string num, int k) { n = num.size(); tr.resize(n + 1, 0); //用10个队列存储每一种数字出现的下标，按先后顺序存储 queue&lt;int&gt; q[10]; num = &#39; &#39; + num; for (int i = 1; i &lt;= n; i ++ ) { int t = num[i] - &#39;0&#39;; q[t].push(i); } string ans; //枚举每一位应该是什么数 for (int i = 1; i &lt;= n; i ++ ) { //按顺序从队列里面取，这样先取到的是最小的数，别忘了break for (int j = 0; j &lt; 10; j ++ ) { if (!q[j].size()) continue; //t是在原数组中的下标 int t = q[j].front(); //pos是t + 偏移量之后，最新的下标 int pos = t + sum(t); //这里要判断当前最新下标和正在枚举的位置之前转换次数是否大于k if (pos - i &lt;= k) { ans += j + &#39;0&#39;; //差分，相当于从1到t - 1的下标全部 + 1 //因为所有出队之后的数不会再次用到，并且t位置之前的数字都是按照顺序的 //因此可以直接将1到t - 1都右移1，已经用过的数字没有影响 add(1, 1), add(t, -1); q[j].pop(); k -= pos - i; break; } } } return ans; } }; AW.244 谜一样的牛（简答） 树状数组 + 二分查找。树状数组存储个数的话，存储的是从1~x的所有数个数，如果一定要存储小于x的所有数个数，逻辑会麻烦一些，因此不要那么存。将查找一个数之前有x个数的位置，转换为查找当前数是第x + 1个数，就能符合上述逻辑。 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int tr[N]; int a[N]; int n; int lowbit(int x) { return x &amp; -x; } void add(int x, int c) { for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; } int sum(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } int main() { cin &gt;&gt; n; for (int i = 2; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; //从1~i一共有多少个数 for (int i = 1; i &lt;= n; i ++ ) add(i, 1); for (int i = n; i &gt;= 1; i -- ) { //一个数之前有a[i]个数，则当前数是第a[i] + 1个 int k = a[i] + 1; int l = 1, r = n; while (l &lt; r) { int mid = l + r &gt;&gt; 1; //如果包括自己一共有k个，则当前数就是第k个数 //因为找的是第一个满足k个的位置，所以要求左边界 if (sum(mid) &gt;= k) r = mid; else l = mid + 1; } add(l, -1); a[i] = l; } for (int i = 1; i &lt;= n; i ++ ) cout &lt;&lt; a[i] &lt;&lt; endl; return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"C++原理与使用技巧","slug":"C++原理与使用技巧","date":"2020-06-25T09:44:08.000Z","updated":"2020-06-30T07:54:44.925Z","comments":true,"path":"2020/06/25/C++原理与使用技巧/","link":"","permalink":"/2020/06/25/C++原理与使用技巧/","excerpt":"","text":"C++原理与使用技巧C++语法相关static关键字的使用 函数体内的static作用域是当前函数，表示该变量在下次这个函数调用时，不重新分配，还是上次执行之后的值。 在模块内（一个cpp文件之内）的static全局变量，可以被模块内的所有函数访问，但是模块外的其他函数无法访问。（全局静态变量）。全局和静态不同，全局变量在另一个cpp里可以使用extern来引入，而静态变量不允许被其他cpp引入。 在模块内的static函数只能被当前模块的其他函数调用，外部无法调用。函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。 类中的static成员变量属于整个类所有，对类的所有对象，调用都是同一个。 类中的static成员函数属于整个类所有，函数不接受this指针，因此只能访问static成员变量。 总结：静态的变量和函数都是将变量或者函数限定在了当前cpp文件之中，局部则是多次调用复用。类的静态表示全类共有的东西。 C/C++ 中指针和引用的区别 指针有自己的一块空间，而引用只是一个别名； 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小； 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用； 作为参数传递时，指针需要被解引用(*操作)才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象； 可以有const指针，但是没有const引用； 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变； 指针可以有多级指针（**p），而引用只有一级； 指针和引用使用++运算符的意义不一样，指针是指向下一个地址，引用代表所引用对象值+1； 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。 智能指针C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。unique_ptr是多个指针不能同时指向一个对象，shared_ptr可以指向同一个。weak_ptr不会改变shared_ptr的引用计数。 智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。 当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。（因为引用计数不会为0）为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。 c++11 weak_ptr使用 C++STL相关map和set的区别以及底层实现map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。 map和set区别在于： map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。 set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。 map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"从《广场协议》看近代日本经济","slug":"从《广场协议》看近代日本经济","date":"2020-06-18T05:24:25.000Z","updated":"2020-06-26T09:45:59.439Z","comments":true,"path":"2020/06/18/从《广场协议》看近代日本经济/","link":"","permalink":"/2020/06/18/从《广场协议》看近代日本经济/","excerpt":"","text":"从《广场协议》看近代日本经济日本经过二战之后几十年的经济发展，很快的从战败的萧条中走了出来，曾经成为仅次于美国的全球第二大经济体，然而又在极短的时间内经济全面崩盘，成为“失去的十年”，直到今天也没有完全恢复往日的荣光。对如此戏剧性的快速发展和衰败，到底是什么原因导致了近代日本的经济过山车式的发展？ 首先我们从时间顺序上，以历史的角度看一看日本从二战到现在的经济是如何繁荣的。 首先在政治上，二战结束之后，日本作为战败国成为了美国的占领区。事实上日本应该是被当时苏联、美国、中国和英国四个战胜国分区占领，但除了美国之外其他国家并没有真正履行约定，最后实际由美国占领并且管控。因此从政治上讲，二战之后，日本部分的失去了自己的主权，比如从军队来看，日本无法拥有真正的海陆军，只能最多拥有自卫队。 战后的日本经济的腾飞，是通过朝鲜战争、越南战争和1964年的东京奥运会实现的。朝鲜战争和越南战争期间，日本作为美国军火和物资最大生产地，每年从美国有几十亿美元的收入。日本曾经多次申请举办奥运会，最早的一次在1940年，但是由于日本在当时进行了全面侵华战争，所以奥运会因为战争搁浅。1952年，日本终于成功申请到了1964年东京奥运会的举办资格。日本国民都将此次奥运会作为一次增强国民信心，对外展示日本战后发展的机会。在奥运会之后，日本吸引了全世界的投资，经济进一步发展。 《广场协议》是1985年美国和日本、西德、英国、法国签署的协议，内容是联合干预外汇市场，使美元对日元及德国马克等主要货币贬值，解决美国贸易赤字的问题。由于日本经济的发展和工业化的逐步成型，生产的产品质量好且比美国本土廉价。美国本土的生产企业认为由于美元对日本汇率高，因此卖不出去东西的原因是美元太贵了，不利于出口，因此向政府施压要求签署协议使得日元升值，美元贬值，得以增加出口。 《广场协议》本质是几个国家通过抛售美元，操纵汇率的协议。本来美国和日本双方都有所诉求，心怀鬼胎，但事实上最终对于美国和日本两方都没有达到自己的目的： 美国想通过美元贬值刺激出口，增加国内企业在世界领域产品的竞争力。 日本如果同意日元升值，本质上是牺牲了国内出口企业的利益。但是日元升值有几个好处：第一，石油价格暴涨，石油是由美元结算，因此日元升值有利于日本进口石油。第二，日元升值对于日本人民来说是好事，购买力上升，可以在国外进口更多的商品。第三，日本由于在政治、军事上依靠美国，且最近贸易逆差的确很大，因此日本需要帮助美国解决这个问题。而事实上，经过日本政府测算，日元升值区间在10%至20%之间时，日本企业是可以承受的。 但是由于日本企业在日元升值之后更进一步控制成本，导致即便日元升值也可以通过压缩成本进一步降低价格。这样一来导致美国的商品仍旧在世界范围内不会比日本有更好的竞争力。对于日本，如果日元持续升值，能降低成本的手段都用完了，日本企业只能把自己的生产线转移到人力物力更便宜的地方，比如东南亚、中国。把工厂开到外国，而日本的工人只能失业了。 日本人低估了金融市场的变化，金融市场向来是非理性化的。在1986年1月22日电视屏幕下方路透社新闻栏滑过了一行字：“竹下藏相言明可以接受190左右的日元汇率”。由此日本市场开始了日元升值的疯狂循环。日元最终由于日本政府对于升值的放任态度，导致市场恶性循环失控了。 由于日元的疯狂升值，日本很多小企业最终扛不住了。日本政府这时候进行了错误的决策，认为只要降低银行贷款利息，企业贷款更加方便，有了钱，升值带来的压力就会减小。但是拿了钱的投资人不会去投资给利润低的制造业，而是直接进入了股市和房地产。这样就进一步加大了泡沫经济，使得本就虚浮的实体经济更加无人问津。 但是实体经济才是一个国家的命脉，炒起来的股市和房市泡沫很大，一旦泡沫破了，没有制造业兜底，整个国家的经济就会崩盘。日本政府似乎也意识到了这个问题，因此再次出手，想让过热的股市和楼价降温。日本政府又祭出了5年前使用过的那招——调利率，只不过这次是往高调，而且调整的幅度太大了，1989年5月至1990年8月，日本银行五次上调中央银行的利率，从2.5％升到了6％。这是日本政府的第二次决策失误，导致了过热的经济直接硬着陆。最终导致日本的股市连带房市暴跌，银行大量坏账。 说到这里，真正的问题不在于《广场协议》，而在于日本自己的脱实向虚。金融业吸引资金的能力天生就很强，很容易就吸走实体经济的血液。日本的教训已经说明了，金融业固然不可或缺，但绝不能缺乏政府的管束，任凭其疯狂扩张。 参考资料知乎.被误读的“广场协议”：日本是如何把自己玩死的？ 维基百科.广场协议 B站.骁话一下：面对疫情日本为什么不取消奥运？带你算算政治经济社会三本账 B站.巫师财经：日本经济崩盘始末","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"高精度","slug":"高精度","date":"2020-06-15T08:20:48.000Z","updated":"2020-06-15T09:14:39.334Z","comments":true,"path":"2020/06/15/高精度/","link":"","permalink":"/2020/06/15/高精度/","excerpt":"","text":"高精度高精度加法和乘法原理高精度加法和高精度乘法用在某些题目中成为一个模块，不会单独出现，基本方法是用一个数组或者vector来模拟竖式加法和乘法。有些题目分析之后可能可以用double来代替高精度。 模板#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; //高精度加法 vector&lt;int&gt; add(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) { vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || i &lt; B.size() || t; i ++ ) { if (i &lt; A.size()) t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } return C; } //高精度乘法 vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b) { vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || t; i ++ ) { if (i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } //12345 * 0; while (!C.back() &amp;&amp; C.size() &gt; 1) C.pop_back(); return C; } int main() { string a, b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A, B; for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#39;0&#39;); for (int i = b.size() - 1; i &gt;= 0; i -- ) B.push_back(b[i] - &#39;0&#39;); auto C = add(A, B); for (int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i]; cout &lt;&lt; endl; return 0; } 高精度除法原理高精度加法和乘法方法如同竖式一样，高精度除法是余数每次乘10之后加上当前位除以被除数。没有涉及到两个大数相乘和相除的问题，具体方法要更加复杂。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"BFS","slug":"BFS","date":"2020-06-15T08:05:03.000Z","updated":"2020-06-28T06:20:16.202Z","comments":true,"path":"2020/06/15/BFS/","link":"","permalink":"/2020/06/15/BFS/","excerpt":"","text":"BFS标准BFS原理通过队列每次将邻接点加入，多层扩展，BFS可以求得边权为1的情况下的最短路径，因为当第一次搜索到的都是，就是最短路径。BFS要注意元素不要在出队的时候判重，要在入队之前设置为已经遍历。 模板int dx[] = {0, -1, 0, 1}, dy[] = {1, 0, -1, 0}; int dis = 0; while (q.size()) { int len = q.size(); for (int i = 0; i &lt; len; i ++ ) { auto t = q.front(); int x = t.first, y = t.second; q.pop(); //如果是这里标记，队列里面有大量相同元素，虽然不影响最终得到正确结果，但是效率很低 //A[x][y] = -1; for (int i = 0; i &lt; 4; i ++ ) { int a = x + dx[i], b = y + dy[i]; if (a &lt; 0 || a &gt;= A.size() || b &lt; 0 || b &gt;= A[0].size()) continue; if (A[a][b] == -1) continue; if (A[a][b] == 1) return dis; //就是这里要在入队之前将当前入队元素标记为已经遍历 A[a][b] = -1; q.push({a, b}); } } dis ++ ; } 多源BFS原理通过设置超级源点，可以将多个分散的源点合并为一个，可以解决一个点到另外多个点的最短距离问题。我们从超级源点开始做单源BFS，发现原先的多个源点只不过是BFS的第二层而已，所以多源BFS没有改变BFS的本质，不会影响结果的正确性。 例题LC.1162 地图分析（中等） 双端队列BFS原理双端队列BFS可以解决图中权重仅为0和1时的情况，相当于简化的dijkstra算法，可以更快的（时间复杂度为O(m))搜到想要的答案。使用一个双端队列，队列头插入搜索权重为0的节点，队列尾插入权重为1的节点，每次从队头扩展，可以尽早的扩展那些权重为0的边，相比于BFS更快的搜索到答案。 模板#include &lt;deque&gt; void bfs() { memset(dist, 0x3f, sizeof dist); memset(st, 0, sizeof st); deque&lt;int&gt; q; q.push_back(1); while(q.size()) { int t = q.front(); q.pop_front(); if (st[t]) continue; st[t] = true; for (int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!w[i]) q.push_front(j); else q.push_back(j); } } } } 例题AW.175 电路维修（简单） AW.340 通信线路（中等） 这题是二分+双端广搜","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"快速幂","slug":"快速幂","date":"2020-06-11T06:12:16.000Z","updated":"2020-06-11T06:50:00.777Z","comments":true,"path":"2020/06/11/快速幂/","link":"","permalink":"/2020/06/11/快速幂/","excerpt":"","text":"快速幂原理&emsp;&emsp;可以在log(k)的时间复杂度下计算a^k (mod p)的值。将k以2进制展开，其中的每一个1相当于乘以a^(2^m)。 假设 k的二进制表示为10010101: a^k = a^{2^0} * a^{2^2} * a^{2^4} * a^{2^7}模板LL qmi(LL a, LL k, LL p) { LL res = 1; while (k) { if (k &amp; 1) { res = res * a % p; a = a * a % p; } k &gt;&gt;= 1; } return res; } 例题AW.875 快速幂（简单） AW.876 快速幂求逆元（简单） 快速幂求逆元用到了费马小定理，是扩展欧几里得定理的一个特例","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2020-06-08T14:02:01.000Z","updated":"2020-06-08T14:02:23.660Z","comments":true,"path":"2020/06/08/KMP算法/","link":"","permalink":"/2020/06/08/KMP算法/","excerpt":"","text":"KMP算法原理&emsp;&emsp;KMP算法核心是ne数组，其定义是：从0（空串）到第i个模板串字符的子串为止，子串中前缀和后缀相等的最大长度，其中前缀和后缀不包括子串本身。 &emsp;&emsp;举例来说，对于字符串ababab（按照下标从1开始存储，更为方便）： ne[0]总是0的原因是空串最长前缀也是0。 ne[1] = 0的原因是长度为1的子串前缀如果不包括子串本身，也只有长度为0的空串，因此也是0。 ne[2] = 0，(ab)abab此时子串ab的前缀没有和后缀相等的匹配。 ne[3] = 1，(aba)bab的前缀可以看到下s[1] = a和s[3] = a相等。 ne[4] = 2，(abab)ab的前缀可以看到{s[1], s[2]} = ab和{s[3], s[4]} = ab相等，这里由于只增加了一个字母，且当前最长前缀用到了长度为3子串时的最长前缀，所以最长前缀长度最多增加1，这一点很重要，是动态规划的思想。 ne[5] = 3，(ababa)b，可以看到{s[1], s[2], s[3]} = aba和{s[3], s[4], s[5]} = aba相等。 ne[6] = 4，（ababab), abab = abab。 &emsp;&emsp;通过ne数组的定义，我们可以知道，当模板串和匹配串两个字符不匹配的时候，此时模板串的匹配位置就不必向后错一个位置继续从头匹配，而是从下一个前缀已经匹配完全的位置开始。 &emsp;&emsp;这里通过将开始下标设置为1，之前定义的ne数组是前后缀的最大长度，正好也是当不匹配时，模板串应该移动到的下标位置。 &emsp;&emsp;KMP算法求模板串ne数组的方法实际上是一种动态规划。每次使用了之前模板串中相同的长度，并且每次最长前缀最多+1，来计算下一次的最长前缀。当无法匹配的时候，正好通过定义j = ne[j]来跳到最大匹配位置继续。 模板//n是模板串长度，m是匹配串长度 //p存储模板串，s存储匹配串 //产生ne数组的过程，模板串自己和自己匹配 for (int i = 2, j = 0; i &lt;= n; i ++ ) { while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } //在匹配串中匹配的过程 for (int i = 1, j = 0; i &lt;= m; i ++ ) { while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == n) { //输出位置etc. j = ne[j]; } } 例题AW.831 KMP字符串（简单）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"位运算","slug":"位运算","date":"2020-06-04T06:26:01.000Z","updated":"2020-06-08T05:30:25.427Z","comments":true,"path":"2020/06/04/位运算/","link":"","permalink":"/2020/06/04/位运算/","excerpt":"","text":"位运算亦或运算&emsp;&emsp;亦或运算本质是定义了一组操作，0^0 = 0, 1^1 = 0, 1^0 = 1, 0^1 = 1，描述为相同为0，不同为1。从定义来看，可以判断两个数是否相同，如果为0则相同，为1则不同。进一步，由于有结合律，可以消除一个序列中所有相同的数组，即a^b^c = (a^b)^c = a^(b^c)。在进一步思考，其实所有能够满足上述运算规律的情况都可以用亦或运算来实现，简单有效。比如无进位二进制加法，实际上与0+0 = 0, 1+1 = 0, 1+0 = 1, 0+1 = 1相同。奇偶性检验，如果我们把奇数看做1，偶数看做0，则有0+0 = 0, 1+1 = 0, 1 + 0 = 1, 0 + 1 = 1，和亦或操作一样。凡是有两个相反、相对的状态，都可以抽象为 0 和 1。另外对于奇偶性一般都会有简单的考察：奇数+奇数 = 偶数，以及奇数 - 1 = 偶数这两条基本性质。 ​ 状态压缩题目中一般应用按位与、或和亦或运算会将状态之间的转换变得容易很多。包括如果想取得某一位的状态，可以用 i &gt;&gt; j &amp; 1来计算。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"欧几里得算法","slug":"欧几里得算法","date":"2020-06-04T06:26:01.000Z","updated":"2020-06-11T07:06:36.122Z","comments":true,"path":"2020/06/04/欧几里得算法/","link":"","permalink":"/2020/06/04/欧几里得算法/","excerpt":"","text":"欧几里得算法原理&emsp;&emsp;gcd可以计算两个数的最大公约数。欧几里得算法通过递归来计算最大公约数。基本情况是当b为0时，a和b的最大公约数就是a。 模板int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 扩展欧几里得算法","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"数据结构","slug":"高级数据结构","date":"2020-06-04T06:26:01.000Z","updated":"2020-07-11T13:48:26.133Z","comments":true,"path":"2020/06/04/高级数据结构/","link":"","permalink":"/2020/06/04/高级数据结构/","excerpt":"","text":"数据结构并查集&emsp;&emsp;并查集重点在于通过集合维护什么额外信息来解决问题。额外信息可以是集合内元素数量、当前元素和根节点的距离。当前元素和根节点的距离可以用来维护多个相互关系。 堆&emsp;&emsp;在动态的求中位数时，可以用对顶堆，上边是一个小根堆，下边是一个大根堆，用来维护中位数在中间。 Trie树&emsp;&emsp;Trie树又叫字典树，可以快速插入和查询某一字符串是否在当前集合之中。限制条件是当前字符集合所有字符总数不能太大，否则效率低下且耗费空间。 &emsp;&emsp;这里存储树是通过son[N][26]类型的二维数组来存储，本质是一个单向查询函数，其中son的第一个维度为当前指针地址，用idx从0开始分配。树根被分配为0，之后依次分配地址递增。第二个维度26是当前确定的字符，当确定了当前节点和当前字符之后，就确定了son中存储值，即下一个节点的地址。通过这种逻辑来用数组存储树和图是一种较为方便和快捷的方法。 &emsp;&emsp;AC自动机是Trie树和KMP算法的结合，通过KMP算法的ne数组在Trie树上进行匹配，完成多个模板串在某一原串中出现次数的统计。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"生活","slug":"生活","date":"2020-06-01T14:16:01.000Z","updated":"2020-06-04T06:30:41.296Z","comments":true,"path":"2020/06/01/生活/","link":"","permalink":"/2020/06/01/生活/","excerpt":"","text":"生活近期更新，敬请期待~","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"读书笔记","slug":"读书","date":"2020-06-01T14:16:01.000Z","updated":"2020-06-04T06:30:48.012Z","comments":true,"path":"2020/06/01/读书/","link":"","permalink":"/2020/06/01/读书/","excerpt":"","text":"读书笔记近期更新，敬请期待~","categories":[{"name":"读书","slug":"读书","permalink":"/categories/读书/"}],"tags":[],"keywords":[{"name":"读书","slug":"读书","permalink":"/categories/读书/"}]}]}